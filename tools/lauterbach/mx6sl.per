; i.MX6 Series Peripheral Register Definitions

config 16. 8.
width 12.

tree "Cortex-A9 Registers"
width 0x8
;##################################################
; Identification registers
;##################################################
tree "ID Registers"

rgroup.long c15:0x0++0x0
 line.long 0x0 "MIDR,Main ID Register"
  hexmask.long.byte 0x0 24.--31. 0x1 " IMPL       ,Implementer code"
  bitfld.long 0x0 20.--23.  "              VAR        ,Variant" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
  bitfld.long 0x0 16.--19.  "             ARCH      , Architecture" "Pre-ARMv7,Pre-ARMv7,Pre-ARMv7,Pre-ARMv7,Pre-ARMv7,Pre-ARMv7,Pre-ARMv7,Pre-ARMv7,Pre-ARMv7,Pre-ARMv7,Pre-ARMv7,Pre-ARMv7,Pre-ARMv7,Pre-ARMv7,Pre-ARMv7,ARMv7"
  textline "                 "
  hexmask.long.word 0x0 4.--15. 0x1 " PART       ,Primary Part Number"
  bitfld.long 0x0 0.--3. "            REV        ,Revision Number" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

rgroup.long c15:0x100++0x0
 line.long 0x0 "CTR,Cache Type Register"
  bitfld.long 0x0 29.--31. " FORMAT     ,Format" "Not ARMv7,Not ARMv7,Not ARMv7,Not ARMv7,ARMv7,Not ARMv7,Not ARMv7,Not ARMv7"
  bitfld.long 0x0 24.--27. "       CWG        ,Cache Writeback Granule" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
  textline "                 "
  bitfld.long 0x0 20.--23. " ERG        ,Exclusives Reservation Granule" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
  bitfld.long 0x0 16.--19. "              DMINLINE   ,D-Cache Minimum Line Size" "1 word,2 words,4 words,8 words,16 words,32 words,64 words,128 words,256 words,512 words,1024 words,2048 words,4096 words,8192 words,16384 words,32768 words"
  textline "                 "
  bitfld.long 0x0 14.--15. " L1POLICY   ,L1 Instruction cache policy" "Reserved,ASID,Virtual,Physical"
  bitfld.long 0x0 0.--3. "        IMINLINE   ,I-Cache Minimum Line Size" "1 word,2 words,4 words,8 words,16 words,32 words,64 words,128 words,256 words,512 words,1024 words,2048 words,4096 words,8192 words,16384 words,32768 words"

rgroup.long c15:0x200++0x0
 line.long 0x0 "TCMTR,Tighly-Coupled Memory Type Register"

rgroup.long c15:0x300++0x0
 line.long 0x0 "TLBTR,TLB Type Register"
  hexmask.long.byte 0x0 16.--23. 0x1 " ILSIZE     ,Specifies the number of instruction TLB lockable entries"
  hexmask.long.byte 0x0 8.--15. 0x1 "              DLSIZE     ,Specifies the number of unified or data TLB lockable entries"
  bitfld.long 0x0 1. "             TLB_size  ,TLB Size" "64,128"
  textline "                 "
  bitfld.long 0x0 0. " nU         ,Unified or Separate TLBs" "Unified,Separate"
  
rgroup.long c15:0x500++0x0
 line.long 0x0 "MPIDR,Multiprocessor Affinity Register"
  bitfld.long 0x00 30. " U          ,Processor is part of a multiprocessor or uniprocessor system" "Multiprocessor,Uniprocessor"
  bitfld.long 0x00 8.--11. "  ClusterID  ,Value read in CLUSTERID configuration pins" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
  bitfld.long 0x00 0.--1. "             CPUID     ,Value depends on the number of configured CPUs" "0,1,2,3"

rgroup.long c15:0x0410++0x00
 line.long 0x00 "MMFR0,Memory Model Feature Register 0"
  bitfld.long 0x00 24.--27. " FCSE       ,Fast Context Switch Memory Mappings Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 20.--23. "   ACR        ,Auxiliary Control Register Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 16.--19. "      TCM       ,TCM and Associated DMA Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
    bitfld.long 0x00 12.--15. " OSS        ,Outer Shareable Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 8.--11. "   CC_CPUA    ,Cache Coherency Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 4.--7. "      PMSA      ,Physical Memory System Architecture (PMSA) Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 0.--3. " VMSA       ,Virtual Memory System Architecture (VMSA) Support" "Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"   
rgroup.long c15:0x0510++0x00
 line.long 0x00 "MMFR1,Memory Model Feature Register 1"
  bitfld.long 0x00 28.--31. " BTB        ,Branch Predictor" "Reserved,Reserved,Required,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 24.--27. "        L1TCO      ,Test and Clean Operations on Data Cache/Harvard/Unified Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 20.--23. "  L1UCMO    ,L1 Cache/All Maintenance Operations/Unified Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 16.--19. " L1HCMO     ,L1 Cache/All Maintenance Operations/Harvard Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 12.--15. "   L1UCLMOSW  ,L1 Cache Line Maintenance Operations by Set and Way/Unified Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 8.--11. "  L1HCLMOSW ,L1 Cache Line Maintenance Operations by Set and Way/Harvard Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 4.--7. " L1UCLMOMVA ,L1 Cache Line Maintenance Operations by VA/Unified Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 0.--3. "   L1HCLMOMVA ,L1 Cache Line Maintenance Operations by VA/Harvard Architecture" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved" 
rgroup.long c15:0x0610++0x00
 line.long 0x00 "MMFR2,Memory Model Feature Register 2"
  bitfld.long 0x00 28.--31. " HAF        ,Hardware Access Flag Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 24.--27. "   WFI        ,Wait for Interrupt Stalling Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 20.--23. "      MBF       ,Memory Barrier Operations Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 16.--19. " UTLBMO     ,TLB Maintenance Operations/Unified Architecture Support" "Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 12.--15. "       HTLBMO     ,TLB Maintenance Operations/Harvard Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 8.--11. "  HL1CMRO   ,Cache Maintenance Range Operations/Harvard Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 4.--7. " HL1BPCRO   ,Background Prefetch Cache Range Operations/Harvard Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 0.--3. "   HL1FPCRO   ,Foreground Prefetch Cache Range Operations/Harvard Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
rgroup.long c15:0x0710++0x00
 line.long 0x00 "MMFR3,Memory Model Feature Register 3"
  bitfld.long 0x00 28.--31. " SS         ,Supersection support" "Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 20.--23. "       CW         ,Coherent walk" "Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 12.--15. "      MB        ,Invalidate broadcast Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 8.--11. " BPM        ,Invalidate Branch predictor Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 4.--7. "       HCMOSW     ,Invalidate Cache by Set and Way/Clean by Set and Way/Invalidate and Clean by Set and Way Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 0.--3. "      HCMOMVA   ,Invalidate Cache MVA Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"    
rgroup.long c15:0x0020++0x00
 line.long 0x00 "ISAR0,Instruction Set Attribute Register 0"
  bitfld.long 0x00 24.--27. " DIVI       ,Divide Instructions Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 20.--23. "   DEBI       ,Debug Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 16.--19. "      CI        ,Coprocessor Instructions Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 12.--15. " CBI        ,Combined Compare and Branch Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 8.--11. "       BI         ,Bitfield Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 4.--7. "      BCI       ,Bit Counting Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 0.--3. " SI         ,Swap Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"   
rgroup.long c15:0x0120++0x00
 line.long 0x00 "ISAR1,Instruction Set Attribute Register 1"
  bitfld.long 0x00 28.--31. " JI         ,Jazelle Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 24.--27. "       INTI       ,Interwork Instructions Support" "Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 20.--23. "      IMMI      ,Immediate Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 16.--19. " ITEI       ,If Then Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 12.--15. "       EXTI       ,Extend Instructions Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 8.--11. "      E2I       ,Exception 2 Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 4.--7. " E1I        ,Exception 1 Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 0.--3. "       ENDI       ,Endian Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"   
rgroup.long c15:0x0220++0x00
 line.long 0x00 "ISAR2,Instruction Set Attribute Register 2"
  bitfld.long 0x00 28.--31. " RI         ,Reversal Instructions Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 24.--27. "       PSRI       ,PSR Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 20.--23. "      UMI       ,Advanced Unsigned Multiply Instructions Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 16.--19. " SMI        ,Advanced Signed Multiply Instructions Support" "Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 12.--15. "       MI         ,Multiply Instructions Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 8.--11. "      II        ,Multi-Access Interruptible Instructions Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 4.--7. " MHI        ,Memory Hint Instructions Support" "Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 0.--3. "       LSI        ,Load and Store Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
rgroup.long c15:0x0320++0x00
 line.long 0x00 "ISAR3,Instruction Set Attribute Register 3"
  bitfld.long 0x00 28.--31. " T2E        ,Thumb-2 Extensions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 24.--27. "       NOPI       ,True NOP Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 20.--23. "      TCI       ,Thumb Copy Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 16.--19. " TBI        ,Table Branch Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 12.--15. "       SPI        ,Synchronization Primitive Instructions Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 8.--11. "      SVCI      ,SVC Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 4.--7. " SIMDI      ,Single Instruction Multiple Data (SIMD) Instructions Support" "Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 0.--3. "       SI         ,Saturate Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"    
rgroup.long c15:0x0420++0x00
 line.long 0x00 "ISAR4,Instruction Set Attribute Register 4"
  bitfld.long 0x00 28.--31. " SWP_frac   ,SWAP_frac" "Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 24.--27. "       PSR_M_I    ,PSR_M Instructions Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 20.--23. "  SPRI      ,Synchronization Primitive instructions" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 16.--19. " BI         ,Barrier Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 12.--15. "       SMCI       ,SMC Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 8.--11. "      WBI       ,Write-Back Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
    textline "                 "
  bitfld.long 0x00 4.--7. " WSI        ,With-Shift Instructions Support" "Reserved,Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 0.--3. "       UI         ,Unprivileged Instructions Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"     
rgroup.long c15:0x0520++0x00
 line.long 0x00 "ISAR5,Instruction Set Attribute Registers 5 (Reserved)"
rgroup.long c15:0x0620++0x00
 line.long 0x00 "ISAR6,Instruction Set Attribute Registers 6 (Reserved)"
rgroup.long c15:0x0720++0x00
 line.long 0x00 "ISAR7,Instruction Set Attribute Registers 7 (Reserved)"   
rgroup.long c15:0x0010++0x00
 line.long 0x00 "PFR0,Processor Feature Register 0"
  bitfld.long 0x00 12.--15. " State3     ,Thumb-2 Execution Environment (Thumb-2EE) Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 8.--11. "       State2     ,Java Extension Interface Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 4.--7. "      State1    ,Thumb Encoding Supported by the Processor Type" "Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 0.--3. " State0     ,ARM Instruction Set Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
rgroup.long c15:0x0110++0x00
 line.long 0x00 "PFR1,Processor Feature Register 1"
  bitfld.long 0x00 8.--11. " MPM        ,Microcontroller Programmer's Model Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 4.--7. "   SE         ,Security Extensions Architecture v1 Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 0.--3. "      PM        ,Standard ARMv4 Programmer's Model Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
rgroup.long c15:0x0210++0x00
 line.long 0x00 "DFR0,Debug Feature Register 0"
  bitfld.long 0x00 20.--23. " MDM_MM     ,Microcontroller Debug Model Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 16.--19. "   TDM_MM     ,Trace Debug Model (Memory-Mapped) Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 12.--15. "      TDM_CB    ,Coprocessor-Based Trace Debug Model Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 8.--11. " CDM_MM     ,Memory-Mapped Debug Model Support" "Reserved,Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 4.--7. "       SDM_CB     ,Secure Debug Model (Coprocessor) Support" "Reserved,Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 0.--3. "      CDM_CB    ,Coprocessor Debug Model Support" "Reserved,Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
rgroup.long c15:0x0310++0x00
 line.long 0x00 "AFR0,Auxiliary Feature Register 0"
  hexmask.long 0x00 0.--31. 1. " AF         ,Auxiliary Feature"
tree.end
width 0x8
tree "System Control and Configuration"

group.long c15:0x1++0x0
 line.long 0x0 "SCTLR,Control Register"
  bitfld.long 0x0 30. " TE       ,Thumb exception enable" "ARM,Thumb"
  bitfld.long 0x0 29. "        AFE      ,Access Flag Enable" "Disabled,Enabled"
  bitfld.long 0x0 28. "     TRE      ,TEX remap enable" "Disabled,Enabled"
  textline "                 "
  bitfld.long 0x0 27. " NMFI     ,DNonmaskable Fast Interrupt enable" "Disabled,Enabled"
  bitfld.long 0x0 25. "     EE       ,Exception endianess" "Little,Big"
  bitfld.long 0x0 14. "       RR       ,Replacement strategy for caches, BTAC, and micro TLBs" "Random,Round robin"
  textline "                 "
  bitfld.long 0x0 13. " V        ,Base Location of Exception Registers" "0x00000000,0xFFFF0000"
  bitfld.long 0x0 12. "   I        ,Instruction Cache Enable" "Disabled,Enabled"
  bitfld.long 0x0 11. "     Z        ,Branch Prediction Enable" "Disabled,Enabled"
  textline "                 "
  bitfld.long 0x0 10. " SW       ,SWP/SWPB Enable" "Disabled,Enabled"
  bitfld.long 0x0 2. "     C        ,Enable unified cache or data cache" "Disabled,Enabled"
  bitfld.long 0x0 1. "     A        ,Strict Alignment" "Disabled,Enabled"
  textline "                 "
  bitfld.long 0x0 0. " M        ,MMU or Protection Unit" "Disabled,Enabled"   
group.long c15:0x101++0x0
 line.long 0x0 "ACTLR,Auxiliary Control Register"
  bitfld.long 0x00 9. " PARON    ,Parity On" "Disabled,Enabled"
     bitfld.long 0x00 7. "     EXCL     ,Exclusive cache Enable" "Disabled,Enabled"
  bitfld.long 0x00 6. "     SMP      ,Signals if the Cortex-A9 processor is taking part in coherency or not" "0,1"
  textline "                 "
  bitfld.long 0x00 3. " FOZ      ,Full Of Zero mode Enable" "Disabled,Enabled"
  bitfld.long 0x00 2. "     DP1      ,L1 Dside prefetch Enable" "Disabled,Enabled"   
  bitfld.long 0x00 1. "     DP2      ,L2 Dside prefetch Enable" "Disabled,Enabled"   
  textline "                 "
  bitfld.long 0x00 0. " FW       ,Cache and TLB maintenance broadcast" "Disabled,Enabled"   
group.long c15:0x201++0x0
 line.long 0x0 "CPACR,Coprocessor Access Control Register"
  bitfld.long 0x0 31. " ASEDIS   ,Disable Advanced SIMD Extension functionality" "No,Yes"
  bitfld.long 0x0 30. "          D32DIS   ,Disable use of D16-D31 of the VFP register file" "No,Yes"
  bitfld.long 0x0 22.--23. "          CP11     ,Coprocesor access control" "Denied,Privileged,Reserved,Full"
  textline "                 "
  bitfld.long 0x0 20.--21. " CP10     ,Coprocesor access control" "Denied,Privileged,Reserved,Full"
 textline " "
 
group.long c15:0x11++0x0
 line.long 0x0 "SCR,Secure Configuration Register"
  bitfld.long 0x00 6. " nET      ,Not early termination" "Not early,Early"
  bitfld.long 0x00 5. "    AW       ,Controls whether the Non-secure world can modify the A-bit in the CPSR" "Not allowed,Allowed"
  bitfld.long 0x00 4. "  FW       ,FW-bit controls whether the Non-secure world can modify the F-bit in the CPSR" "Not allowed,Allowed"
  textline "                 "
  bitfld.long 0x00 3. " EA       ,External Abort  exceptions handled in Abort mode or Monitor mode" "Abort,Monitor"
  bitfld.long 0x00 2. "      FIQ      ,FIQ exceptions handled in Abort mode or Monitor mode" "FIQ,Monitor"
  bitfld.long 0x00 1. "      IRQ      ,IRQ exceptions handled in Abort mode or Monitor mode" "IRQ,Monitor"
  textline "                 "
  bitfld.long 0x00 0. " NS       ,Secure mode " "Secure,Non-secure"
group.long c15:0x111++0x0
 line.long 0x0 "SDER,Secure Debug Enable Register"
  bitfld.long 0x00 1. " SUNIDEN  ,Non-Invasive Secure User Debug Enable bit" "Denied,Permitted"
  bitfld.long 0x00 0. "    SUIDEN   ,Invasive Secure User Debug Enable bit" "Denied,Permitted"   
group.long c15:0x0211++0x00
 line.long 0x00 "NSACR,Non-Secure Access Control Register"
  bitfld.long 0x00 18. " NS_SMP   ,Determines if the SMP bit of the Auxiliary Control Register is writable in Non-secure state" "Disabled,Enabled"
  bitfld.long 0x00 17. "     TL       ,Lockable Page Table Entries Allocation in Nonsecure World" "Denied,Permitted"
  bitfld.long 0x00 15. "    NSASEDIS ,Disable Non-secure Advanced SIMD Extension functionality" "Denied,Permitted"
  textline "                 "
  bitfld.long 0x00 14. " NSD32DIS ,Disable the Non-secure use of D16-D31 of the VFP register" "Denied,Permitted"
    bitfld.long 0x00 11. "    CP11     ,Coprocessor 11 in the Nonsecure World Access Permission" "Denied,Permitted"
  bitfld.long 0x00 10. "    CP10     ,Coprocessor 10 in the Nonsecure World Access Permission" "Denied,Permitted"
group.long c15:0x0311++0x00
 line.long 0x00 "VCR,Virtualization Control Register"
  bitfld.long 0x00 8. " AMO      ,Abort Mask Override" "0,1"
  bitfld.long 0x00 7. "            IMO      ,IRQ Mask Override" "0,1"
  bitfld.long 0x00 6. "            IFO      ,FIQ Mask Override" "0,1"
 textline " "
 
group.long c15:0x000c++0x00
 line.long 0x00 "VBAR,Secure or Nonsecure Vector Base Address Register"
  hexmask.long 0x00 5.--31. 0x20 " VBA      ,Base Address"
group.long c15:0x10c++0x00
 line.long 0x0 "MVBAR,Monitor Vector Base Address Register"
  hexmask.long 0x00 5.--31. 0x20 " MVBA     , Monitor Vector Base Address"
rgroup.long c15:0x1C++0x0
 line.long 0x0 "ISR,Interrupt status Register"
  bitfld.long 0x0 8. " A        ,Pending External Abort" "Not pending,Pending"
  bitfld.long 0x0 7. "  I        ,Pending IRQ" "Not pending,Pending"
  bitfld.long 0x0 6. "  F        ,Pending FIQ" "Not pending,Pending"
group.long c15:0x11c++0x0
 line.long 0x00 "VIR,Virtualization Interrupt Register"
  bitfld.long 0x00 8. " VA       ,Virtual Abort" "0,1"
  bitfld.long 0x00 7. "            VI       ,Virtual IRQ" "0,1"
  bitfld.long 0x00 6. "            VF       ,Virtual FIQ" "0,1"
 textline " "

group.long c15:0xf++0x0
 line.long 0x00 "PCR,Power Control Register"
  bitfld.long 0x00 8.--10. " MCL      ,Max Clock Latency" "0,1,2,3,4,5,6,7"
  bitfld.long 0x00 0. "            EDCG     ,Enable Dynamic Clock Gating" "Disabled,Enabled"
group.long c15:0x1f++0x0
 line.long 0x00 "NEONBR,NEON Busy Register"
  bitfld.long 0x00 0. " BUSY     ,NEON Busy" "No,Yes"
group.long c15:0x400f++0x0
 line.long 0x00 "CBAR,Configuration Base Address Register"
  hexmask.long 0x00 0.--31. 1. " CBAR     ,Configuration Base Address Register"
tree.end

width 0x0d
tree "Memory Management Unit"
group.long c15:0x1++0x0
 line.long 0x0 "SCTLR,Control Register"
  bitfld.long 0x0 30. " TE      ,Thumb exception enable" "ARM,Thumb"
  bitfld.long 0x0 29. "        AFE     ,Access Flag Enable" "Disabled,Enabled"
  bitfld.long 0x0 28. "     TRE      ,TEX remap enable" "Disabled,Enabled"
  textline "                      "
  bitfld.long 0x0 27. " NMFI    ,DNonmaskable Fast Interrupt enable" "Disabled,Enabled"
  bitfld.long 0x0 25. "     EE      ,Exception endianess" "Little,Big"
  bitfld.long 0x0 14. "       RR       ,Replacement strategy for caches, BTAC, and micro TLBs" "Random,Round robin"
  textline "                      "
  bitfld.long 0x0 13. " V       ,Base Location of Exception Registers" "0x00000000,0xFFFF0000"
  bitfld.long 0x0 12. "   I       ,Instruction Cache Enable" "Disabled,Enabled"
  bitfld.long 0x0 11. "     Z        ,Branch Prediction Enable" "Disabled,Enabled"
  textline "                      "
  bitfld.long 0x0 10. " SW      ,SWP/SWPB Enable" "Disabled,Enabled"
  bitfld.long 0x0 2. "     C       ,Enable unified cache or data cache" "Disabled,Enabled"
  bitfld.long 0x0 1. "     A        ,Strict Alignment" "Disabled,Enabled"
  textline "                      "
  bitfld.long 0x0 0. " M       ,MMU or Protection Unit" "Disabled,Enabled"   
 textline " "
 
group.long c15:0x0002++0x00
 line.long 0x00 "TTBR0,Translation Table Base Register 0"
  hexmask.long 0x00 14.--31. 0x4000 " TTB0    ,Translation Table Base Address"
  bitfld.long 0x00 6. 0. "                IRGN[1:0] ,Indicates inner cacheability" "Noncacheable,Back/allocated,Through,Back/not allocated"
  textline "                      "
  bitfld.long 0x00 3.--4. " RGN     ,Outer Cacheable Attributes for Page Table Walking" "Noncacheable,Back/allocated,Through,Back/not allocated"
  bitfld.long 0x00 1. "      S         ,Page Table Walk to Shared Memory" "Nonshared,Shared"
group.long c15:0x0102++0x00
 line.long 0x00 "TTBR1,Translation Table Base Register 1"
  hexmask.long 0x00 14.--31. 0x4000 " TTB1    ,Translation Table Base Address"
  bitfld.long 0x00 6. 0. "                IRGN[1:0] ,Indicates inner cacheability" "Noncacheable,Back/allocated,Through,Back/not allocated"
  textline "                      "
  bitfld.long 0x00 3.--4. " RGN     ,Outer Cacheable Attributes for Page Table Walking" "Noncacheable,Back/allocated,Through,Back/not allocated"
  bitfld.long 0x00 1. "      S         ,Page Table Walk to Shared Memory" "Nonshared,Shared"
group.long c15:0x0202++0x00
 line.long 0x00 "TTBCR,Translation Table Base Control Register"
   bitfld.long 0x00 5. " PD1     ,Page Table Walk on a TLB Miss When Using Translation Table Base Register 1" "Enable,Disable"
   bitfld.long 0x00 4. "  PD0  ,Page Table Walk on a TLB Miss When Using Translation Table Base Register 0" "Enable,Disable"
   bitfld.long 0x0 0.--2. "   N    ,Translation Table Base Register 0 page table boundary size" "Off,0x80000000,0x40000000,0x20000000,0x10000000,0x08000000,0x04000000,0x02000000"
 textline " "
 
group.long c15:0x3--0x3 
 line.long 0x0 "DACR,Domain Access Control Register"
  bitfld.long 0x0 30.--31. " D15  ,Domain Access 15" "Denied,Client,Reserved,Manager"
  bitfld.long 0x0 28.--29. "  D14 ,Domain Access 14" "Denied,Client,Reserved,Manager"
  bitfld.long 0x0 26.--27. "  D13 ,Domain Access 13" "Denied,Client,Reserved,Manager"
  bitfld.long 0x0 24.--25. "  D12 ,Domain Access 12" "Denied,Client,Reserved,Manager"
 textline "                      "
  bitfld.long 0x0 22.--23. " D11  ,Domain Access 11" "Denied,Client,Reserved,Manager"
  bitfld.long 0x0 20.--21. "  D10 ,Domain Access 10" "Denied,Client,Reserved,Manager"
  bitfld.long 0x0 18.--19. "  D9  ,Domain Access 9" "Denied,Client,Reserved,Manager"
  bitfld.long 0x0 16.--17. "  D8  ,Domain Access 8" "Denied,Client,Reserved,Manager"
 textline "                      "
  bitfld.long 0x0 14.--15. " D7   ,Domain Access 7" "Denied,Client,Reserved,Manager"
  bitfld.long 0x0 12.--13. "  D6  ,Domain Access 6" "Denied,Client,Reserved,Manager"
  bitfld.long 0x0 10.--11. "  D5  ,Domain Access 5" "Denied,Client,Reserved,Manager"
  bitfld.long 0x0 8.--9. "  D4  ,Domain Access 4" "Denied,Client,Reserved,Manager"
 textline "                      "
  bitfld.long 0x0 6.--7. " D3   ,Domain Access 3" "Denied,Client,Reserved,Manager"
  bitfld.long 0x0 4.--5. "  D2  ,Domain Access 2" "Denied,Client,Reserved,Manager"
  bitfld.long 0x0 2.--3. "  D1  ,Domain Access 1" "Denied,Client,Reserved,Manager"
  bitfld.long 0x0 0.--1. "  D0  ,Domain Access 0" "Denied,Client,Reserved,Manager"
 textline " "
 
group.long c15:0x0005++0x00
 line.long 0x00 "DFSR,Data Fault Status Register"
  bitfld.long 0x00 12. " EXT     ,External Abort Qualifier" "DECERR,SLVERR"
  bitfld.long 0x00 11. "                  RW        ,Access Caused an Abort Type" "Read,Write"
  textline "                      "
  bitfld.long 0x00 4.--7. " DOMAIN  ,Domain Accessed When a Data Fault Occurs" "D0,D1,D2,D3,D4,D5,D6,D7,D8,D9,D10,D11,D12,D13,D14,D15"
  bitfld.long 0x00 0.--3. 10.  "                     STATUS    ,Generated Exception Type" "Reserved,Alignment,Debug,Access/section,Instruction,Translation/section,Access/page,Translation/page,Nontranslation/synchronous external,Domain/section,Reserved,Domain/page,L1/external,Permission/section,L2/external,Permission/page,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Asynchronous external,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
group.long c15:0x0006++0x00
 line.long 0x00 "DFAR,Data Fault Address Register"
  hexmask.long 0x00 0.--31. 1. " DFA     ,Data Fault Address"
group.long c15:0x0105++0x00
 line.long 0x00 "IFSR,Instruction Fault Status Register"
  bitfld.long 0x00 12. " SD      ,External Abort Qualifier" "DECERR,SLVERR"
  bitfld.long 0x00 0.--3. 10. "                  STATUS    ,Generated Exception Type" "Reserved,Alignment,Debug,Access/section,Instruction,Translation/section,Access/page,Translation/page,Nontranslation/synchronous external,Domain/section,Reserved,Domain/page,L1/external,Permission/section,L2/external,Permission/page,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Asynchronous external,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
group.long c15:0x0206++0x00
 line.long 0x00 "IFAR,Instruction Fault Address Register"
  hexmask.long 0x00 0.--31. 1. " IFA     ,Instruction Fault Address"
group.long c15:0x0015++0x00
 line.long 0x00 "DAFSR,Data Auxiliary Fault Status Register"
  hexmask.long 0x00 0.--31. 1. " DAFS    ,Data Auxiliary Fault Status"
group.long c15:0x0115++0x00
 line.long 0x00 "IAFSR,Instruction Auxiliary Fault Status Register"
  hexmask.long 0x00 0.--31. 1. " IAFS    ,Instruction Auxiliary Fault Status" 
 textline " "
 
group.long c15:0xa++0x0
  line.long 0x0 "TLBLR,TLB Lockdown Register"
  bitfld.long 0x0 28.--29. " VICTIM  ,Victim Value Increments after Each Tabel Walk" "0,1,2,3"
  bitfld.long 0x0 0. "                       P         ,Lockdown by Victim or Set Associative Region of TLB" "Associative,Lockdown"
  
group.long c15:0x525f++0x0
 line.long 0x00 "MTLBVAR,Main TLB VA Register"
  hexmask.long 0x00 12.--31. 1. " VPN     ,Virtual Page Number"
  bitfld.long 0x00 10. "                NS        ,Non-Secure bit" "Not secured,Secured"
  textline "                      "
  hexmask.long.word 0x00 0.--9. 1. " PROCESS ,Memory space identifier"
group.long c15:0x526f++0x0
 line.long 0x00 "MTLBPAR,Main TLB PA Register"
  hexmask.long 0x00 12.--31. 1. " PPN     ,Physical Page Number"
  bitfld.long 0x00 6.--7. "                SZ        ,Region Size" "16MB,4KB,64KB,1MB"
  textline "                      "
  bitfld.long 0x00 1.--3. " AP      ,Access permission" "All access,Supervisor access only,Supervisor R/W access,Full,Reserved,Supervisor read only,Supervisor/Usr read only,Supervisor/Usr read only"
  bitfld.long 0x00 0. "V         ,Value bit" "0,1"
group.long c15:0x527f++0x0
 line.long 0x00 "MTLBAR,Main TLB Attribute Register"
  bitfld.long 0x00 11. " NS      ,Non-secure description" "Not secured,Secured"
  bitfld.long 0x00 7.--10. "             DOMAIN    ,Domain number of the TLB entry" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
  textline "                      "
  bitfld.long 0x00 6. " XN      ,Execute Never attribute" "0,1"
  bitfld.long 0x00 3.--5. "                       TEX       ,Region type Encoding" "0,1,2,3,4,5,6,7"
  textline "                      "
  bitfld.long 0x00 1.--2. " CB      ,Region type Encoding" "0,1,2,3"
  bitfld.long 0x00 0. "                       S         ,Shared attribute" "0,1"
group.long c15:0x0047++0x00
 line.long 0x00 "PAR,PA Register"
  hexmask.long 0x00 12.--31. 0x1000 " PA      ,Physical Adress"
  bitfld.long 0x00 9. "                NS        ,Non-secure" "Not secured,Secured"
  textline "                      "
  bitfld.long 0x00 7. " SH      ,Shareable attribute" "Non-shareable,Shareable"
  bitfld.long 0x00 4.--6. "           Inner     ,Signals region inner attributes" "Noncacheable,Strongly-ordered,Reserved,Device,Reserved,Write-back allocate,Write-through,Write-back"
  textline "                      "
  bitfld.long 0x00 2.--3. " Outer   ,Signals region outer attributes for normal memory type" "Noncacheable,Write-back allocate,Write-through,Write-back"
  bitfld.long 0x00 1. "     SS        ,Supersection Enable bit" "Disabled,Enabled"
  textline "                      "
  bitfld.long 0x00 0. " F       ,Translation Successful" "Successful,No successful"
 textline " "

group.long c15:0x002A++0x0
 line.long 0x00 "PRRR,Primary Region Remap Register"
  bitfld.long 0x00 19. " NS1     ,Shareable Attribute Remap when S=1 for Normal Regions" "Remapped,Not remapped"
  bitfld.long 0x00 18. "            NS0       ,Shareable Attribute Remap when S=0 for Normal Regions" "Not remapped,Remapped"
  textline "                      "
  bitfld.long 0x00 17. " DS1     ,Shareable Attribute Remap when S=1 for Device regions" "Remapped,Not remapped"
  bitfld.long 0x00 16. "            DS0       ,Shareable Attribute Remap when S=0 for Device regions" "Not remapped,Remapped"
  textline "                      "
  bitfld.long 0x00 14.--15. " TR7     ,{TEX[0] C B} = b111 Remap" "Strongly ordered,Device,Normal,UNP"
  bitfld.long 0x00 12.--13. "        TR6       ,{TEX[0] C B} = b110 Remap" "Strongly ordered,Device,Normal,UNP"
  textline "                      "
  bitfld.long 0x00 10.--11. " TR5     ,{TEX[0] C B} = b101 Remap" "Strongly ordered,Device,Normal,UNP"
  bitfld.long 0x00 8.--9. "        TR4       ,{TEX[0] C B} = b100 Remap" "Strongly ordered,Device,Normal,UNP"
  textline "                      "
  bitfld.long 0x00 6.--7. " TR3     ,{TEX[0] C B} = b011 Remap" "Strongly ordered,Device,Normal,UNP"
  bitfld.long 0x00 4.--5. "        TR2       ,{TEX[0] C B} = b010 Remap" "Strongly ordered,Device,Normal,UNP"
  textline "                      "
  bitfld.long 0x00 2.--3. " TR1     ,{TEX[0] C B} = b001 Remap" "Strongly ordered,Device,Normal,UNP"
  bitfld.long 0x00 0.--1. "        TR0       ,{TEX[0] C B} = b000 Remap" "Strongly ordered,Device,Normal,UNP"
group.long c15:0x012A++0x0
 line.long 0x00 "NMRR,Normal Memory Remap Register"
  bitfld.long 0x00 30.--31. " OR7     ,Outer Attribute for {TEX[0] C B} = b111 Remap" "Noncachable,Write-back allocate,Write-through,Write-back no allocate"
  bitfld.long 0x00 28.--29. "  OR6       ,Outer Attribute for {TEX[0] C B} = b110 Remap" "Noncachable,Write-back allocate,Write-through,Write-back no allocate"
  textline "                      "
  bitfld.long 0x00 26.--27. " OR5     ,Outer Attribute for {TEX[0] C B} = b101 Remap" "Noncachable,Write-back allocate,Write-through,Write-back no allocate"
  bitfld.long 0x00 24.--25. "  OR4       ,Outer Attribute for {TEX[0] C B} = b100 Remap" "Noncachable,Write-back allocate,Write-through,Write-back no allocate"
  textline "                      "
  bitfld.long 0x00 22.--23. " OR3     ,Outer Attribute for {TEX[0] C B} = b011 Remap" "Noncachable,Write-back allocate,Write-through,Write-back no allocate"
  bitfld.long 0x00 20.--21. "  OR2       ,Outer Attribute for {TEX[0] C B} = b010 Remap" "Noncachable,Write-back allocate,Write-through,Write-back no allocate"
  textline "                      "
  bitfld.long 0x00 18.--19. " OR1     ,Outer Attribute for {TEX[0] C B} = b001 Remap" "Noncachable,Write-back allocate,Write-through,Write-back no allocate"
  bitfld.long 0x00 16.--17. "  OR0       ,Outer Attribute for {TEX[0] C B} = b000 Remap" "Noncachable,Write-back allocate,Write-through,Write-back no allocate"
  textline "                      "
  bitfld.long 0x00 14.--15. " IR7     ,Inner attribute for {TEX[0] C B} = b111 Remap" "Noncachable,Write-back allocate,Write-through,Write-back no allocate"
  bitfld.long 0x00 12.--13. "  IR6       ,Inner attribute for {TEX[0] C B} = b110 Remap" "Noncachable,Write-back allocate,Write-through,Write-back no allocate"
  textline "                      "
  bitfld.long 0x00 10.--11. " IR5     ,Inner attribute for {TEX[0] C B} = b101 Remap" "Noncachable,Write-back allocate,Write-through,Write-back no allocate"
  bitfld.long 0x00 8.--9. "  IR4       ,Inner attribute for {TEX[0] C B} = b100 Remap" "Noncachable,Write-back allocate,Write-through,Write-back no allocate"
  textline "                      "
  bitfld.long 0x00 6.--7. " IR3     ,Inner attribute for {TEX[0] C B} = b011 Remap" "Noncachable,Write-back allocate,Write-through,Write-back no allocate"
  bitfld.long 0x00 4.--5. "  IR2       ,Inner attribute for {TEX[0] C B} = b010 Remap" "Noncachable,Write-back allocate,Write-through,Write-back no allocate"
  textline "                      "
  bitfld.long 0x00 2.--3. " IR1     ,Inner attribute for {TEX[0] C B} = b001 Remap" "Noncachable,Write-back allocate,Write-through,Write-back no allocate"
  bitfld.long 0x00 0.--1. "  IR0       ,Inner attribute for {TEX[0] C B} = b000 Remap" "Noncachable,Write-back allocate,Write-through,Write-back no allocate"
 textline " "

rgroup.long c15:0x000d++0x00
 line.long 0x00 "FCSEIDR,FCSE PID Register"
  hexmask.long 0x00 0.--31. 1. " FCSEPID ,Process for Fast Context Switch Identification and Specification"
group.long c15:0x10d++0x0
 line.long 0x0 "CONTEXTIDR,Context ID Register"
  hexmask.long.tbyte 0x0 8.--31. 1 " PROCID  ,Process ID"
  hexmask.long.byte 0x0 0.--7. 1 "                  ASID      ,Application Space ID"
group.long c15:0x020d++0x00
 line.long 0x00 "URWTPIDR,User Read/Write Thread and Process ID Register"
  hexmask.long 0x00 0.--31. 1. " URWTPID ,User Read/Write Thread and Process ID"
group.long c15:0x030d++0x00
 line.long 0x00 "UROTPIDR,User Read-Only Thread and Process ID Register"
  hexmask.long 0x00 0.--31. 1. " UROTPID ,User Read-Only Thread and Process ID"
group.long c15:0x040d++0x00
 line.long 0x00 "POTPIDR,Privileged Only Thread and Process ID Register"
  hexmask.long 0x00 0.--31. 1. " POTPID  ,Privileged Only Thread and Process ID"
tree.end

width 0xC
tree "Cache Control and Configuration"
rgroup.long c15:0x1100++0x0
 line.long 0x0 "CLIDR,Cache Level ID Register"
  bitfld.long 0x00 27.--29. " LOU     ,Level of Unification" "Level 1,Level 2,Level 3,Level 4,Level 5,Level 6,Level 7,Level 8"
  bitfld.long 0x00 24.--26. "                    LOC    ,Level of Coherency" "Level 1,Level 2,Level 3,Level 4,Level 5,Level 6,Level 7,Level 8"
  textline "                     "
  bitfld.long 0x00 21.--23. " CType8  ,Cache type for levels 8" "No cache,I-cache,D-cache,Separate I/D,Unified,Reserved,Reserved,Reserved"
  bitfld.long 0x00 18.--20. "               CType7 ,Cache type for levels 7" "No cache,I-cache,D-cache,Separate I/D,Unified,Reserved,Reserved,Reserved"
  textline "                     "
  bitfld.long 0x00 15.--17. " CType6  ,Cache type for levels 6" "No cache,I-cache,D-cache,Separate I/D,Unified,Reserved,Reserved,Reserved"
  bitfld.long 0x00 12.--14. "               CType5 ,Cache type for levels 5" "No cache,I-cache,D-cache,Separate I/D,Unified,Reserved,Reserved,Reserved"
  textline "                     "
  bitfld.long 0x00 9.--11. " CType4  ,Cache type for levels 4" "No cache,I-cache,D-cache,Separate I/D,Unified,Reserved,Reserved,Reserved"
  bitfld.long 0x00 6.--8. "               CType3 ,Cache type for levels 3" "No cache,I-cache,D-cache,Separate I/D,Unified,Reserved,Reserved,Reserved"
  textline "                     "
  bitfld.long 0x00 3.--5. " CType2  ,Cache type for levels 2" "No cache,I-cache,D-cache,Separate I/D,Unified,Reserved,Reserved,Reserved"
  bitfld.long 0x00 0.--2. "               CType1 ,Cache type for levels 1" "No cache,I-cache,D-cache,Separate I/D,Unified,Reserved,Reserved,Reserved"
rgroup.long c15:0x1700++0x0
 line.long 0x0 "AIDR,Auxiliary ID Register"
  hexmask.long 0x00 0.--31. 1. " AID     ,Auxiliary ID"
rgroup.long c15:0x1000++0x0
 line.long 0x0 "CCSIDR,Current Cache Size ID Register"
   bitfld.long 0x00 31. " WT      ,Write-Through" "Not Supported,Supported"
  bitfld.long 0x00 30. "              WB     ,Write-Back" "Not Supported,Supported"
  textline "                     "
  bitfld.long 0x00 29. " RA      ,Read-Allocate" "Not Supported,Supported"
  bitfld.long 0x00 28. "              WA     ,Write-Allocate" "Not Supported,Supported"
  textline "                     "
  hexmask.long.word 0x00 13.--27. 1.  " SETS    ,Number of Sets"
  hexmask.long.word 0x00 3.--12. 1.  "                       ASSOC  ,Associativity"
  textline "                     "
  bitfld.long 0x00 0.--2. " LSIZE   ,Line Size" "4 words,8 words,16 words,32 words,64 words,128 words,256 words,512 words"
group.long c15:0x2000++0x0
 line.long 0x0 "CSSELR,Cache Size Selection Register"
  bitfld.long 0x00 1.--3. " LEVEL   ,Level" "Level 1,Level 2,Level 3,Level 4,Level 5,Level 6,Level 7,Level 8"
  bitfld.long 0x00 0. "                    IND    ,Instruction/Not Data" "Data,Instruction"
tree.end

width 0x8

tree "L2 Preload Engine"
 rgroup c15:0x000b++0x00
  line.long 0x00 "PLEIDR,PLE Identification Register 0"
   bitfld.long 0x00 0. " CH0P ,Channel 0 Present" "Not present,Present"
 rgroup c15:0x020b++0x00
  line.long 0x00 "PLESR,PLE Status Register"
   bitfld.long 0x00 0. " CH0R ,Channel 0 Run" "Not running,Running"
 rgroup c15:0x040b++0x00
  line.long 0x00 "PLEFSR,PLE FIFO Status Register"
 group c15:0x001b++0x00
  line.long 0x00 "PLEUAR,PLE User Accessibility Register"
   bitfld.long 0x00 0. " U0  ,User Mode Process Access Registers for Channel 0 Permission" "Not permitted,Permitted"
 group c15:0x011b++0x00
  line.long 0x00 "PLEPCR,PLE Parameters Control Register"
tree.end

width 12.
tree "System Performance Monitor"
group.long c15:0xC9++0x0
 line.long 0x0 "PMCR,Performance Monitor Control Register"
  hexmask.long.byte 0x00 24.--31. 1. " IMP  ,Implementer code"
  hexmask.long.byte 0x00 16.--23. 1. "           IDCODE ,Identification code"
  bitfld.long 0x00 11.--15. "           N  ,Number of counters implemented" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
  bitfld.long 0x00 5. "           DP ,Disable CCNT when prohibited" "Enabled,Disabled"
  textline "                     "
  bitfld.long 0x00 4. " X    ,Export Enabled" "Disabled,Enabled"
  bitfld.long 0x00 3. "     D      ,Clock Divider" "Every cycle,64th cycle"
  bitfld.long 0x00 2. "  C  ,Clock Counter Reset" "No action,Reset"
  bitfld.long 0x00 1. "    P  ,Performance Counter Reset" "No action,Reset"
  textline "                     "
  bitfld.long 0x00 0. " E    ,Counters Enable" "Disabled,Enabled"
group.long c15:0x1C9++0x0
 line.long 0x0 "PMCNTENSET,Count Enable Set Register"
  bitfld.long 0x00 31. " C    ,CCNT Enabled" "Disabled,Enabled"
  bitfld.long 0x00  5. "     P5     ,PMN5 Enabled" "Disabled,Enabled"
  bitfld.long 0x00  4. "     P4 ,PMN5 Enabled" "Disabled,Enabled"
  bitfld.long 0x00  3. "     P3 ,PMN3 Enabled" "Disabled,Enabled"
  textline "                     "
  bitfld.long 0x00  2. " P2   ,PMN2 Enabled" "Disabled,Enabled"
  bitfld.long 0x00  1. "     P1     ,PMN1 Enabled" "Disabled,Enabled"
  bitfld.long 0x00  0. "     P0 ,PMN0 Enabled" "Disabled,Enabled"
group.long c15:0x2C9++0x0
 line.long 0x0 "PMCNTENCLR,Count Enable Clear Register"
  bitfld.long 0x00 31. " C    ,CCNT Enabled" "Disabled,Enabled"
  bitfld.long 0x00  5. "     P5     ,PMN5 Enabled" "Disabled,Enabled"
  bitfld.long 0x00  4. "     P4 ,PMN5 Enabled" "Disabled,Enabled"
  bitfld.long 0x00  3. "     P3 ,PMN3 Enabled" "Disabled,Enabled"
  textline "                     "
  bitfld.long 0x00  2. " P2   ,PMN2 Enabled" "Disabled,Enabled"
  bitfld.long 0x00  1. "     P1     ,PMN1 Enabled" "Disabled,Enabled"
  bitfld.long 0x00  0. "     P0 ,PMN0 Enabled" "Disabled,Enabled"
group.long c15:0x3C9++0x0
 line.long 0x0 "PMOVSR,Overflow Flag Status Register"
  eventfld.long 0x00 31. " C    ,CCNT overflowed" "No overflow,Overflow"
  eventfld.long 0x00  5. "  P5     ,PMN5 overflow" "No overflow,Overflow"
  eventfld.long 0x00  4. "  P4 ,PMN5 overflow" "No overflow,Overflow"
  eventfld.long 0x00  3. "  P3 ,PMN3 overflow" "No overflow,Overflow"
  textline "                     "
  eventfld.long 0x00  2. " P2   ,PMN2 overflow" "No overflow,Overflow"
  eventfld.long 0x00  1. "  P1     ,PMN1 overflow" "No overflow,Overflow"
  eventfld.long 0x00  0. "  P0 ,PMN0 overflow" "No overflow,Overflow"
wgroup.long c15:0x4C9++0x0
 line.long 0x0 "PMSWINC,Software Increment Register"
  eventfld.long 0x00  5. " P5   ,Increment  PMN2" "No action,Increment"
  eventfld.long 0x00  4. "    P4     ,Increment  PMN1" "No action,Increment"
  eventfld.long 0x00  3. "    P3 ,Increment  PMN3" "No action,Increment"
  eventfld.long 0x00  2. "    P2 ,Increment  PMN2" "No action,Increment"
  textline "                     "
  eventfld.long 0x00  1. " P1   ,Increment  PMN1" "No action,Increment"
  eventfld.long 0x00  0. "    P0     ,Increment  PMN0" "No action,Increment"
group.long c15:0x5C9++0x0
 line.long 0x0 "PMSELR,Performance Counter Selection Register"
  bitfld.long 0x00 0.--5. " SEL  ,Selection value" "CNT0,CNT1,CNT2,CNT3,CNT4,CNT5,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
group.long c15:0xD9++0x0
 line.long 0x00 "PMCCNTR,Cycle Count Register"
  hexmask.long 0x00 0.--31. 1. " CCNT ,Cycle Count"
group.long c15:0x01d9++0x00
 line.long 0x00 "PMXEVTYPER,Event Selection Register"
  hexmask.long.byte 0x00 0.--7. 1. " SEL  ,Event Selection"
group.long c15:0x02d9++0x00
 line.long 0x00 "PMCNT,Performance Monitor Count Register"
  hexmask.long 0x00 0.--31. 1. " PMC  ,Performance Monitor Count"
group.long c15:0xE9++0x0
 line.long 0x0 "PMUSERENR,User Enable Register"
  bitfld.long 0x00  0. " EN   ,User Mode Enable" "Disabled,Enabled"
group.long c15:0x1E9++0x0
 line.long 0x0 "PMINTENSET,Interrupt Enable Set Register"
  bitfld.long 0x00 31. " C    ,CCNT Overflow Interrupt Enable" "Disabled,Enabled"
  bitfld.long 0x00  5. "     P5     ,PMCNT5 Overflow Interrupt Enable" "Disabled,Enabled"
  bitfld.long 0x00  4. "     P4 ,PMCNT4 Overflow Interrupt Enable" "Disabled,Enabled"
  bitfld.long 0x00  3. "     P3 ,PMCNT3 Overflow Interrupt Enable" "Disabled,Enabled"
  textline "                     "
  bitfld.long 0x00  2. " P2   ,PMCNT2 Overflow Interrupt Enable" "Disabled,Enabled"
  bitfld.long 0x00  1. "     P1     ,PMCNT1 Overflow Interrupt Enable" "Disabled,Enabled"
  bitfld.long 0x00  0. "     P0 ,PMCNT0 Overflow Interrupt Enable" "Disabled,Enabled"
group.long c15:0x2E9++0x0
 line.long 0x0 "PMINTENCLR,Interrupt Enable Clear Register"
  eventfld.long 0x00 31. " C    ,CCNT Overflow Interrupt Enable" "Disabled,Enabled"
  eventfld.long 0x00  5. "     P5     ,PMCNT5 Overflow Interrupt Enable" "Disabled,Enabled"
  eventfld.long 0x00  4. "     P4 ,PMCNT4 Overflow Interrupt Enable" "Disabled,Enabled"
  eventfld.long 0x00  3. "     P3 ,PMCNT3 Overflow Interrupt Enable" "Disabled,Enabled"
  textline "                     "
  eventfld.long 0x00  2. " P2   ,PMCNT2 Overflow Interrupt Enable" "Disabled,Enabled"
  eventfld.long 0x00  1. "     P1     ,PMCNT1 Overflow Interrupt Enable" "Disabled,Enabled"
  eventfld.long 0x00  0. "     P0 ,PMCNT0 Overflow Interrupt Enable" "Disabled,Enabled"
tree.end
width 0xb
width 8.

tree "Debug Registers"
 width 11.
 tree "Processor Identifier Registers"
    rgroup c14:0x340--0x340
     line.long 0x00 "CPUID,Main ID Register"
       hexmask.long.byte 0x0 24.--31. 0x1 " IMPL       ,Implementer code"
       hexmask.long.byte 0x0 20.--23. 0x1 "             SPECREV    ,Variant number"
       textline "                    "
       hexmask.long.byte 0x0 16.--19. 0x1 " ARCH       , Architecture"
       hexmask.long.word 0x0 4.--15. 0x1 "             PARTNUM    ,Part Number"
       textline "                    "
       hexmask.long.byte 0x0 0.--3. 0x1 " REV        ,Layout Revision"
    rgroup c14:0x341--0x341
     line.long 0x00 "CACHETYPE,Cache Type Register"
     bitfld.long 0x0 29.--31. " FORMAT     ,Format" "Not ARMv7,Not ARMv7,Not ARMv7,Not ARMv7,ARMv7,Not ARMv7,Not ARMv7,Not ARMv7"
     bitfld.long 0x0 24.--27. "      CWG        ,Cache Writeback Granule" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
     textline "                    "
     bitfld.long 0x0 20.--23. " ERG        ,Exclusives Reservation Granule" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
     bitfld.long 0x00 16.--19. "             DMinLine   ,Words of Smallest Line Length in L1 or L2 Data Cache Number" "Reserved,Reserved,Reserved,Reserved,16x32-bit words,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 14.--15. " L1_Ipolicy ,VIPT Instruction Cache Support" "Reserved,Reserved,Supported,Reserved"
     bitfld.long 0x00 0.--3. "      IMinLine   ,Words of Smallest Line Length in L1 or L2 Instruction Cache Number" "Reserved,Reserved,Reserved,Reserved,16x32-bit words,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
    rgroup c14:0x343--0x343
     line.long 0x00 "TLBTYPE,TLB Type Register"
      hexmask.long.byte 0x0 16.--23. 0x1 " ILsize     ,Specifies the number of instruction TLB lockable entries"
      hexmask.long.byte 0x0 8.--15. 0x1 "             DLsize     ,Specifies the number of unified or data TLB lockable entries"
       textline "                    "
      bitfld.long 0x0 1. " TLB_size   ,TLB Size" "64,128"
      bitfld.long 0x0 0. "            U          ,Unified or separate instruction TLBs" "Unified,Separate"
    rgroup c14:0x348--0x348
     line.long 0x00 "ID_PFR0,Processor Feature Register 0"
     bitfld.long 0x00 12.--15. " State3     ,Thumb-2 Execution Environment (Thumb-2EE) Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 8.--11. "      State2     ,Java Extension Interface Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 4.--7. " State1     ,Thumb Encoding Supported by the Processor Type" "Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 0.--3. "      State0     ,ARM Instruction Set Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
    rgroup c14:0x349--0x349
     line.long 0x00 "ID_PFR1,Processor Feature Register 1"
     bitfld.long 0x00 8.--11. " MPM        ,Microcontroller Programmer's Model Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 4.--7. "  SE         ,Security Extensions Architecture v1 Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 0.--3. " PM         ,Standard ARMv4 Programmer's Model Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
    rgroup c14:0x34a--0x34a
     line.long 0x00 "ID_DFR0,Debug Feature Register 0"
     bitfld.long 0x00 20.--23. " MDM_MM     ,Microcontroller Debug Model Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 16.--19. "  TDM_MM     ,Trace Debug Model (Memory-Mapped) Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 12.--15. " TDM_CB     ,Coprocessor-Based Trace Debug Model Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 8.--11. "  CDM_MM     ,Memory-Mapped Debug Model Support" "Reserved,Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 4.--7. " SDM_CB     ,Secure Debug Model (Coprocessor) Support" "Reserved,Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 0.--3. "      CDM_CB     ,Coprocessor Debug Model Support" "Reserved,Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
    rgroup c14:0x34b--0x34b
     line.long 0x00 "ID_AFR0,Auxiliary Feature Register 0"
     hexmask.long 0x00 0.--31. 1. " AF         ,Auxiliary Feature"
    rgroup c14:0x34c--0x34c
     line.long 0x00 "ID_MMFR0,Processor Feature Register 0"
     bitfld.long 0x00 24.--27. " FCSE       ,Fast Context Switch Memory Mappings Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 20.--23. "  ACR        ,Auxiliary Control Register Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 16.--19. " TCM        ,TCM and Associated DMA Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 12.--15. "  OSS        ,Outer Shareable Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 8.--11. " CC_CPUA    ,Cache Coherency Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 4.--7. "      PMSA       ,Physical Memory System Architecture (PMSA) Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 0.--3. " VMSA       ,Virtual Memory System Architecture (VMSA) Support" "Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"   
    rgroup c14:0x34d--0x34d
     line.long 0x00 "ID_MMFR1,Processor Feature Register 1"
     bitfld.long 0x00 28.--31. " BTB        ,Branch Predictor" "Reserved,Reserved,Required,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 24.--27. "       L1TCO      ,Test and Clean Operations on Data Cache/Harvard/Unified Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 20.--23. " L1UCMO     ,L1 Cache/All Maintenance Operations/Unified Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 16.--19. "  L1HCMO     ,L1 Cache/All Maintenance Operations/Harvard Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 12.--15. " L1UCLMOSW  ,L1 Cache Line Maintenance Operations by Set and Way/Unified Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 8.--11. "  L1HCLMOSW  ,L1 Cache Line Maintenance Operations by Set and Way/Harvard Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 4.--7. " L1UCLMOMVA ,L1 Cache Line Maintenance Operations by VA/Unified Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 0.--3. "  L1HCLMOMVA ,L1 Cache Line Maintenance Operations by VA/Harvard Architecture" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved" 
    rgroup c14:0x34e--0x34e
     line.long 0x00 "ID_MMFR2,Processor Feature Register 2"
     bitfld.long 0x00 28.--31. " HAF        ,Hardware Access Flag Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 24.--27. "  WFI        ,Wait for Interrupt Stalling Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 20.--23. " MBF        ,Memory Barrier Operations Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 16.--19. "      UTLBMO     ,TLB Maintenance Operations/Unified Architecture Support" "Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 12.--15. " HTLBMO     ,TLB Maintenance Operations/Harvard Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 8.--11. "  HL1CMRO    ,Cache Maintenance Range Operations/Harvard Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 4.--7. " HL1BPCRO   ,Background Prefetch Cache Range Operations/Harvard Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 0.--3. "  HL1FPCRO   ,Foreground Prefetch Cache Range Operations/Harvard Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
    rgroup c14:0x34f--0x34f
     line.long 0x00 "ID_MMFR3,Processor Feature Register 3"
     bitfld.long 0x00 28.--31. " SS         ,Supersection support" "Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 20.--23. "      CW         ,Coherent walk" "Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 12.--15. " MB         ,Invalidate broadcast Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 8.--11. "      BPM        ,Invalidate Branch predictor Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 4.--7. " HCMOSW     ,Invalidate Cache by Set and Way/Clean by Set and Way/Invalidate and Clean by Set and Way Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 0.--3. "      HCMOMVA    ,Invalidate Cache MVA Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"    
    rgroup c14:0x350--0x350
     line.long 0x00 "ID_ISAR0,ISA Feature Register 0"
     bitfld.long 0x00 24.--27. " DIVI       ,Divide Instructions Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 20.--23. "  DEBI       ,Debug Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 16.--19. " CI         ,Coprocessor Instructions Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 12.--15. "  CBI        ,Combined Compare and Branch Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 8.--11. " BI         ,Bitfield Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 4.--7. "      BCI        ,Bit Counting Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 0.--3. " SI         ,Swap Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"   
    rgroup c14:0x351--0x351
     line.long 0x00 "ID_ISAR1,ISA Feature Register 1"
     bitfld.long 0x00 28.--31. " JI         ,Jazelle Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 24.--27. "      INTI       ,Interwork Instructions Support" "Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 20.--23. " IMMI       ,Immediate Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 16.--19. "      ITEI       ,If Then Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 12.--15. " EXTI       ,Extend Instructions Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 8.--11. "      E2I        ,Exception 2 Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 4.--7. " E1I        ,Exception 1 Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 0.--3. "      ENDI       ,Endian Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"   
    rgroup c14:0x352--0x352
     line.long 0x00 "ID_ISAR2,ISA Feature Register 2"
     bitfld.long 0x00 28.--31. " RI         ,Reversal Instructions Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 24.--27. "      PSRI       ,PSR Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 20.--23. " UMI        ,Advanced Unsigned Multiply Instructions Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 16.--19. "      SMI        ,Advanced Signed Multiply Instructions Support" "Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 12.--15. " MI         ,Multiply Instructions Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 8.--11. "      II         ,Multi-Access Interruptible Instructions Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 4.--7. " MHI        ,Memory Hint Instructions Support" "Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 0.--3. "      LSI        ,Load and Store Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
    rgroup c14:0x353--0x353
     line.long 0x00 "ID_ISAR3,ISA Feature Register 3"
     bitfld.long 0x00 28.--31. " T2E        ,Thumb-2 Extensions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 24.--27. "      NOPI       ,True NOP Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 20.--23. " TCI        ,Thumb Copy Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 16.--19. "      TBI        ,Table Branch Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 12.--15. " SPI        ,Synchronization Primitive Instructions Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 8.--11. "      SVCI       ,SVC Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 4.--7. " SIMDI      ,Single Instruction Multiple Data (SIMD) Instructions Support" "Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 0.--3. "      SI         ,Saturate Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"    
    rgroup c14:0x354--0x354
     line.long 0x00 "ID_ISAR4,ISA Feature Register 4"
     bitfld.long 0x00 28.--31. " SWP_frac   ,SWAP_frac" "Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 24.--27. "      PSR_M_I    ,PSR_M Instructions Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 20.--23. " SPRI       ,Synchronization Primitive instructions" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 16.--19. "  BI         ,Barrier Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 12.--15. " SMCI       ,SMC Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 8.--11. "      WBI        ,Write-Back Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 4.--7. " WSI        ,With-Shift Instructions Support" "Reserved,Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 0.--3. "      UI         ,Unprivileged Instructions Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"     
    rgroup c14:0x355--0x355
     line.long 0x00 "ID_ISAR5,ISA Feature Register 5 (Reserrved)"
 tree.end

tree "Coresight Management Registers"
 width 0xC

 textline "                     "

 group c14:0x03bd++0x00
  line.long 0x00 "ITCTRL_IOC,Integration Internal Output Control Register"
   bitfld.long 0x00 5. " I_DBGTRIGGER    ,Internal DBGTRIGGER" "0,1"
   bitfld.long 0x00 4. "                I_DBGRESTARTED  ,Internal DBGRESTARTED" "0,1"
     textline "                     "
   bitfld.long 0x00 3. " I_nPMUIRQ       ,Internal nPMUIRQ" "0,1"
   bitfld.long 0x00 2. "                InternalCOMMTX  ,Internal COMMTX" "0,1"
     textline "                     "
   bitfld.long 0x00 1. " I_COMMRX        ,Internal COMMRX" "0,1"
   bitfld.long 0x00 0. "                I_DBGACK        ,Internal DBGACK" "0,1"
 group c14:0x03be++0x00
  line.long 0x00 "ITCTRL_EOC,Integration External Output Control Register"
   bitfld.long 0x00 7. " nDMAEXTERRIQ    ,External nDMAEXTERRIRQ" "0,1"
   bitfld.long 0x00 6. "                nDMASIRQ        ,External nDMASIRQ" "0,1"
   textline "                     "
   bitfld.long 0x00 5. " nDMAIRQ         ,External nDMAIRQ" "0,1"
   bitfld.long 0x00 4. "                nPMUIRQ         ,External nPMUIRQ" "0,1"
   textline "                     "
   bitfld.long 0x00 3. " STANDBYWFI      ,External STANDBYWFI" "0,1"
   bitfld.long 0x00 2. "                COMMTX          ,External COMMTX" "0,1"
   textline "                     "
   bitfld.long 0x00 1. " COMMRX          ,External COMMRX" "0,1"
   bitfld.long 0x00 0. "                DBGACK          ,External DBGACK" "0,1"
 rgroup c14:0x03bf++0x00
  line.long 0x00 "ITCTRL_IS,Integration Input Status Register"
   bitfld.long 0x00 11. " CTI_DBGRESTART  ,CTI Debug Restart" "0,1"
   bitfld.long 0x00 10. "                CTI_EDBGRQ      ,CTI Debug Request" "0,1"
   textline "                     "
   bitfld.long 0x00 9. " CTI_PMUEXTIN[1] ,CTI PMUEXTIN[1] Signal" "0,1"
   bitfld.long 0x00 8. "                CTI_PMUEXTIN[0] ,CTI PMUEXTIN[0] Signal" "0,1"
   textline "                     "
   bitfld.long 0x00 2. " nFIQ            ,nFIQ Input" "0,1"
   bitfld.long 0x00 1. "                nIRQ            ,nIRQ Input" "0,1"
   textline "                     "
   bitfld.long 0x00 0. " EDBGRQ          ,EDBGRQ Input" "0,1"
 group c14:0x3c0--0x3c0
  line.long 0x0 "ITCTRL,Integration Mode Control Register"
   bitfld.long 0x0 0. " IME             ,Integration Mode Enable" "Disabled,Enabled"
 group c14:0x3e8--0x3e8
  line.long 0x0 "CLAIMSET,Claim Tag Set Register"
   bitfld.long 0x0 7. " CT7             ,Claim Tag 7" "No Effect,Set"
   bitfld.long 0x0 6. "        CT6             ,Claim Tag 6" "No Effect,Set"
   textline "                     "
   bitfld.long 0x0 5. " CT5             ,Claim Tag 5" "No Effect,Set"
   bitfld.long 0x0 4. "        CT4             ,Claim Tag 4" "No Effect,Set"
   textline "                     "
   bitfld.long 0x0 3. " CT3             ,Claim Tag 3" "No Effect,Set"
   bitfld.long 0x0 2. "        CT2             ,Claim Tag 2" "No Effect,Set"
   textline "                     "
   bitfld.long 0x0 1. " CT1             ,Claim Tag 1" "No Effect,Set"
   bitfld.long 0x0 0. "        CT0             ,Claim Tag 0" "No Effect,Set"
 group c14:0x3e9--0x3e9
  line.long 0x0 "CLAIMCLR,Claim Tag Clear Register"
   bitfld.long 0x0 7. " CT7             ,Claim Tag 7" "No Effect,Cleared"
   bitfld.long 0x0 6. "        CT6             ,Claim Tag 6" "No Effect,Cleared"
   textline "                     "
   bitfld.long 0x0 5. " CT5             ,Claim Tag 5" "No Effect,Cleared"
   bitfld.long 0x0 4. "        CT4             ,Claim Tag 4" "No Effect,Cleared"
   textline "                     "
   bitfld.long 0x0 3. " CT3             ,Claim Tag 3" "No Effect,Cleared"
   bitfld.long 0x0 2. "        CT2             ,Claim Tag 2" "No Effect,Cleared"
   textline "                     "
   bitfld.long 0x0 1. " CT1             ,Claim Tag 1" "No Effect,Cleared"
   bitfld.long 0x0 0. "        CT0             ,Claim Tag 0" "No Effect,Cleared"
 wgroup c14:0x3ec--0x3ec
  line.long 0x0 "LAR,Lock Access Register"
   hexmask.long.long 0x0 0.--31. 1 " LACK            ,Lock Access Control Key"
 rgroup c14:0x3ed--0x3ed 
  line.long 0x0 "LSR,Lock Status Register"
   bitfld.long 0x0 2. " 32ACND          ,32-bit Access Needed" "Needed,Not needed"
   bitfld.long 0x0 1. "       WLCK            ,Writes Lock" "Permitted,Ignored"
   textline "                     "
   bitfld.long 0x0 0. " LI              ,Lock Implementation" "Lock ignored,Unlock required"
width 0xc
 rgroup c14:0x3ee--0x3ee
  line.long 0x0 "AUTHSTATUS,Authentication Status Register"
   bitfld.long 0x0 7. " SNIDFI  ,Secure Non-invasive Debug Features Implemented" "Not Implemented,Implemented"
   bitfld.long 0x0 6. "  SNIDE  ,Secure Non-invasive Debug Enable" "Disabled,Enabled"
   textline "                     "
   bitfld.long 0x0 5. " SIDFI   ,Secure Invasive Debug Feauter Implemented" "Not Implemented,Implemented"
   bitfld.long 0x0 4. "  SIDE   ,Secure Invasive Debug Enable" "Disabled,Enabled"
   textline "                     "
   bitfld.long 0x0 3. " NSNIDFI ,Non-secure Non-invasive Debug Feature Implemented" "Not Implemented,Implemented"
   bitfld.long 0x0 2. "  NSNIDE ,Non-secure Non-invasive Debug Enable" "Disabled,Enabled"
   textline "                     "
   bitfld.long 0x0 1. " NSIDFI  ,Non-secure Invasive Debug Implemented" "Not Implemented,Implemented"
   bitfld.long 0x0 0. "  NSIDE  ,Non-secure Invasive Debug Enable" "Disabled,Enabled"
width 0xc
 hgroup c14:0x3f2--0x3f2
  hide.long 0x0 "DEVID,Device Identifier (RESERVED)"
 rgroup c14:0x3f3--0x3f3
  line.long 0x0 "DEVTYPE,Device Type"
   hexmask.long.byte 0x0 4.--7. 1 " STPC   ,Sub Type: Processor Core"
   hexmask.long.byte 0x0 0.--3. 1 "     MCDL   ,Main Class: Debug Logic"

   rgroup c14:0x3f8--0x3f8
    line.long 0x0 "PID0,Peripherial ID0"
     hexmask.long.byte 0x0 0.--7. 1 " PN     ,Part Number [7:0]"
   rgroup c14:0x3f9--0x3f9  
    line.long 0x0 "PID1,Peripherial ID1"
     hexmask.long.byte 0x0 4.--7. 1 " JEP106 ,JEP106 Identity Code [3:0]"
     hexmask.long.byte 0x0 0.--3. 1 "     PN     ,Part Number [11:8]"
   rgroup c14:0x3fa--0x3fa
    line.long 0x0 "PID2,Peripherial ID2"
     hexmask.long.byte 0x0 4.--7. 1 " REV    ,Revision"
     hexmask.long.byte 0x0 0.--2. 1 "     JEP106 ,JEP106 Identity Code [6:4]"
   rgroup c14:0x3fb--0x3fb
    line.long 0x0 "PID3,Peripherial ID3"
     hexmask.long.byte 0x0 4.--7. 1 " REVA   ,RevAnd"
     hexmask.long.byte 0x0 0.--3. 1 "     CMOD   ,Customer Modified"
   rgroup c14:0x3f4--0x3f4
    line.long 0x0 "PID4,Peripherial ID4"
     bitfld.long 0x0 4.--7. " 4KBC   ,Number of 4KB Blocks Occupied" "1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768"
     bitfld.long 0x0 0.--3. "  JEP106 ,JEP106 Continuation Code" "0000,0001,0010,0011,0100,0101,0110,0111,1000,1001,1010,1011,1100,1101,1110,1111"
   rgroup c14:0x3fc--0x3fc
    line.long 0x0 "COMPONENTID0,Component ID0"
     hexmask.long.byte 0x0 0.--7. 1 " PRBL   ,Preamble"
   rgroup c14:0x3fd--0x3fd
    line.long 0x0 "COMPONENTID1,Component ID1"
     hexmask.long.byte 0x0 4.--7. 1 " CCLASS ,Component Class (CoreSight Component)"
     hexmask.long.byte 0x0 0.--3. 1 "     PRBL   ,Preamble"
   rgroup c14:0x3fe--0x3fe
    line.long 0x0 "COMPONENTID2,Component ID2"
     hexmask.long.byte 0x0 0.--7. 1 " PRBL   ,Preamble"
   rgroup c14:0x3ff--0x3ff
    line.long 0x0 "COMPONENTID3,Component ID3"
     hexmask.long.byte 0x0 0.--7. 1 " PRBL   ,Preamble"
tree.end

textline "                     "
width 0x7

rgroup c14:0x000--0x000
 line.long 0x0 "DIDR,Debug ID Register"
  bitfld.long 0x0 28.--31. " WRP      ,Number of Watchpoint Register Pairs" "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16"
  bitfld.long 0x0 24.--27. "               BRP      ,Number of Breakpoint Register Pairs" "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16"
  bitfld.long 0x0 20.--23. "         Context ,Number of BRPs with Context ID Comparison Capability" "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16"
 textline "                "
  bitfld.long 0x0 16.--19. " Version  ,Debug Architecture Version" "Reserved,ARMv6,ARMv6.1,ARMv7,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
 textline "                "
  bitfld.long 0x0 13. " PCSAMPLE ,PC Sample register implemented" "Not implemented,Implemented"
  bitfld.long 0x0 12. "  Security ,Security Extensions implemented" "Not implemented,Implemented"
 textline "                "
  bitfld.long 0x0 4.--7. " Variant  ,Implementation-defined Variant Number" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
  bitfld.long 0x0 0.--3. "               Revision ,Implementation-defined Revision Number" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

width 0x7
group c14:0x22--0x22
 line.long 0x0 "DSCR,Debug Status and Control Register"
  bitfld.long 0x0 30. " DTRRXfull   ,The DTRRX Full Flag" "Empty,Full"
  bitfld.long 0x0 29. "                 DTRTXfull   ,The DTRTX Full Flag" "Empty,Full"
 textline "                "
 bitfld.long 0x00 27. " DTRRXfull_l ,The DTRRX Full Flag 1" "Empty,Full"
 bitfld.long 0x00 26. "                 DTRTXfull_l ,The DTRTX Full Flag 1" "Empty,Full"
 textline "                "
  bitfld.long 0x0 25. " SPA         ,Sticky Pipeline Advance" "No effect,Instruction retired"
  bitfld.long 0x0 24. "   IC          ,Instruction Complete" "Executing,Not executing"
 textline "                "
  bitfld.long 0x0 20.--21. " DTR         ,DTR Access Mode" "Non-blocking,Stall,Fast,Reserved"
  bitfld.long 0x0 19. "          NSWS        ,Imprecise Data Aborts discarded" "Not discarded,Discarded"
 textline "                "
 bitfld.long 0x0 18. " NS          ,Non-secure World Status" "Secured,Not secured"
  bitfld.long 0x0 17. "           nSPNIDEN    ,Secure Non-invasive Debug Disabled" "Enabled,Disabled"
 textline "                "
  bitfld.long 0x0 16. " nSPIDEN     ,Secure Invasive Debug Disabled" "Enabled,Disabled"
  bitfld.long 0x0 15. "              MONITOR     ,Monitor Debug-mode enable" "Disabled,Enabled"
   textline "                "
  bitfld.long 0x0 14. " HDEn        ,Halting Debug-mode enable" "Disabled,Enabled"
  bitfld.long 0x0 13. "              EXECUTE     ,Execute instruction enable" "Disabled,Enabled"
 textline "                "
  bitfld.long 0x0 12. " COMMS       ,User mode access to Comms Channel disable" "Enabled,Disabled"
  bitfld.long 0x0 11. "              IntDis      ,Disable Interrupts" "Enabled,Disabled"
 textline "                "
  bitfld.long 0x0 10. " DbgAck      ,Force Debug Acknowledge" "Not forced,Forced"
  bitfld.long 0x0 8. "            uExt        ,Sticky Undefined Exception" "No exception,Exception"
 textline "                "
  bitfld.long 0x0 7. " IABORT      ,Sticky Imprecise Abort" "Not aborted,Aborted"
  bitfld.long 0x0 6. "           PABORT      ,Sticky Precise Abort" "Not aborted,Aborted"
 textline "                "
  bitfld.long 0x0 2.--5. " MOE         ,Method of Debug Entry" "Debug Entry,Breakpoint,Imprecise Watchpoint,BKPT instruction,External debug,Vector catch,Reserved,Reserved,OS Unlock,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x0 1. "  RESTARTED   ,Core Restarted" "Debug not exited,Debug exited"
 textline "                "
  bitfld.long 0x0 0. " HALTED      ,Core Halted" "Normal state,Debug state"
width 0x7
if (((data.long(c14:0x00))&0x01000)==0x00000)
group c14:0x007--0x007
 line.long 0x0 "VCR,Vector Catch Register"
  bitfld.long 0x0 7. " FIQ     ,Vector Catch Enable FIQ" "Disabled,Enabled"
  bitfld.long 0x0 6. "  IRQ     ,Vector Catch Enable IRQ" "Disabled,Enabled"
 textline "                "
  bitfld.long 0x0 4. " DABORT  ,Vector Catch Enable Data Abort" "Disabled,Enabled"
  bitfld.long 0x0 3. "  PABORT  ,Vector Catch Enable Prefetch Abort" "Disabled,Enabled"
 textline "                "
  bitfld.long 0x0 2. " SWI     ,Vector Catch Enable SWI" "Disabled,Enabled"
  bitfld.long 0x0 1. "  UNDEF   ,Vector Catch Enable Undefined Instruction" "Disabled,Enabled"
 textline "                "
  bitfld.long 0x0 0. " RESET   ,Vector Catch Enable Reset" "Disabled,Enabled"
else
group c14:0x007--0x007
 line.long 0x0 "VCR,Vector Catch Register"
  bitfld.long 0x0 31. " FIQN    ,Vector Catch Enable FIQ (Non-secure)" "Disabled,Enabled"
  bitfld.long 0x0 30. "  IRQN    ,Vector Catch Enable IRQ (Non-secure)" "Disabled,Enabled"
 textline "                "
  bitfld.long 0x0 28. " DABORTN ,Vector Catch Enable Data Abort (Non-secure)" "Disabled,Enabled"
  bitfld.long 0x0 27. "  PABORTN ,Vector Catch Enable Prefetch abort (Non-secure)" "Disabled,Enabled"
 textline "                "
  bitfld.long 0x0 26. " SWIN    ,Vector Catch Enable SWI (Non-secure)" "Disabled,Enabled"
  bitfld.long 0x0 25. "  UNDEFS  ,Vector Catch Enable Undefined (Non-secure)" "Disabled,Enabled"
 textline "                "
  bitfld.long 0x0 15. " FIQS    ,Vector Catch Enable FIQ (Secure)" "Disabled,Enabled"
  bitfld.long 0x0 14. "  IRQS    ,Vector Catch Enable IRQ (Secure)" "Disabled,Enabled"
 textline "                "
  bitfld.long 0x0 12. " DABORTS ,Vector Catch Enable Data Abort (Secure)" "Disabled,Enabled"
 bitfld.long 0x00 11. "  PABORTS ,Vector Catch Enable Prefetch abort (Secure)" "Disabled,Enabled"
 textline "                "
  bitfld.long 0x0 10. " SMI     ,Vector Catch Enable SMI (Secure)" "Disabled,Enabled"
  bitfld.long 0x0 7. "  FIQ     ,Vector Catch Enable FIQ" "Disabled,Enabled"
  textline "                "
  bitfld.long 0x0 6. " IRQ     ,Vector Catch Enable IRQ" "Disabled,Enabled"
  bitfld.long 0x0 4. "  DABORT0 ,Vector Catch Enable Data Abort" "Disabled,Enabled"
 textline "                "
  bitfld.long 0x0 3. " PABORT  ,Vector Catch Enable Prefetch Abort" "Disabled,Enabled"
  bitfld.long 0x0 2. "  SWI     ,Vector Catch Enable SWI" "Disabled,Enabled"
 textline "                "
  bitfld.long 0x0 1. " UNDEF   ,Vector Catch Enable Undefined Instruction" "Disabled,Enabled"
  bitfld.long 0x0 0. "  RESET   ,Vector Catch Enable Reset" "Disabled,Enabled"
endif

;rgroup c14:0x1++0x1
; line.long 0x0 "DRAR,Debug ROM Address Register"
;  hexmask.long 0x0 12.--31. 0x1000 " DBROMPA ,Debug bus ROM physical address"
;  bitfld.long 0x0 0.--1. "  VB      ,Valid bits" "Not valid,Reserved,Reserved,Valid"
; line.long 0x4 "DSAR,Debug Self Address Offset Register"
;  hexmask.long 0x4 12.--31. 0x1000 " DBSAOV  ,Debug bus self-address offset value"
;  bitfld.long 0x4 0.--1. "  VB      ,Valid bits" "Not valid,Reserved,Reserved,Valid"
;hgroup c14:0x50++0x0
; hide.long 0x0 "DTR,Data Transfer Register"
;  in
width 0x7
hgroup c14:0x020--0x020
 hide.long 0x0 "DTRRX,Target -> Host Data Transfer Register"
  in
group c14:0x023--0x023
 line.long 0x0 "DTRTX,Host -> Target Data Transfer Register"
 hexmask.long 0x00 0.--31. 1 " HTD   ,Host -> target data"
group c14:0x09++0x00
 line.long 0x00 "ECR,Event Catch Register"
  bitfld.long 0x00 0. " OSUC  ,OS Unlock Catch" "Disabled,Enabled"
group c14:0x0a++0x00
 line.long 0x00 "DSCCR,Debug State Cache Control Register"
  bitfld.long 0x00 2. " NWT   ,Not Write-Through" "Forced,Normal"
  bitfld.long 0x00 0. "            DUCL ,Data and Unified Cache Linefill" "Disabled,Normal"
wgroup c14:0x21++0x00
 line.long 0x00 "ITR,Instruction Transfer Register"
  hexmask.long 0x00 0.--31. 1. " Data  ,ARM Instruction for the Processor in Debug State Execute"
wgroup c14:0x24++0x00
 line.long 0x00 "DRCR,Debug Run Control Register"
  bitfld.long 0x00 3. " CSPA  ,Clear Sticky Pipeline Advance" "Not cleared,Cleared"
  bitfld.long 0x00 2. "       CSE  ,Clear Sticky Exceptions" "Not cleared,Cleared"
   textline "                "
  bitfld.long 0x00 1. " RR    ,Restart Request" "Not requested,Requested"
  bitfld.long 0x00 0. "     HR   ,Halt Request" "Not requested,Requested"
wgroup c14:0xc0++0x00
 line.long 0x00 "OSLAR,Operating System Lock Access Register"
  hexmask.long 0x00 0.--31. 1. " OSLA  ,OS Lock Access"
rgroup c14:0xc1++0x00
 line.long 0x00 "OSLSR,Operating System Lock Status Register"
  bitfld.long 0x00 2. " 32_BA ,32-Bit Access" "Not required,Required"
  bitfld.long 0x00 1. "      LB   ,Locked Bit" "Not locked,Locked"
  bitfld.long 0x00 0. "     LIB ,Lock Implemented Bit" "Not implemented,Implemented"
group c14:0xc2++0x00
 line.long 0x00 "OSSRR,Operating System Save and Restore Register"
  hexmask.long 0x00 0.--31. 1. " OSSR  ,OS Save and Restore"
group c14:0xc4++0x00
 line.long 0x00 "PRCR,Device Power-Down and Reset Control Register"
  bitfld.long 0x00 0. " NPD   ,No Power-Down" "DBGNOPWRDWN low,DBGNOPWRDWN high"
hgroup c14:0xc5++0x00
 hide.long 0x00 "PRSR,Device Power-Down and Reset Status Register"
  in
tree.end

width 6.
tree "Breakpoint Registers"
 group c14:0x40++0x00
  line.long 0x00 "BVR0,Breakpoint Value Register 0"
   hexmask.long 0x00 0.--31. 1. " BV0 ,Breakpoint Value 0"
 group c14:0x50++0x00
  line.long 0x00 "BCR0,Breakpoint Control Register 0"
   bitfld.long 0x00 20.--22. " M   ,BVR Meaning" "IVA match,Linked IVA match,Reserved,Reserved,IVA mismatch,Linked IVA mismatch,Reserved,Reserved"
   bitfld.long 0x00 16.--19. "     LBRP ,Linked BRP Number" "BRP,BRP1,BRP2,BRP3,BRP4,BRP5,BRP6,BRP7,BRP8,BRP9,BRP10,BRP11,BRP12,BRP13,BRP14,BRP15"
   bitfld.long 0x00 14.--15. "     SWAC ,Secure World Access Control" "Both,Nonsecure,Secure,Reserved"
   textline "               "
   bitfld.long 0x0 8. " BAS ,Byte 3 address select" "0,1"
   bitfld.long 0x0 7. ",Byte 2 address select" "0,1"
    bitfld.long 0x0 6. ",Byte 1 address select" "0,1"
    bitfld.long 0x0 5. ",Byte 0 address select" "0,1"
   bitfld.long 0x00 1.--2. "        S  ,Supervisor Access Control" "User/system/supervisor,Privileged,User,Any"
   bitfld.long 0x00 0. "  B    ,Breakpoint Enable" "Disabled,Enabled"
 group c14:0x41++0x00
  line.long 0x00 "BVR1,Breakpoint Value Register 1"
   hexmask.long 0x00 0.--31. 1. " BV1 ,Breakpoint Value 1"
 group c14:0x51++0x00
  line.long 0x00 "BCR1,Breakpoint Control Register 1"
   bitfld.long 0x00 20.--22. " M   ,BVR Meaning" "IVA match,Linked IVA match,Reserved,Reserved,IVA mismatch,Linked IVA mismatch,Reserved,Reserved"
   bitfld.long 0x00 16.--19. "     LBRP ,Linked BRP Number" "BRP,BRP1,BRP2,BRP3,BRP4,BRP5,BRP6,BRP7,BRP8,BRP9,BRP10,BRP11,BRP12,BRP13,BRP14,BRP15"
   bitfld.long 0x00 14.--15. "     SWAC ,Secure World Access Control" "Both,Nonsecure,Secure,Reserved"
   textline "               "
   bitfld.long 0x0 8. " BAS ,Byte 3 address select" "0,1"
   bitfld.long 0x0 7. ",Byte 2 address select" "0,1"
    bitfld.long 0x0 6. ",Byte 1 address select" "0,1"
    bitfld.long 0x0 5. ",Byte 0 address select" "0,1"
   bitfld.long 0x00 1.--2. "        S  ,Supervisor Access Control" "User/system/supervisor,Privileged,User,Any"
   bitfld.long 0x00 0. "  B    ,Breakpoint Enable" "Disabled,Enabled"
 group c14:0x42++0x00
  line.long 0x00 "BVR2,Breakpoint Value Register 2"
   hexmask.long 0x00 0.--31. 1. " BV2 ,Breakpoint Value 2"
 group c14:0x52++0x00
  line.long 0x00 "BCR2,Breakpoint Control Register 2"
   bitfld.long 0x00 20.--22. " M   ,BVR Meaning" "IVA match,Linked IVA match,Reserved,Reserved,IVA mismatch,Linked IVA mismatch,Reserved,Reserved"
   bitfld.long 0x00 16.--19. "     LBRP ,Linked BRP Number" "BRP,BRP1,BRP2,BRP3,BRP4,BRP5,BRP6,BRP7,BRP8,BRP9,BRP10,BRP11,BRP12,BRP13,BRP14,BRP15"
   bitfld.long 0x00 14.--15. "     SWAC ,Secure World Access Control" "Both,Nonsecure,Secure,Reserved"
   textline "               "
   bitfld.long 0x0 8. " BAS ,Byte 3 address select" "0,1"
   bitfld.long 0x0 7. ",Byte 2 address select" "0,1"
    bitfld.long 0x0 6. ",Byte 1 address select" "0,1"
    bitfld.long 0x0 5. ",Byte 0 address select" "0,1"
   bitfld.long 0x00 1.--2. "        S  ,Supervisor Access Control" "User/system/supervisor,Privileged,User,Any"
   bitfld.long 0x00 0. "  B    ,Breakpoint Enable" "Disabled,Enabled"
 group c14:0x43++0x00
  line.long 0x00 "BVR3,Breakpoint Value Register 3"
   hexmask.long 0x00 0.--31. 1. " BV3 ,Breakpoint Value 3"
 group c14:0x53++0x00
  line.long 0x00 "BCR3,Breakpoint Control Register 3"
   bitfld.long 0x00 20.--22. " M   ,BVR Meaning" "IVA match,Linked IVA match,Reserved,Reserved,IVA mismatch,Linked IVA mismatch,Reserved,Reserved"
   bitfld.long 0x00 16.--19. "     LBRP ,Linked BRP Number" "BRP,BRP1,BRP2,BRP3,BRP4,BRP5,BRP6,BRP7,BRP8,BRP9,BRP10,BRP11,BRP12,BRP13,BRP14,BRP15"
   bitfld.long 0x00 14.--15. "     SWAC ,Secure World Access Control" "Both,Nonsecure,Secure,Reserved"
   textline "               "
   bitfld.long 0x0 8. " BAS ,Byte 3 address select" "0,1"
   bitfld.long 0x0 7. ",Byte 2 address select" "0,1"
    bitfld.long 0x0 6. ",Byte 1 address select" "0,1"
    bitfld.long 0x0 5. ",Byte 0 address select" "0,1"
   bitfld.long 0x00 1.--2. "        S  ,Supervisor Access Control" "User/system/supervisor,Privileged,User,Any"
   bitfld.long 0x00 0. "  B    ,Breakpoint Enable" "Disabled,Enabled"
 group c14:0x44++0x00
  line.long 0x00 "BVR4,Breakpoint Value Register 4"
   hexmask.long 0x00 0.--31. 1. " BV4 ,Breakpoint Value 4"
 group c14:0x54++0x00
  line.long 0x00 "BCR4,Breakpoint Control Register 4"
   bitfld.long 0x00 20.--22. " M   ,BVR Meaning" "IVA match,Linked IVA match,Unlinked ID,Linked ID,IVA mismatch,Linked IVA mismatch,Reserved,Reserved"
   bitfld.long 0x00 16.--19. "     LBRP ,Linked BRP Number" "BRP,BRP1,BRP2,BRP3,BRP4,BRP5,BRP6,BRP7,BRP8,BRP9,BRP10,BRP11,BRP12,BRP13,BRP14,BRP15"
   bitfld.long 0x00 14.--15. "     SWAC ,Secure World Access Control" "Both,Nonsecure,Secure,Reserved"
   textline "               "
   bitfld.long 0x0 8. " BAS ,Byte 3 address select" "0,1"
   bitfld.long 0x0 7. ",Byte 2 address select" "0,1"
    bitfld.long 0x0 6. ",Byte 1 address select" "0,1"
    bitfld.long 0x0 5. ",Byte 0 address select" "0,1"
   bitfld.long 0x00 1.--2. "        S  ,Supervisor Access Control" "User/system/supervisor,Privileged,User,Any"
   bitfld.long 0x00 0. "  B    ,Breakpoint Enable" "Disabled,Enabled"
 group c14:0x45++0x00
  line.long 0x00 "BVR5,Breakpoint Value Register 5"
   hexmask.long 0x00 0.--31. 1. " BV5 ,Breakpoint Value 5"
 group c14:0x55++0x00
  line.long 0x00 "BCR5,Breakpoint Control Register 5"
   bitfld.long 0x00 20.--22. " M   ,BVR Meaning" "IVA match,Linked IVA match,Unlinked ID,Linked ID,IVA mismatch,Linked IVA mismatch,Reserved,Reserved"
   bitfld.long 0x00 16.--19. "     LBRP ,Linked BRP Number" "BRP,BRP1,BRP2,BRP3,BRP4,BRP5,BRP6,BRP7,BRP8,BRP9,BRP10,BRP11,BRP12,BRP13,BRP14,BRP15"
   bitfld.long 0x00 14.--15. "     SWAC ,Secure World Access Control" "Both,Nonsecure,Secure,Reserved"
   textline "               "
   bitfld.long 0x0 8. " BAS ,Byte 3 address select" "0,1"
   bitfld.long 0x0 7. ",Byte 2 address select" "0,1"
    bitfld.long 0x0 6. ",Byte 1 address select" "0,1"
    bitfld.long 0x0 5. ",Byte 0 address select" "0,1"
   bitfld.long 0x00 1.--2. "        S  ,Supervisor Access Control" "User/system/supervisor,Privileged,User,Any"
   bitfld.long 0x00 0. "  B    ,Breakpoint Enable" "Disabled,Enabled"
tree.end

width 6.
tree "Watchpoint Control Registers"
 group c14:0x60++0x00
  line.long 0x00 "WVR0,Watchpoint Value Register 0"
   hexmask.long 0x00 2.--31. 0x04 " WA0   ,Watchpoint Address 0"
 group c14:0x70--0x70
  line.long 0x0 "WCR0,Watchpoint Control Register 0"
   bitfld.long 0x0 24.--28. " WAM   ,Watchpoint address mask" "Not masked,Reserved,Reserved,0x7,0xF,0x1F,0x3F,0x7F,0xFF,0x1FF,0x3FF,0x7FF,0xFFF,0x1FFF,0x3FFF,0x7FFF,0xFFFF,0x1FFFF,0x3FFFF,0x7FFFF,0xFFFFF,0x1FFFFF,0x3FFFFF,0x7FFFFF,0xFFFFFF,0x1FFFFFF,0x3FFFFFF,0x7FFFFFF,0xFFFFFFF,0x1FFFFFFF,0x3FFFFFFF,0x7FFFFFFF"
   bitfld.long 0x0 20. "  EL   ,Enable Linking" "Disabled,Enabled"
    textline "               "
   bitfld.long 0x0 16.--19. " LBN   ,Linked BRP number" "BRP,BRP1,BRP2,BRP3,BRP4,BRP5,BRP6,BRP7,BRP8,BRP9,BRP10,BRP11,BRP12,BRP13,BRP14,BRP15"
   bitfld.long 0x0 14.--15. "       SWAC ,Secure world access control" "Non-secure & Secure,Non-secure,Secure,Reserved"
    textline "               "
   bitfld.long 0x0 12. " BAS   ,Byte 7 address select" "0,1"
   bitfld.long 0x0 11. ",Byte 6 address select" "0,1"
   bitfld.long 0x0 10. ",Byte 5 address select" "0,1"
   bitfld.long 0x0 9. ",Byte 4 address select" "0,1"
   bitfld.long 0x0 8. ",Byte 3 address select" "0,1"
   bitfld.long 0x0 7. ",Byte 2 address select" "0,1"
   bitfld.long 0x0 6. ",Byte 1 address select" "0,1"
   bitfld.long 0x0 5. ",Byte 0 address select" "0,1"
  textline "               "
   bitfld.long 0x0 3.--4. " RD/WR ,Load/Store access control" "Reserved,Load,Store,Any"
   bitfld.long 0x0 1.--2. "    PAC  ,Privileged access control" "Reserved,Privileged,USR,Any"
    textline "               "
   bitfld.long 0x0 0. " WE    ,Watchpoint enable" "Disabled,Enabled"
 group c14:0x61++0x00
  line.long 0x00 "WVR1,Watchpoint Value Register 1"
   hexmask.long 0x00 2.--31. 0x04 " WA1   ,Watchpoint Address 1"
 group c14:0x71--0x71
  line.long 0x0 "WCR1,Watchpoint Control Register 1"
     bitfld.long 0x0 24.--28. " WAM   ,Watchpoint address mask" "Not masked,Reserved,Reserved,0x7,0xF,0x1F,0x3F,0x7F,0xFF,0x1FF,0x3FF,0x7FF,0xFFF,0x1FFF,0x3FFF,0x7FFF,0xFFFF,0x1FFFF,0x3FFFF,0x7FFFF,0xFFFFF,0x1FFFFF,0x3FFFFF,0x7FFFFF,0xFFFFFF,0x1FFFFFF,0x3FFFFFF,0x7FFFFFF,0xFFFFFFF,0x1FFFFFFF,0x3FFFFFFF,0x7FFFFFFF"
   bitfld.long 0x0 20. "  EL   ,Enable Linking" "Disabled,Enabled"
    textline "               "
   bitfld.long 0x0 16.--19. " LBN   ,Linked BRP number" "BRP,BRP1,BRP2,BRP3,BRP4,BRP5,BRP6,BRP7,BRP8,BRP9,BRP10,BRP11,BRP12,BRP13,BRP14,BRP15"
   bitfld.long 0x0 14.--15. "       SWAC ,Secure world access control" "Non-secure & Secure,Non-secure,Secure,Reserved"
    textline "               "
   bitfld.long 0x0 12. " BAS   ,Byte 7 address select" "0,1"
   bitfld.long 0x0 11. ",Byte 6 address select" "0,1"
   bitfld.long 0x0 10. ",Byte 5 address select" "0,1"
   bitfld.long 0x0 9. ",Byte 4 address select" "0,1"
   bitfld.long 0x0 8. ",Byte 3 address select" "0,1"
   bitfld.long 0x0 7. ",Byte 2 address select" "0,1"
   bitfld.long 0x0 6. ",Byte 1 address select" "0,1"
   bitfld.long 0x0 5. ",Byte 0 address select" "0,1"
  textline "               "
   bitfld.long 0x0 3.--4. " RD/WR ,Load/Store access control" "Reserved,Load,Store,Any"
   bitfld.long 0x0 1.--2. "    PAC  ,Privileged access control" "Reserved,Privileged,USR,Any"
    textline "               "
   bitfld.long 0x0 0. " WE    ,Watchpoint enable" "Disabled,Enabled"
group c14:0x62++0x00
  line.long 0x00 "WVR2,Watchpoint Value Register 2"
   hexmask.long 0x00 2.--31. 0x04 " WA2   ,Watchpoint Address 2"
 group c14:0x72--0x72
  line.long 0x0 "WCR2,Watchpoint Control Register 2"
   bitfld.long 0x0 24.--28. " WAM   ,Watchpoint address mask" "Not masked,Reserved,Reserved,0x7,0xF,0x1F,0x3F,0x7F,0xFF,0x1FF,0x3FF,0x7FF,0xFFF,0x1FFF,0x3FFF,0x7FFF,0xFFFF,0x1FFFF,0x3FFFF,0x7FFFF,0xFFFFF,0x1FFFFF,0x3FFFFF,0x7FFFFF,0xFFFFFF,0x1FFFFFF,0x3FFFFFF,0x7FFFFFF,0xFFFFFFF,0x1FFFFFFF,0x3FFFFFFF,0x7FFFFFFF"
   bitfld.long 0x0 20. "  EL   ,Enable Linking" "Disabled,Enabled"
    textline "               "
   bitfld.long 0x0 16.--19. " LBN   ,Linked BRP number" "BRP,BRP1,BRP2,BRP3,BRP4,BRP5,BRP6,BRP7,BRP8,BRP9,BRP10,BRP11,BRP12,BRP13,BRP14,BRP15"
   bitfld.long 0x0 14.--15. "       SWAC ,Secure world access control" "Non-secure & Secure,Non-secure,Secure,Reserved"
    textline "               "
   bitfld.long 0x0 12. " BAS   ,Byte 7 address select" "0,1"
   bitfld.long 0x0 11. ",Byte 6 address select" "0,1"
   bitfld.long 0x0 10. ",Byte 5 address select" "0,1"
   bitfld.long 0x0 9. ",Byte 4 address select" "0,1"
   bitfld.long 0x0 8. ",Byte 3 address select" "0,1"
   bitfld.long 0x0 7. ",Byte 2 address select" "0,1"
   bitfld.long 0x0 6. ",Byte 1 address select" "0,1"
   bitfld.long 0x0 5. ",Byte 0 address select" "0,1"
  textline "               "
   bitfld.long 0x0 3.--4. " RD/WR ,Load/Store access control" "Reserved,Load,Store,Any"
   bitfld.long 0x0 1.--2. "    PAC  ,Privileged access control" "Reserved,Privileged,USR,Any"
    textline "               "
   bitfld.long 0x0 0. " WE    ,Watchpoint enable" "Disabled,Enabled"
group c14:0x63++0x00
  line.long 0x00 "WVR3,Watchpoint Value Register 3"
   hexmask.long 0x00 2.--31. 0x04 " WA3   ,Watchpoint Address 3"
 group c14:0x73--0x73
  line.long 0x0 "WCR3,Watchpoint Control Register 3"
   bitfld.long 0x0 24.--28. " WAM   ,Watchpoint address mask" "Not masked,Reserved,Reserved,0x7,0xF,0x1F,0x3F,0x7F,0xFF,0x1FF,0x3FF,0x7FF,0xFFF,0x1FFF,0x3FFF,0x7FFF,0xFFFF,0x1FFFF,0x3FFFF,0x7FFFF,0xFFFFF,0x1FFFFF,0x3FFFFF,0x7FFFFF,0xFFFFFF,0x1FFFFFF,0x3FFFFFF,0x7FFFFFF,0xFFFFFFF,0x1FFFFFFF,0x3FFFFFFF,0x7FFFFFFF"
   bitfld.long 0x0 20. "  EL   ,Enable Linking" "Disabled,Enabled"
    textline "               "
   bitfld.long 0x0 16.--19. " LBN   ,Linked BRP number" "BRP,BRP1,BRP2,BRP3,BRP4,BRP5,BRP6,BRP7,BRP8,BRP9,BRP10,BRP11,BRP12,BRP13,BRP14,BRP15"
   bitfld.long 0x0 14.--15. "       SWAC ,Secure world access control" "Non-secure & Secure,Non-secure,Secure,Reserved"
    textline "               "
   bitfld.long 0x0 12. " BAS   ,Byte 7 address select" "0,1"
   bitfld.long 0x0 11. ",Byte 6 address select" "0,1"
   bitfld.long 0x0 10. ",Byte 5 address select" "0,1"
   bitfld.long 0x0 9. ",Byte 4 address select" "0,1"
   bitfld.long 0x0 8. ",Byte 3 address select" "0,1"
   bitfld.long 0x0 7. ",Byte 2 address select" "0,1"
   bitfld.long 0x0 6. ",Byte 1 address select" "0,1"
   bitfld.long 0x0 5. ",Byte 0 address select" "0,1"
  textline "               "
   bitfld.long 0x0 3.--4. " RD/WR ,Load/Store access control" "Reserved,Load,Store,Any"
   bitfld.long 0x0 1.--2. "    PAC  ,Privileged access control" "Reserved,Privileged,USR,Any"
    textline "               "
   bitfld.long 0x0 0. " WE    ,Watchpoint enable" "Disabled,Enabled"
 group c14:0x006--0x006
  line.long 0x0 "WFAR,Watchpoint Fault Address Register"
  hexmask.long.long 0x00 1.--31. 0x02 " WFAR  ,Address of the watchpointed instruction"
tree.end
width 0xb
tree.end

;--------------------------------------------------------------------------------
; AIPSTZ
;--------------------------------------------------------------------------------
tree.open "AIPSTZ"
    tree "AIPSTZ1"
        base ad:0x02000000

width 4.
group.long 0x0++0x3
    line.long 0x00 "MPR,Master Priviledge Registers"
        hexmask.long.byte 0x00 16.--20. 1. " MPROT3 ,Master 3 Priviledge, Buffer, Read, Write Control."
        textline "   "
        hexmask.long.byte 0x00 24.--28. 1. " MPROT1 ,Master 1 Priviledge, Buffer, Read, Write Control"
        textline "   "
        hexmask.long.byte 0x00 28.--32. 1. " MPROT0 ,Master 0 Priviledge, Buffer, Read, Write Control"
width 6.
group.long 0x40++0x3
    line.long 0x00 "OPACR,Off-Platform Peripheral Access Control Registers"
        hexmask.long.byte 0x00 0.--4. 1. " OPAC7 ,Off-platform Peripheral Access Control 7"
        textline "     "
        hexmask.long.byte 0x00 4.--8. 1. " OPAC6 ,Off-platform Peripheral Access Control 6"
        textline "     "
        hexmask.long.byte 0x00 8.--12. 1. " OPAC5 ,Off-platform Peripheral Access Control 5"
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " OPAC4 ,Off-platform Peripheral Access Control 4"
        textline "     "
        hexmask.long.byte 0x00 16.--20. 1. " OPAC3 ,Off-platform Peripheral Access Control 3"
        textline "     "
        hexmask.long.byte 0x00 20.--24. 1. " OPAC2 ,Off-platform Peripheral Access Control 2"
        textline "     "
        hexmask.long.byte 0x00 24.--28. 1. " OPAC1 ,Off-platform Peripheral Access Control 1"
        textline "     "
        hexmask.long.byte 0x00 28.--32. 1. " OPAC0 ,Off-platform Peripheral Access Control 0"
width 7.
group.long 0x44++0x3
    line.long 0x00 "OPACR1,Off-Platform Peripheral Access Control Registers"
        hexmask.long.byte 0x00 0.--4. 1. " OPAC15 ,Off-platform Peripheral Access Control 15"
        textline "      "
        hexmask.long.byte 0x00 4.--8. 1. " OPAC14 ,Off-platform Peripheral Access Control 14"
        textline "      "
        hexmask.long.byte 0x00 8.--12. 1. " OPAC13 ,Off-platform Peripheral Access Control 13"
        textline "      "
        hexmask.long.byte 0x00 12.--16. 1. " OPAC12 ,Off-platform Peripheral Access Control 12"
        textline "      "
        hexmask.long.byte 0x00 16.--20. 1. " OPAC11 ,Off-platform Peripheral Access Control 11"
        textline "      "
        hexmask.long.byte 0x00 20.--24. 1. " OPAC10 ,Off-platform Peripheral Access Control 10"
        textline "      "
        hexmask.long.byte 0x00 24.--28. 1. " OPAC9 ,Off-platform Peripheral Access Control 9"
        textline "      "
        hexmask.long.byte 0x00 28.--32. 1. " OPAC8 ,Off-platform Peripheral Access Control 8"
width 7.
group.long 0x48++0x3
    line.long 0x00 "OPACR2,Off-Platform Peripheral Access Control Registers"
        hexmask.long.byte 0x00 0.--4. 1. " OPAC23 ,Off-platform Peripheral Access Control 23"
        textline "      "
        hexmask.long.byte 0x00 4.--8. 1. " OPAC22 ,Off-platform Peripheral Access Control 22"
        textline "      "
        hexmask.long.byte 0x00 8.--12. 1. " OPAC21 ,Off-platform Peripheral Access Control 21"
        textline "      "
        hexmask.long.byte 0x00 12.--16. 1. " OPAC20 ,Off-platform Peripheral Access Control 20"
        textline "      "
        hexmask.long.byte 0x00 16.--20. 1. " OPAC19 ,Off-platform Peripheral Access Control 19"
        textline "      "
        hexmask.long.byte 0x00 20.--24. 1. " OPAC18 ,Off-platform Peripheral Access Control 18"
        textline "      "
        hexmask.long.byte 0x00 24.--28. 1. " OPAC17 ,Off-platform Peripheral Access Control 17"
        textline "      "
        hexmask.long.byte 0x00 28.--32. 1. " OPAC16 ,Off-platform Peripheral Access Control 16"
width 7.
group.long 0x4c++0x3
    line.long 0x00 "OPACR3,Off-Platform Peripheral Access Control Registers"
        hexmask.long.byte 0x00 0.--4. 1. " OPAC31 ,Off-platform Peripheral Access Control 31"
        textline "      "
        hexmask.long.byte 0x00 4.--8. 1. " OPAC30 ,Off-platform Peripheral Access Control 30"
        textline "      "
        hexmask.long.byte 0x00 8.--12. 1. " OPAC29 ,Off-platform Peripheral Access Control 29"
        textline "      "
        hexmask.long.byte 0x00 12.--16. 1. " OPAC28 ,Off-platform Peripheral Access Control 28"
        textline "      "
        hexmask.long.byte 0x00 16.--20. 1. " OPAC27 ,Off-platform Peripheral Access Control 27"
        textline "      "
        hexmask.long.byte 0x00 20.--24. 1. " OPAC26 ,Off-platform Peripheral Access Control 26"
        textline "      "
        hexmask.long.byte 0x00 24.--28. 1. " OPAC25 ,Off-platform Peripheral Access Control 25"
        textline "      "
        hexmask.long.byte 0x00 28.--32. 1. " OPAC24 ,Off-platform Peripheral Access Control 24"
width 7.
group.long 0x50++0x3
    line.long 0x00 "OPACR4,Off-Platform Peripheral Access Control Registers"
        hexmask.long.byte 0x00 24.--28. 1. " OPAC33 ,Off-platform Peripheral Access Control 33"
        textline "      "
        hexmask.long.byte 0x00 28.--32. 1. " OPAC32 ,Off-platform Peripheral Access Control 32"


    tree.end
    tree "AIPSTZ2"
        base ad:0x02100000

width 4.
group.long 0x0++0x3
    line.long 0x00 "MPR,Master Priviledge Registers"
        hexmask.long.byte 0x00 16.--20. 1. " MPROT3 ,Master 3 Priviledge, Buffer, Read, Write Control."
        textline "   "
        hexmask.long.byte 0x00 24.--28. 1. " MPROT1 ,Master 1 Priviledge, Buffer, Read, Write Control"
        textline "   "
        hexmask.long.byte 0x00 28.--32. 1. " MPROT0 ,Master 0 Priviledge, Buffer, Read, Write Control"
width 6.
group.long 0x40++0x3
    line.long 0x00 "OPACR,Off-Platform Peripheral Access Control Registers"
        hexmask.long.byte 0x00 0.--4. 1. " OPAC7 ,Off-platform Peripheral Access Control 7"
        textline "     "
        hexmask.long.byte 0x00 4.--8. 1. " OPAC6 ,Off-platform Peripheral Access Control 6"
        textline "     "
        hexmask.long.byte 0x00 8.--12. 1. " OPAC5 ,Off-platform Peripheral Access Control 5"
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " OPAC4 ,Off-platform Peripheral Access Control 4"
        textline "     "
        hexmask.long.byte 0x00 16.--20. 1. " OPAC3 ,Off-platform Peripheral Access Control 3"
        textline "     "
        hexmask.long.byte 0x00 20.--24. 1. " OPAC2 ,Off-platform Peripheral Access Control 2"
        textline "     "
        hexmask.long.byte 0x00 24.--28. 1. " OPAC1 ,Off-platform Peripheral Access Control 1"
        textline "     "
        hexmask.long.byte 0x00 28.--32. 1. " OPAC0 ,Off-platform Peripheral Access Control 0"
width 7.
group.long 0x44++0x3
    line.long 0x00 "OPACR1,Off-Platform Peripheral Access Control Registers"
        hexmask.long.byte 0x00 0.--4. 1. " OPAC15 ,Off-platform Peripheral Access Control 15"
        textline "      "
        hexmask.long.byte 0x00 4.--8. 1. " OPAC14 ,Off-platform Peripheral Access Control 14"
        textline "      "
        hexmask.long.byte 0x00 8.--12. 1. " OPAC13 ,Off-platform Peripheral Access Control 13"
        textline "      "
        hexmask.long.byte 0x00 12.--16. 1. " OPAC12 ,Off-platform Peripheral Access Control 12"
        textline "      "
        hexmask.long.byte 0x00 16.--20. 1. " OPAC11 ,Off-platform Peripheral Access Control 11"
        textline "      "
        hexmask.long.byte 0x00 20.--24. 1. " OPAC10 ,Off-platform Peripheral Access Control 10"
        textline "      "
        hexmask.long.byte 0x00 24.--28. 1. " OPAC9 ,Off-platform Peripheral Access Control 9"
        textline "      "
        hexmask.long.byte 0x00 28.--32. 1. " OPAC8 ,Off-platform Peripheral Access Control 8"
width 7.
group.long 0x48++0x3
    line.long 0x00 "OPACR2,Off-Platform Peripheral Access Control Registers"
        hexmask.long.byte 0x00 0.--4. 1. " OPAC23 ,Off-platform Peripheral Access Control 23"
        textline "      "
        hexmask.long.byte 0x00 4.--8. 1. " OPAC22 ,Off-platform Peripheral Access Control 22"
        textline "      "
        hexmask.long.byte 0x00 8.--12. 1. " OPAC21 ,Off-platform Peripheral Access Control 21"
        textline "      "
        hexmask.long.byte 0x00 12.--16. 1. " OPAC20 ,Off-platform Peripheral Access Control 20"
        textline "      "
        hexmask.long.byte 0x00 16.--20. 1. " OPAC19 ,Off-platform Peripheral Access Control 19"
        textline "      "
        hexmask.long.byte 0x00 20.--24. 1. " OPAC18 ,Off-platform Peripheral Access Control 18"
        textline "      "
        hexmask.long.byte 0x00 24.--28. 1. " OPAC17 ,Off-platform Peripheral Access Control 17"
        textline "      "
        hexmask.long.byte 0x00 28.--32. 1. " OPAC16 ,Off-platform Peripheral Access Control 16"
width 7.
group.long 0x4c++0x3
    line.long 0x00 "OPACR3,Off-Platform Peripheral Access Control Registers"
        hexmask.long.byte 0x00 0.--4. 1. " OPAC31 ,Off-platform Peripheral Access Control 31"
        textline "      "
        hexmask.long.byte 0x00 4.--8. 1. " OPAC30 ,Off-platform Peripheral Access Control 30"
        textline "      "
        hexmask.long.byte 0x00 8.--12. 1. " OPAC29 ,Off-platform Peripheral Access Control 29"
        textline "      "
        hexmask.long.byte 0x00 12.--16. 1. " OPAC28 ,Off-platform Peripheral Access Control 28"
        textline "      "
        hexmask.long.byte 0x00 16.--20. 1. " OPAC27 ,Off-platform Peripheral Access Control 27"
        textline "      "
        hexmask.long.byte 0x00 20.--24. 1. " OPAC26 ,Off-platform Peripheral Access Control 26"
        textline "      "
        hexmask.long.byte 0x00 24.--28. 1. " OPAC25 ,Off-platform Peripheral Access Control 25"
        textline "      "
        hexmask.long.byte 0x00 28.--32. 1. " OPAC24 ,Off-platform Peripheral Access Control 24"
width 7.
group.long 0x50++0x3
    line.long 0x00 "OPACR4,Off-Platform Peripheral Access Control Registers"
        hexmask.long.byte 0x00 24.--28. 1. " OPAC33 ,Off-platform Peripheral Access Control 33"
        textline "      "
        hexmask.long.byte 0x00 28.--32. 1. " OPAC32 ,Off-platform Peripheral Access Control 32"


    tree.end

tree.end



;--------------------------------------------------------------------------------
; ARMGLOBALTIMER
;--------------------------------------------------------------------------------
tree "ARMGLOBALTIMER"
    base ad:0x00a00000

width 9.
group.long 0x200++0x3
    line.long 0x00 "COUNTER0,Global Timer Counter Registers"
        hexmask.long.long 0x00 0.--32. 1. " VALUE ,32-bits of the counter value."
width 9.
group.long 0x204++0x3
    line.long 0x00 "COUNTER1,Global Timer Counter Registers"
        hexmask.long.long 0x00 0.--32. 1. " VALUE ,32-bits of the counter value."
width 8.
group.long 0x208++0x3
    line.long 0x00 "CONTROL,Global Timer Control Register"
        bitfld.long 0x00 0. " TIMER_ENABLE ,Timer enable." "0,1"
        textline "       "
        bitfld.long 0x00 1. " COMP_ENABLE ,This bit is banked per Cortex-A9 processor." "0,1"
        textline "       "
        bitfld.long 0x00 2. " IRQ_ENABLE ,This bit is banked per Cortex-A9 processor." "0,1"
        textline "       "
        bitfld.long 0x00 3. " AUTO_INCREMENT ,This bit is banked per Cortex-A9 processor." "0,1"
        textline "       "
        hexmask.long.byte 0x00 8.--16. 1. " PRESCALER ,The prescaler modifies the clock period for the decrementing event for the Counter Register."
width 10.
group.long 0x20c++0x3
    line.long 0x00 "IRQSTATUS,Global Timer Interrupt Status Register"
        bitfld.long 0x00 0. " EVENT_FLAG ,The event flag is a sticky bit that is automatically set when the Counter Register reaches the Comparator Register value." "0,1"
width 12.
group.long 0x210++0x3
    line.long 0x00 "COMPARATOR0,Global Timer Comparator Value Registers"
        hexmask.long.long 0x00 0.--32. 1. " VALUE ,32-bits of the comparator value."
width 12.
group.long 0x214++0x3
    line.long 0x00 "COMPARATOR1,Global Timer Comparator Value Registers"
        hexmask.long.long 0x00 0.--32. 1. " VALUE ,32-bits of the comparator value."
width 14.
group.long 0x218++0x3
    line.long 0x00 "AUTOINCREMENT,Global Timer Auto-increment Register"
        hexmask.long.long 0x00 0.--32. 1. " VALUE ,32-bit auto-increment value."


tree.end



;--------------------------------------------------------------------------------
; AUDMUX
;--------------------------------------------------------------------------------
tree "AUDMUX"
    base ad:0x021d8000

width 6.
group.long 0x0++0x3
    line.long 0x00 "PTCR1,Port Timing Control Register 1"
        bitfld.long 0x00 11. " SYN ,Synchronous/Asynchronous Select." "0,1"
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " RCSEL ,Receive Clock Select."
        textline "     "
        bitfld.long 0x00 16. " RCLKDIR ,Receive Clock Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 17.--21. 1. " RFSEL ,Receive Frame Sync Select."
        textline "     "
        bitfld.long 0x00 21. " RFS_DIR ,Receive Frame Sync Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 22.--26. 1. " TCSEL ,Transmit Clock Select."
        textline "     "
        bitfld.long 0x00 26. " TCLKDIR ,Transmit Clock Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 27.--31. 1. " TFSEL ,Transmit Frame Sync Select."
        textline "     "
        bitfld.long 0x00 31. " TFS_DIR ,Transmit Frame Sync Direction Control." "0,1"
width 6.
group.long 0x4++0x3
    line.long 0x00 "PDCR1,Port Data Control Register 1"
        hexmask.long.byte 0x00 0.--8. 1. " INMMASK ,Internal Network Mode Mask."
        textline "     "
        bitfld.long 0x00 8. " MODE ,Mode Select." "0,1"
        textline "     "
        bitfld.long 0x00 12. " TXRXEN ,Transmit/Receive Switch Enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 13.--16. 1. " RXDSEL ,Receive Data Select."
width 6.
group.long 0x8++0x3
    line.long 0x00 "PTCR2,Port Timing Control Register 2"
        bitfld.long 0x00 11. " SYN ,Synchronous/Asynchronous Select." "0,1"
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " RCSEL ,Receive Clock Select."
        textline "     "
        bitfld.long 0x00 16. " RCLKDIR ,Receive Clock Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 17.--21. 1. " RFSEL ,Receive Frame Sync Select."
        textline "     "
        bitfld.long 0x00 21. " RFS_DIR ,Receive Frame Sync Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 22.--26. 1. " TCSEL ,Transmit Clock Select."
        textline "     "
        bitfld.long 0x00 26. " TCLKDIR ,Transmit Clock Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 27.--31. 1. " TFSEL ,Transmit Frame Sync Select."
        textline "     "
        bitfld.long 0x00 31. " TFS_DIR ,Transmit Frame Sync Direction Control." "0,1"
width 6.
group.long 0xc++0x3
    line.long 0x00 "PDCR2,Port Data Control Register 2"
        hexmask.long.byte 0x00 0.--8. 1. " INMMASK ,Internal Network Mode Mask."
        textline "     "
        bitfld.long 0x00 8. " MODE ,Mode Select." "0,1"
        textline "     "
        bitfld.long 0x00 12. " TXRXEN ,Transmit/Receive Switch Enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 13.--16. 1. " RXDSEL ,Receive Data Select."
width 6.
group.long 0x10++0x3
    line.long 0x00 "PTCR3,Port Timing Control Register 3"
        bitfld.long 0x00 11. " SYN ,Synchronous/Asynchronous Select." "0,1"
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " RCSEL ,Receive Clock Select."
        textline "     "
        bitfld.long 0x00 16. " RCLKDIR ,Receive Clock Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 17.--21. 1. " RFSEL ,Receive Frame Sync Select."
        textline "     "
        bitfld.long 0x00 21. " RFS_DIR ,Receive Frame Sync Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 22.--26. 1. " TCSEL ,Transmit Clock Select."
        textline "     "
        bitfld.long 0x00 26. " TCLKDIR ,Transmit Clock Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 27.--31. 1. " TFSEL ,Transmit Frame Sync Select."
        textline "     "
        bitfld.long 0x00 31. " TFS_DIR ,Transmit Frame Sync Direction Control." "0,1"
width 6.
group.long 0x14++0x3
    line.long 0x00 "PDCR3,Port Data Control Register 3"
        hexmask.long.byte 0x00 0.--8. 1. " INMMASK ,Internal Network Mode Mask."
        textline "     "
        bitfld.long 0x00 8. " MODE ,Mode Select." "0,1"
        textline "     "
        bitfld.long 0x00 12. " TXRXEN ,Transmit/Receive Switch Enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 13.--16. 1. " RXDSEL ,Receive Data Select."
width 6.
group.long 0x18++0x3
    line.long 0x00 "PTCR4,Port Timing Control Register 4"
        bitfld.long 0x00 11. " SYN ,Synchronous/Asynchronous Select." "0,1"
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " RCSEL ,Receive Clock Select."
        textline "     "
        bitfld.long 0x00 16. " RCLKDIR ,Receive Clock Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 17.--21. 1. " RFSEL ,Receive Frame Sync Select."
        textline "     "
        bitfld.long 0x00 21. " RFS_DIR ,Receive Frame Sync Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 22.--26. 1. " TCSEL ,Transmit Clock Select."
        textline "     "
        bitfld.long 0x00 26. " TCLKDIR ,Transmit Clock Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 27.--31. 1. " TFSEL ,Transmit Frame Sync Select."
        textline "     "
        bitfld.long 0x00 31. " TFS_DIR ,Transmit Frame Sync Direction Control." "0,1"
width 6.
group.long 0x1c++0x3
    line.long 0x00 "PDCR4,Port Data Control Register 4"
        hexmask.long.byte 0x00 0.--8. 1. " INMMASK ,Internal Network Mode Mask."
        textline "     "
        bitfld.long 0x00 8. " MODE ,Mode Select." "0,1"
        textline "     "
        bitfld.long 0x00 12. " TXRXEN ,Transmit/Receive Switch Enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 13.--16. 1. " RXDSEL ,Receive Data Select."
width 6.
group.long 0x20++0x3
    line.long 0x00 "PTCR5,Port Timing Control Register 5"
        bitfld.long 0x00 11. " SYN ,Synchronous/Asynchronous Select." "0,1"
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " RCSEL ,Receive Clock Select."
        textline "     "
        bitfld.long 0x00 16. " RCLKDIR ,Receive Clock Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 17.--21. 1. " RFSEL ,Receive Frame Sync Select."
        textline "     "
        bitfld.long 0x00 21. " RFS_DIR ,Receive Frame Sync Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 22.--26. 1. " TCSEL ,Transmit Clock Select."
        textline "     "
        bitfld.long 0x00 26. " TCLKDIR ,Transmit Clock Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 27.--31. 1. " TFSEL ,Transmit Frame Sync Select."
        textline "     "
        bitfld.long 0x00 31. " TFS_DIR ,Transmit Frame Sync Direction Control." "0,1"
width 6.
group.long 0x24++0x3
    line.long 0x00 "PDCR5,Port Data Control Register 5"
        hexmask.long.byte 0x00 0.--8. 1. " INMMASK ,Internal Network Mode Mask."
        textline "     "
        bitfld.long 0x00 8. " MODE ,Mode Select." "0,1"
        textline "     "
        bitfld.long 0x00 12. " TXRXEN ,Transmit/Receive Switch Enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 13.--16. 1. " RXDSEL ,Receive Data Select."
width 6.
group.long 0x28++0x3
    line.long 0x00 "PTCR6,Port Timing Control Register 6"
        bitfld.long 0x00 11. " SYN ,Synchronous/Asynchronous Select." "0,1"
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " RCSEL ,Receive Clock Select."
        textline "     "
        bitfld.long 0x00 16. " RCLKDIR ,Receive Clock Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 17.--21. 1. " RFSEL ,Receive Frame Sync Select."
        textline "     "
        bitfld.long 0x00 21. " RFS_DIR ,Receive Frame Sync Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 22.--26. 1. " TCSEL ,Transmit Clock Select."
        textline "     "
        bitfld.long 0x00 26. " TCLKDIR ,Transmit Clock Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 27.--31. 1. " TFSEL ,Transmit Frame Sync Select."
        textline "     "
        bitfld.long 0x00 31. " TFS_DIR ,Transmit Frame Sync Direction Control." "0,1"
width 6.
group.long 0x2c++0x3
    line.long 0x00 "PDCR6,Port Data Control Register 6"
        hexmask.long.byte 0x00 0.--8. 1. " INMMASK ,Internal Network Mode Mask."
        textline "     "
        bitfld.long 0x00 8. " MODE ,Mode Select." "0,1"
        textline "     "
        bitfld.long 0x00 12. " TXRXEN ,Transmit/Receive Switch Enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 13.--16. 1. " RXDSEL ,Receive Data Select."
width 6.
group.long 0x30++0x3
    line.long 0x00 "PTCR7,Port Timing Control Register 7"
        bitfld.long 0x00 11. " SYN ,Synchronous/Asynchronous Select." "0,1"
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " RCSEL ,Receive Clock Select."
        textline "     "
        bitfld.long 0x00 16. " RCLKDIR ,Receive Clock Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 17.--21. 1. " RFSEL ,Receive Frame Sync Select."
        textline "     "
        bitfld.long 0x00 21. " RFS_DIR ,Receive Frame Sync Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 22.--26. 1. " TCSEL ,Transmit Clock Select."
        textline "     "
        bitfld.long 0x00 26. " TCLKDIR ,Transmit Clock Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 27.--31. 1. " TFSEL ,Transmit Frame Sync Select."
        textline "     "
        bitfld.long 0x00 31. " TFS_DIR ,Transmit Frame Sync Direction Control." "0,1"
width 6.
group.long 0x34++0x3
    line.long 0x00 "PDCR7,Port Data Control Register 7"
        hexmask.long.byte 0x00 0.--8. 1. " INMMASK ,Internal Network Mode Mask."
        textline "     "
        bitfld.long 0x00 8. " MODE ,Mode Select." "0,1"
        textline "     "
        bitfld.long 0x00 12. " TXRXEN ,Transmit/Receive Switch Enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 13.--16. 1. " RXDSEL ,Receive Data Select."


tree.end



;--------------------------------------------------------------------------------
; CCM
;--------------------------------------------------------------------------------
tree "CCM"
    base ad:0x020c4000

width 4.
group.long 0x0++0x3
    line.long 0x00 "CCR,CCM Control Register"
        hexmask.long.byte 0x00 0.--8. 1. " OSCNT ,Oscillator ready counter value."
        textline "   "
        bitfld.long 0x00 12. " COSC_EN ,On chip oscillator enable bit - this bit value is reflected on the output cosc_en." "0,1"
        textline "   "
        hexmask.long.byte 0x00 16.--19. 1. " WB_COUNT ,Well Bias counter."
        textline "   "
        hexmask.long.byte 0x00 21.--27. 1. " REG_BYPASS_COUNT ,Counter for analog_reg_bypass signal assertion after standby voltage request by pmic_vstby_req."
        textline "   "
        bitfld.long 0x00 27. " RBC_EN ,Enable for REG_BYPASS_COUNTER." "0,1"
width 5.
group.long 0x4++0x3
    line.long 0x00 "CCDR,CCM Control Divider Register"
        bitfld.long 0x00 16. " MMDC_ROOT_MASK ,During divider ratio mmdc_root_axi_podf change or sync mux periph2_clk_sel change (but not jtag) or SRC request during warm reset, mask handshake with mmdc_root module." "0,1"
        textline "    "
        bitfld.long 0x00 17. " MMDC_CH0_MASK ,During divider ratio mmdc_ch0_axi_podf change or sync mux periph_clk_sel change (but not jtag) or SRC request during warm reset, mask handshake with mmdc_ch0 module." "0,1"
width 4.
rgroup.long 0x8++0x3
    line.long 0x00 "CSR,CCM Status Register"
        bitfld.long 0x00 0. " REF_EN_B ,Status of the value of CCM_REF_EN_B output of ccm" "0,1"
        textline "   "
        bitfld.long 0x00 5. " COSC_READY ,Status indication of on board oscillator." "0,1"
width 5.
group.long 0xc++0x3
    line.long 0x00 "CCSR,CCM Clock Swither Register"
        bitfld.long 0x00 0. " PLL3_SW_CLK_SEL ,Selects source to generate pll3_sw_clk." "0,1"
        textline "    "
        bitfld.long 0x00 1. " PLL2_SW_CLK_SEL ,Selects source to generate pll2_sw_clk." "0,1"
        textline "    "
        bitfld.long 0x00 2. " PLL1_SW_CLK_SEL ,Selects source to generate pll1_sw_clk." "0,1"
        textline "    "
        bitfld.long 0x00 8. " STEP_SEL ,Selects the option to be chosen for the step frequency when shifting ARM frequency." "0,1"
        textline "    "
        bitfld.long 0x00 9. " PDF_396M_DIS_MASK ,Mask of 396M PFD auto-disable." "0,1"
        textline "    "
        bitfld.long 0x00 10. " PDF_352M_DIS_MASK ,Mask of 352M PFD auto-disable." "0,1"
        textline "    "
        bitfld.long 0x00 11. " PDF_594M_DIS_MASK ,Mask of 594M PFD auto-disable." "0,1"
        textline "    "
        bitfld.long 0x00 12. " PDF_508M_DIS_MASK ,Mask of 508M PFD auto-disable." "0,1"
        textline "    "
        bitfld.long 0x00 13. " PDF_454M_DIS_MASK ,Mask of 454M PFD auto-disable." "0,1"
        textline "    "
        bitfld.long 0x00 14. " PDF_720M_DIS_MASK ,Mask of 720M PFD auto-disable." "0,1"
        textline "    "
        bitfld.long 0x00 15. " PDF_540M_DIS_MASK ,Mask of 540M PFD auto-disable." "0,1"
width 6.
group.long 0x10++0x3
    line.long 0x00 "CACRR,CCM Arm Clock Root Register"
        hexmask.long.byte 0x00 0.--3. 1. " ARM_PODF ,Divider for ARM clock root."
width 6.
group.long 0x14++0x3
    line.long 0x00 "CBCDR,CCM Bus Clock Divider Register"
        hexmask.long.byte 0x00 0.--3. 1. " PERIPH2_CLK2_PODF ,Divider for periph2_clk2 podf."
        textline "     "
        hexmask.long.byte 0x00 3.--6. 1. " FABRIC_MMDC_PODF ,Post divider for fabric_mmdc clock."
        textline "     "
        bitfld.long 0x00 6. " OCRAM_CLK_SEL ,OCRAM clock source select" "0,1"
        textline "     "
        bitfld.long 0x00 7. " OCRAM_ALT_CLK_SEL ,OCRAM alternative clock select" "0,1"
        textline "     "
        hexmask.long.byte 0x00 8.--10. 1. " IPG_PODF ,Divider for ipg podf."
        textline "     "
        hexmask.long.byte 0x00 10.--13. 1. " AHB_PODF ,Divider for ahb podf."
        textline "     "
        hexmask.long.byte 0x00 16.--19. 1. " OCRAM_PODF ,Post divider for ocram clock."
        textline "     "
        bitfld.long 0x00 25. " PERIPH_CLK_SEL ,Selector for peripheral main clock (source of mmdc_ch0_axi_clk_root)." "0,1"
        textline "     "
        bitfld.long 0x00 26. " PERIPH2_CLK_SEL ,Selector for peripheral2 main clock (source of mmdc_root_axi_clk_root )." "0,1"
        textline "     "
        hexmask.long.byte 0x00 27.--30. 1. " PERIPH_CLK2_PODF ,Divider for periph2 clock podf."
width 6.
group.long 0x18++0x3
    line.long 0x00 "CBCMR,CCM Bus Clock Multiplexer Register"
        hexmask.long.byte 0x00 4.--6. 1. " GPU2D_OVG_CORE_CLK_SEL ,Selector for gpu2d_ovg_core clock multiplexer"
        textline "     "
        hexmask.long.byte 0x00 8.--10. 1. " GPU2D_CORE_CLK_SEL ,Selector for gpu2d_core clock multiplexer"
        textline "     "
        bitfld.long 0x00 11. " VDOAXI_CLK_SEL ,Selector for vdoaxi clock multiplexer" "0,1"
        textline "     "
        hexmask.long.byte 0x00 12.--14. 1. " PERIPH_CLK2_SEL ,Selector for peripheral clk2 clock multiplexer"
        textline "     "
        hexmask.long.byte 0x00 18.--20. 1. " PRE_PERIPH_CLK_SEL ,Selector for pre_periph clock multiplexer"
        textline "     "
        bitfld.long 0x00 20. " PERIPH2_CLK2_SEL ,Selector for periph2_clk2 clock multiplexer" "0,1"
        textline "     "
        hexmask.long.byte 0x00 21.--23. 1. " PRE_PERIPH2_CLK_SEL ,Selector for pre_periph2 clock multiplexer"
        textline "     "
        hexmask.long.byte 0x00 23.--26. 1. " EPDC_PIX_PODF ,Post divider for EPDC_PIX."
        textline "     "
        hexmask.long.byte 0x00 26.--29. 1. " GPU2D_OVG_CORE_PODF ,Divider for gpu3d_core clock."
        textline "     "
        hexmask.long.byte 0x00 29.--32. 1. " GPU2D_CORE_PODF ,Post divider for gpu2d_core clock."
width 7.
group.long 0x1c++0x3
    line.long 0x00 "CSCMR1,CCM Serial Clock Multiplexer Register 1"
        hexmask.long.byte 0x00 0.--6. 1. " PERCLK_PODF ,Divider for perclk podf."
        textline "      "
        bitfld.long 0x00 6. " PERCLK_CLK_SEL ,Selector for the perclk clock multiplexor" "0,1"
        textline "      "
        hexmask.long.byte 0x00 10.--12. 1. " SSI1_CLK_SEL ,Selector for ssi1 clock multiplexer"
        textline "      "
        hexmask.long.byte 0x00 12.--14. 1. " SSI2_CLK_SEL ,Selector for ssi2 clock multiplexer"
        textline "      "
        hexmask.long.byte 0x00 14.--16. 1. " SSI3_CLK_SEL ,Selector for ssi3 clock multiplexer"
        textline "      "
        bitfld.long 0x00 16. " USDHC1_CLK_SEL ,Selector for usdhc1 clock multiplexer" "0,1"
        textline "      "
        bitfld.long 0x00 17. " USDHC2_CLK_SEL ,Selector for usdhc2 clock multiplexer" "0,1"
        textline "      "
        bitfld.long 0x00 18. " USDHC3_CLK_SEL ,Selector for usdhc3 clock multiplexer" "0,1"
        textline "      "
        bitfld.long 0x00 19. " USDHC4_CLK_SEL ,Selector for usdhc4 clock multiplexer" "0,1"
        textline "      "
        hexmask.long.byte 0x00 20.--23. 1. " LCDIF_PIX_PODF ,Post divider for LCDIF_PIX."
        textline "      "
        hexmask.long.byte 0x00 23.--26. 1. " ACLK_EIM_SLOW_PODF ,Divider for aclk_eim_slow clock root."
        textline "      "
        hexmask.long.byte 0x00 29.--31. 1. " ACLK_EIM_SLOW_SEL ,Selector for aclk_eim_slow root clock multiplexer"
width 7.
group.long 0x20++0x3
    line.long 0x00 "CSCMR2,CCM Serial Clock Multiplexer Register 2"
        hexmask.long.byte 0x00 19.--21. 1. " EXTERN_AUDIO_CLK_SEL ,Selector for external audio clock multiplexer"
width 7.
group.long 0x24++0x3
    line.long 0x00 "CSCDR1,CCM Serial Clock Divider Register 1"
        hexmask.long.byte 0x00 0.--6. 1. " UART_CLK_PODF ,Divider for uart clock podf."
        textline "      "
        bitfld.long 0x00 6. " UART_CLK_SEL ,Selector for the UART clock multiplexor" "0,1"
        textline "      "
        hexmask.long.byte 0x00 11.--14. 1. " USDHC1_PODF ,Divider for usdhc1 clock podf."
        textline "      "
        hexmask.long.byte 0x00 16.--19. 1. " USDHC2_PODF ,Divider for usdhc2 clock."
        textline "      "
        hexmask.long.byte 0x00 19.--22. 1. " USDHC3_PODF ,Divider for usdhc3 clock podf."
        textline "      "
        hexmask.long.byte 0x00 22.--25. 1. " USDHC4_PODF ,Divider for esdhc4 clock pred."
width 7.
group.long 0x28++0x3
    line.long 0x00 "CS1CDR,CCM SSI1 Clock Divider Register"
        hexmask.long.byte 0x00 0.--6. 1. " SSI1_CLK_PODF ,Divider for ssi1 clock podf."
        textline "      "
        hexmask.long.byte 0x00 6.--9. 1. " SSI1_CLK_PRED ,Divider for ssi1 clock pred."
        textline "      "
        hexmask.long.byte 0x00 9.--12. 1. " EXTERN_AUDIO_CLK_PRED ,Divider for external audio clock pred."
        textline "      "
        hexmask.long.byte 0x00 16.--22. 1. " SSI3_CLK_PODF ,Divider for ssi3 clock podf."
        textline "      "
        hexmask.long.byte 0x00 22.--25. 1. " SSI3_CLK_PRED ,Divider for ssi3 clock pred."
        textline "      "
        hexmask.long.byte 0x00 25.--28. 1. " EXTERN_AUDIO_CLK_PODF ,Divider for external audio clock podf."
width 7.
group.long 0x2c++0x3
    line.long 0x00 "CS2CDR,CCM SSI2 Clock Divider Register"
        hexmask.long.byte 0x00 0.--6. 1. " SSI2_CLK_PODF ,Divider for ssi2 clock podf."
        textline "      "
        hexmask.long.byte 0x00 6.--9. 1. " SSI2_CLK_PRED ,Divider for ssi2 clock pred."
        textline "      "
        hexmask.long.byte 0x00 9.--12. 1. " LDB_DI0_CLK_SEL ,Selector for ldb_di1 clock multiplexer"
        textline "      "
        hexmask.long.byte 0x00 12.--15. 1. " LDB_DI1_CLK_SEL ,Selector for ldb_di1 clock multiplexer"
width 6.
group.long 0x30++0x3
    line.long 0x00 "CDCDR,CCM D1 Clock Divider Register"
        hexmask.long.byte 0x00 7.--9. 1. " SPDIF1_CLK_SEL ,Selector for spdif1 clock multiplexer"
        textline "     "
        hexmask.long.byte 0x00 9.--12. 1. " SPDIF1_CLK_PODF ,Divider for spdif1 clock podf."
        textline "     "
        hexmask.long.byte 0x00 12.--15. 1. " SPDIF1_CLK_PRED ,Divider for spdif1 clock pred."
        textline "     "
        hexmask.long.byte 0x00 20.--22. 1. " SPDIF0_CLK_SEL ,Selector for spdif0 clock multiplexer"
        textline "     "
        hexmask.long.byte 0x00 22.--25. 1. " SPDIF0_CLK_PODF ,Divider for spdif0 clock podf."
        textline "     "
        hexmask.long.byte 0x00 25.--28. 1. " SPDIF0_CLK_PRED ,Divider for spdif0 clock pred."
width 8.
group.long 0x34++0x3
    line.long 0x00 "CHSCCDR,CCM HSC Clock Divider Register"
        hexmask.long.byte 0x00 3.--6. 1. " PXP_AXI_PODF ,Divider for pxp_axi clock divider."
        textline "       "
        hexmask.long.byte 0x00 6.--9. 1. " PXP_AXI_CLK_SEL ,Selector for pxp_axi root clock multiplexer"
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " EPDC_AXI_PODF ,Divider for epdc_axi (SiPix) clock divider."
        textline "       "
        hexmask.long.byte 0x00 15.--18. 1. " EPDC_AXI_CLK_SEL ,Selector for epdc_axi (SiPix) root clock multiplexer"
width 7.
group.long 0x38++0x3
    line.long 0x00 "CSCDR2,CCM Serial Clock Divider Register 2"
        hexmask.long.byte 0x00 3.--6. 1. " LCDIF_PIX_PRED ,Divider for lcdif_pix clock divider."
        textline "      "
        hexmask.long.byte 0x00 6.--9. 1. " LCDIF_PIX_CLK_SEL ,Selector for lcdif_pix root clock multiplexer"
        textline "      "
        hexmask.long.byte 0x00 12.--15. 1. " EPDC_PIX_PRED ,Divider for epdc_pix clock divider."
        textline "      "
        hexmask.long.byte 0x00 15.--18. 1. " EPDC_PIX_CLK_SEL ,Selector for epdc_pix root clock pre-multiplexer"
        textline "      "
        bitfld.long 0x00 18. " ECSPI_CLK_SEL ,Selector for the ECSPI clock multiplexor" "0,1"
        textline "      "
        hexmask.long.byte 0x00 19.--25. 1. " ECSPI_CLK_PODF ,Divider for ecspi clock podf."
width 7.
group.long 0x3c++0x3
    line.long 0x00 "CSCDR3,CCM Serial Clock Divider Register 3"
        hexmask.long.byte 0x00 9.--11. 1. " CSI_CORE_CLK_SEL ,Selector for csi_core clock multiplexer"
        textline "      "
        hexmask.long.byte 0x00 11.--14. 1. " CSI_CORE_PODF ,Post divider for csi_core clock."
        textline "      "
        hexmask.long.byte 0x00 14.--16. 1. " LCDIF_AXI_CLK_SEL ,Selector for lcdif_axi clock multiplexer"
        textline "      "
        hexmask.long.byte 0x00 16.--19. 1. " LCDIF_AXI_PODF ,Divider for lcdif_axi clock."
width 5.
group.long 0x44++0x3
    line.long 0x00 "CWDR,CCM Wakeup Detector Register"
width 7.
rgroup.long 0x48++0x3
    line.long 0x00 "CDHIPR,CCM Divider Handshake In-Process Register"
        bitfld.long 0x00 0. " AXI_PODF_BUSY ,Busy indicator for axi_podf." "0,1"
        textline "      "
        bitfld.long 0x00 1. " AHB_PODF_BUSY ,Busy indicator for ahb_podf." "0,1"
        textline "      "
        bitfld.long 0x00 2. " MMDC_ROOT_PODF_BUSY ,Busy indicator for mmdc_root_axi_podf." "0,1"
        textline "      "
        bitfld.long 0x00 3. " PERIPH2_CLK_SEL_BUSY ,Busy indicator for periph2_clk_sel mux control." "0,1"
        textline "      "
        bitfld.long 0x00 4. " MMDC_CH0_PODF_BUSY ,Busy indicator for mmdc_ch0_axi_podf." "0,1"
        textline "      "
        bitfld.long 0x00 5. " PERIPH_CLK_SEL_BUSY ,Busy indicator for periph_clk_sel mux control." "0,1"
        textline "      "
        bitfld.long 0x00 16. " ARM_PODF_BUSY ,Busy indicator for arm_podf." "0,1"
width 5.
group.long 0x50++0x3
    line.long 0x00 "CTOR,CCM Testing Observability Register"
        hexmask.long.byte 0x00 0.--4. 1. " OBS_SPARE_OUTPUT_2_SEL ,Selection of the signal to be generated on obs_output_2 (output of CCM) for observability on the pads."
        textline "    "
        hexmask.long.byte 0x00 4.--8. 1. " OBS_SPARE_OUTPUT_1_SEL ,Selection of the signal to be generated on obs_output_1 (output of CCM) for observability on the pads."
        textline "    "
        hexmask.long.byte 0x00 8.--13. 1. " OBS_SPARE_OUTPUT_0_SEL ,Selection of the signal to be generated on obs_output_0 (output of CCM) for observability on the pads."
        textline "    "
        bitfld.long 0x00 13. " OBS_EN ,observability enable bit." "0,1"
width 6.
group.long 0x54++0x3
    line.long 0x00 "CLPCR,CCM Low Power Control Register"
        hexmask.long.byte 0x00 0.--2. 1. " LPM ,Setting the low power mode that system will enter on next assertion of dsm_request signal."
        textline "     "
        bitfld.long 0x00 2. " BYPASS_PMIC_VFUNCTIONAL_READY ,By asserting this bit CCM will bypass waiting for pmic_vfunctional_ready signal when coming out of STOP mode." "0,1"
        textline "     "
        bitfld.long 0x00 5. " ARM_CLK_DIS_ON_LPM ,Define if ARM clocks (arm_clk, soc_mxclk, soc_pclk, soc_dbg_pclk, vl_wrck) will be disabled on wait mode." "0,1"
        textline "     "
        bitfld.long 0x00 6. " SBYOS ,Standby clock oscillator bit." "0,1"
        textline "     "
        bitfld.long 0x00 7. " DIS_REF_OSC ,dis_ref_osc - in run mode, software can manually control closing of external reference oscillator clock, i.e." "0,1"
        textline "     "
        bitfld.long 0x00 8. " VSTBY ,Voltage standby request bit." "0,1"
        textline "     "
        hexmask.long.byte 0x00 9.--11. 1. " STBY_COUNT ,Standby counter definition."
        textline "     "
        bitfld.long 0x00 11. " COSC_PWRDOWN ,In run mode, software can manually control powering down of on chip oscillator, i.e." "0,1"
        textline "     "
        bitfld.long 0x00 16. " WB_PER_AT_LPM ,Enable periphery charge pump for well biasing at low power mode (stop or wait)" "0,1"
        textline "     "
        bitfld.long 0x00 19. " BYPASS_MMDC_CH0_LPM_HS ,Bypass handshake with mmdc_ch0 on next entrance to low power mode (wait or stop mode)." "0,1"
        textline "     "
        bitfld.long 0x00 21. " BYPASS_MMDC_ROOT_LPM_HS ,Bypass handshake with mmdc_root on next entrance to low power mode (wait or stop mode)." "0,1"
        textline "     "
        bitfld.long 0x00 22. " MASK_CORE0_WFI ,Mask WFI of core0 for entering low power mode Note: assertion of all bits[27:22] will generate low power mode request" "0,1"
        textline "     "
        bitfld.long 0x00 26. " MASK_SCU_IDLE ,Mask SCU IDLE for entering low power mode Note: assertion of all bits[27:22] will generate low power mode request" "0,1"
        textline "     "
        bitfld.long 0x00 27. " MASK_L2CC_IDLE ,Mask L2CC IDLE for entering low power mode." "0,1"
width 5.
group.long 0x58++0x3
    line.long 0x00 "CISR,CCM Interrupt Status Register"
        bitfld.long 0x00 0. " LRF_PLL ,Interrupt ipi_int_2 generated due to lock of all enabled and not bypaseed pll's" "0,1"
        textline "    "
        bitfld.long 0x00 6. " COSC_READY ,Interrupt ipi_int_2 generated due to on board oscillator ready, i.e." "0,1"
        textline "    "
        bitfld.long 0x00 17. " AXI_PODF_LOADED ,Interrupt ipi_int_1 generated due to frequency change of axi_a_podf" "0,1"
        textline "    "
        bitfld.long 0x00 18. " AXI_B_PODF_LOADED ,Interrupt ipi_int_1 generated due to frequency change of axi_b_podf" "0,1"
        textline "    "
        bitfld.long 0x00 19. " PERIPH2_CLK_SEL_LOADED ,Interrupt ipi_int_1 generated due to frequency change of periph2_clk_sel" "0,1"
        textline "    "
        bitfld.long 0x00 20. " AHB_PODF_LOADED ,Interrupt ipi_int_1 generated due to frequency change of ahb_podf" "0,1"
        textline "    "
        bitfld.long 0x00 21. " MMDC_ROOT_PODF_LOADED ,Interrupt ipi_int_1 generated due to frequency change of mmdc_ch0_podf_ loaded" "0,1"
        textline "    "
        bitfld.long 0x00 22. " PERIPH_CLK_SEL_LOADED ,Interrupt ipi_int_1 generated due to update of periph_clk_sel." "0,1"
        textline "    "
        bitfld.long 0x00 23. " MMDC_CH0_PODF_LOADED ,Interrupt ipi_int_1 generated due to update of mmdc_ch0_axi_podf." "0,1"
        textline "    "
        bitfld.long 0x00 26. " ARM_PODF_LOADED ,Interrupt ipi_int_1 generated due to frequency change of arm_podf." "0,1"
width 5.
group.long 0x5c++0x3
    line.long 0x00 "CIMR,CCM Interrupt Mask Register"
        bitfld.long 0x00 0. " MASK_LRF_PLL ,mask interrupt generation due to lrf of pll's" "0,1"
        textline "    "
        bitfld.long 0x00 6. " MASK_COSC_READY ,mask interrupt generation due to on board oscillator ready" "0,1"
        textline "    "
        bitfld.long 0x00 17. " MASK_AXI_PODF_LOADED ,mask interrupt generation due to frequency change of axi_podf" "0,1"
        textline "    "
        bitfld.long 0x00 18. " MASK_AXI_B_PODF_LOADED ,mask interrupt generation due to frequency change of axi_b_podf" "0,1"
        textline "    "
        bitfld.long 0x00 19. " MASK_PERIPH2_CLK_SEL_LOADED ,mask interrupt generation due to update of periph2_clk_sel." "0,1"
        textline "    "
        bitfld.long 0x00 20. " MASK_AHB_PODF_LOADED ,mask interrupt generation due to frequency change of ahb_podf" "0,1"
        textline "    "
        bitfld.long 0x00 21. " MASK_MMDC_ROOT_PODF_LOADED ,mask interrupt generation due to update of mask_mmdc_root_podf" "0,1"
        textline "    "
        bitfld.long 0x00 22. " MASK_PERIPH_CLK_SEL_LOADED ,mask interrupt generation due to update of periph_clk_sel." "0,1"
        textline "    "
        bitfld.long 0x00 23. " MASK_MMDC_CH0_PODF_LOADED ,mask interrupt generation due to update of mask_mmdc_ch0_podf" "0,1"
        textline "    "
        bitfld.long 0x00 26. " ARM_PODF_LOADED ,mask interrupt generation due to frequency change of arm_podf" "0,1"
width 6.
group.long 0x60++0x3
    line.long 0x00 "CCOSR,CCM Clock Output Source Register"
        hexmask.long.byte 0x00 0.--4. 1. " CLKO_SEL ,Selection of the clock to be generated on CCM_CLKO1"
        textline "     "
        hexmask.long.byte 0x00 4.--7. 1. " CLKO1_DIV ,Setting the divider of CCM_CLKO1"
        textline "     "
        bitfld.long 0x00 7. " CLKO1_EN ,Enable of CCM_CLKO1 clock" "0,1"
        textline "     "
        bitfld.long 0x00 8. " CLKO_SEL1 ,CCM_CLKO1 output to reflect CCM_CLKO1 or CCM_CLKO2 clocks" "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--21. 1. " CLKO2_SEL ,Selection of the clock to be generated on CCM_CLKO2"
        textline "     "
        hexmask.long.byte 0x00 21.--24. 1. " CLKO2_DIV ,Setting the divider of CCM_CLKO2"
        textline "     "
        bitfld.long 0x00 24. " CLKO2_EN ,Enable of CCM_CLKO2 clock" "0,1"
width 5.
group.long 0x64++0x3
    line.long 0x00 "CGPR,CCM General Purpose Register"
        bitfld.long 0x00 0. " PMIC_DELAY_SCALER ,Defines clock dividion of clock for stby_count (pmic delay counter)" "0,1"
        textline "    "
        bitfld.long 0x00 1. " MEM_IGP_STOP_MASK ,Clear this bit to disallow putting the ARM cache into low power mode." "0,1"
        textline "    "
        bitfld.long 0x00 2. " MMDC_EXT_CLK_DIS ,Disable external clock driver of MMDC during STOP mode" "0,1"
        textline "    "
        bitfld.long 0x00 4. " EFUSE_PROG_SUPPLY_GATE ,Defines the value of the output signal cgpr_dout[4]." "0,1"
        textline "    "
        bitfld.long 0x00 16. " FPL ," "0,1"
width 6.
group.long 0x68++0x3
    line.long 0x00 "CCGR0,CCM Clock Gating Register 0"
        hexmask.long.byte 0x00 0.--2. 1. " CG0 ,aips_tz1 clocks (aips_tz1_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 2.--4. 1. " CG1 ,aips_tz2 clocks (aips_tz2_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 4.--6. 1. " CG2 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 6.--8. 1. " CG3 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 8.--10. 1. " CG4 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 10.--12. 1. " CG5 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 12.--14. 1. " CG6 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 14.--16. 1. " CG7 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " CG8 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 18.--20. 1. " CG9 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 20.--22. 1. " CG10 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 22.--24. 1. " CG11 ,CPU debug clocks (arm_dbg_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 24.--26. 1. " CG12 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 26.--28. 1. " CG13 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 28.--30. 1. " CG14 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " CG15 ,Reserved"
width 6.
group.long 0x6c++0x3
    line.long 0x00 "CCGR1,CCM Clock Gating Register 1"
        hexmask.long.byte 0x00 0.--2. 1. " CG0 ,ecspi1 clocks (ecspi1_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 2.--4. 1. " CG1 ,ecspi2 clocks (ecspi2_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 4.--6. 1. " CG2 ,ecspi3 clocks (ecspi3_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 6.--8. 1. " CG3 ,ecspi4 clocks (ecspi4_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 8.--10. 1. " CG4 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 10.--12. 1. " CG5 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 12.--14. 1. " CG6 ,epit1 clocks (epit1_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 14.--16. 1. " CG7 ,epit2 clocks (epit2_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " CG8 ,esai clocks (extern_audio_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 18.--20. 1. " CG9 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 20.--22. 1. " CG10 ,gpt bus clock (gpt_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 22.--24. 1. " CG11 ,gpt serial clock (gpt_serial_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 24.--26. 1. " CG12 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 26.--28. 1. " CG13 ,gpu2d ovg clock (gpu2d_ovg_core_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 28.--30. 1. " CG14 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " CG15 ,Reserved"
width 6.
group.long 0x70++0x3
    line.long 0x00 "CCGR2,CCM Clock Gating Register 2"
        hexmask.long.byte 0x00 0.--2. 1. " CG0 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 2.--4. 1. " CG1 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 4.--6. 1. " CG2 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 6.--8. 1. " CG3 ,i2c1_serial clock (i2c1_serial_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 8.--10. 1. " CG4 ,i2c2_serial clock (i2c2_serial_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 10.--12. 1. " CG5 ,i2c3_serial clock (i2c3_serial_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 12.--14. 1. " CG6 ,OCOTP_CTRL clock (iim_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 14.--16. 1. " CG7 ,iomux_ipt_clk_io clock (iomux_ipt_clk_io_enable)"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " CG8 ,ipmux1 clock (ipmux1_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 18.--20. 1. " CG9 ,ipmux2 clock (ipmux2_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 20.--22. 1. " CG10 ,ipmux3 clock (ipmux3_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 22.--24. 1. " CG11 ,ipsync_ip2apb_tzasc1_ipg clocks (ipsync_ip2apb_tzasc1_ipg_master_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 24.--26. 1. " CG12 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 26.--28. 1. " CG13 ,ipsync_vdoa_ipg clocks (ipsync_vdoa_ipg_master_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 28.--30. 1. " CG14 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " CG15 ,Reserved"
width 6.
group.long 0x74++0x3
    line.long 0x00 "CCGR3,CCM Clock Gating Register 3"
        hexmask.long.byte 0x00 0.--2. 1. " CG0 ,csi core clock (csi_core_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 2.--4. 1. " CG1 ,pxp axi clock (pxp_axi_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 4.--6. 1. " CG2 ,epdc axi clock (epdc_axi_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 6.--8. 1. " CG3 ,lcdif axi clock (lcdif_axi_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 8.--10. 1. " CG4 ,ipu2_ipu_di0 clock (ipu2_ipu_di0_clk_enable) lcdif_pix clock (lcdif_pix_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 10.--12. 1. " CG5 ,epdc_pix clock (epdc_pix_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 12.--14. 1. " CG6 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 14.--16. 1. " CG7 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " CG8 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 18.--20. 1. " CG9 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 20.--22. 1. " CG10 ,mmdc_core_aclk_fast_core_p0 clock (mmdc_core_aclk_fast_core_p0_enable)"
        textline "     "
        hexmask.long.byte 0x00 22.--24. 1. " CG11 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 24.--26. 1. " CG12 ,mmdc_core_ipg_clk_p0 clock (mmdc_core_ipg_clk_p0_enable)"
        textline "     "
        hexmask.long.byte 0x00 26.--28. 1. " CG13 ,mmdc_core_ipg_clk_p1 clock (mmdc_core_ipg_clk_p1_enable)"
        textline "     "
        hexmask.long.byte 0x00 28.--30. 1. " CG14 ,ocram clock (ocram_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " CG15 ,Reserved"
width 6.
group.long 0x78++0x3
    line.long 0x00 "CCGR4,CCM Clock Gating Register 4"
        hexmask.long.byte 0x00 0.--2. 1. " CG0 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 2.--4. 1. " CG1 ,Reserved."
        textline "     "
        hexmask.long.byte 0x00 4.--6. 1. " CG2 ,Reserved."
        textline "     "
        hexmask.long.byte 0x00 6.--8. 1. " CG3 ,Reserved."
        textline "     "
        hexmask.long.byte 0x00 8.--10. 1. " CG4 ,pl301_mx6qfast1_s133 clock (pl301_mx6qfast1_s133clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 10.--12. 1. " CG5 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 12.--14. 1. " CG6 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 14.--16. 1. " CG7 ,pl301_mx6qper2_mainclk_enable (pl301_mx6qper2_mainclk_enable)"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " CG8 ,pwm1 clocks (pwm1_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 18.--20. 1. " CG9 ,pwm2 clocks (pwm2_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 20.--22. 1. " CG10 ,pwm3 clocks (pwm3_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 22.--24. 1. " CG11 ,pwm4 clocks (pwm4_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 24.--26. 1. " CG12 ,rawnand_u_bch_input_apb clock (rawnand_u_bch_input_apb_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 26.--28. 1. " CG13 ,rawnand_u_gpmi_bch_input_bch clock (rawnand_u_gpmi_bch_input_bch_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 28.--30. 1. " CG14 ,rawnand_u_gpmi_bch_input_gpmi_io clock (rawnand_u_gpmi_bch_input_gpmi_io_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " CG15 ,rawnand_u_gpmi_input_apb clock rawnand_u_gpmi_input_apb_clk_enable)"
width 6.
group.long 0x7c++0x3
    line.long 0x00 "CCGR5,CCM Clock Gating Register 5"
        hexmask.long.byte 0x00 0.--2. 1. " CG0 ,rom clock (rom_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 2.--4. 1. " CG1 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 4.--6. 1. " CG2 ,100M clock (100M_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 6.--8. 1. " CG3 ,sdma clock (sdma_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 8.--10. 1. " CG4 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 10.--12. 1. " CG5 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 12.--14. 1. " CG6 ,spba clock (spba_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 14.--16. 1. " CG7 ,spdif clock (spdif_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " CG8 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 18.--20. 1. " CG9 ,ssi1 clocks (ssi1_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 20.--22. 1. " CG10 ,ssi2 clocks (ssi2_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 22.--24. 1. " CG11 ,ssi3 clocks (ssi3_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 24.--26. 1. " CG12 ,uart clock (uart_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 26.--28. 1. " CG13 ,uart_serial clock (uart_serial_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 28.--30. 1. " CG14 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " CG15 ,Reserved"
width 6.
group.long 0x80++0x3
    line.long 0x00 "CCGR6,CCM Clock Gating Register 6"
        hexmask.long.byte 0x00 0.--2. 1. " CG0 ,usboh3 clock (usboh3_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 2.--4. 1. " CG1 ,usdhc1 clocks (usdhc1_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 4.--6. 1. " CG2 ,usdhc2 clocks (usdhc2_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 6.--8. 1. " CG3 ,usdhc3 clocks (usdhc3_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 8.--10. 1. " CG4 ,usdhc4 clocks (usdhc4_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 10.--12. 1. " CG5 ,eim_slow clocks (eim_slow_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 12.--14. 1. " CG6 ,vdoaxiclk root clock (vdoaxiclk_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 14.--16. 1. " CG7 ,vpu clocks (vpu_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " CG8 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 18.--20. 1. " CG9 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 20.--22. 1. " CG10 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 22.--24. 1. " CG11 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 24.--26. 1. " CG12 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 26.--28. 1. " CG13 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 28.--30. 1. " CG14 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " CG15 ,Reserved"
width 6.
group.long 0x88++0x3
    line.long 0x00 "CMEOR,CCM Module Enable Overide Register"
        bitfld.long 0x00 5. " MOD_EN_OV_GPT ,overide clock enable signal from gpt - clock will not be gated based on gpt's signal 'ipg_enable_clk' ." "0,1"
        textline "     "
        bitfld.long 0x00 6. " MOD_EN_OV_EPIT ,overide clock enable signal from epit - clock will not be gated based on epit's signal 'ipg_enable_clk' ." "0,1"
        textline "     "
        bitfld.long 0x00 7. " MOD_EN_USDHC ,overide clock enable signal from usdhc." "0,1"
        textline "     "
        bitfld.long 0x00 10. " MOD_EN_OV_GPU2D ,overide clock enable signal from gpu2d - clock will not be gated based on gpu2d's signal 'gpu2d_busy' ." "0,1"


tree.end



;--------------------------------------------------------------------------------
; CCM_ANALOG
;--------------------------------------------------------------------------------
tree "CCM_ANALOG"
    base ad:0x020c8000

width 8.
group.long 0x0++0x3
    line.long 0x00 "PLL_ARM,Analog ARM PLL control Register"
        hexmask.long.byte 0x00 0.--7. 1. " DIV_SELECT ,This field controls the pll loop divider."
        textline "       "
        bitfld.long 0x00 12. " POWERDOWN ,Powers down the PLL." "0,1"
        textline "       "
        bitfld.long 0x00 13. " ENABLE ,Enable the clock output." "0,1"
        textline "       "
        hexmask.long.byte 0x00 14.--16. 1. " BYPASS_CLK_SRC ,Determines the bypass source."
        textline "       "
        bitfld.long 0x00 16. " BYPASS ,Bypass the pll." "0,1"
        textline "       "
        bitfld.long 0x00 17. " LVDS_SEL ,Analog Debug Bit" "0,1"
        textline "       "
        bitfld.long 0x00 18. " LVDS_24MHZ_SEL ,Analog Debug Bit" "0,1"
        textline "       "
        bitfld.long 0x00 19. " PLL_SEL ,Reserved" "0,1"
        textline "       "
        bitfld.long 0x00 31. " LOCK ,1 - PLL is currently locked." "0,1"
width 9.
group.long 0x10++0x3
    line.long 0x00 "PLL_USB1,Analog USB1 480MHz PLL Control Register"
        hexmask.long.byte 0x00 0.--2. 1. " DIV_SELECT ,This field controls the pll loop divider."
        textline "        "
        bitfld.long 0x00 6. " EN_USB_CLKS ,Powers the 9-phase PLL outputs for USBPHYn." "0,1"
        textline "        "
        bitfld.long 0x00 12. " POWER ,Powers up the PLL." "0,1"
        textline "        "
        bitfld.long 0x00 13. " ENABLE ,Enable the PLL clock output." "0,1"
        textline "        "
        hexmask.long.byte 0x00 14.--16. 1. " BYPASS_CLK_SRC ,Determines the bypass source."
        textline "        "
        bitfld.long 0x00 16. " BYPASS ,Bypass the pll." "0,1"
        textline "        "
        bitfld.long 0x00 31. " LOCK ,1 - PLL is currently locked." "0,1"
width 9.
group.long 0x20++0x3
    line.long 0x00 "PLL_USB2,Analog USB2 480MHz PLL Control Register"
        hexmask.long.byte 0x00 0.--2. 1. " DIV_SELECT ,This field controls the pll loop divider."
        textline "        "
        bitfld.long 0x00 6. " EN_USB_CLKS ,0: 8-phase PLL outputs for USBPHY1 are powered down." "0,1"
        textline "        "
        bitfld.long 0x00 12. " POWER ,Powers up the PLL." "0,1"
        textline "        "
        bitfld.long 0x00 13. " ENABLE ,Enable the PLL clock output." "0,1"
        textline "        "
        hexmask.long.byte 0x00 14.--16. 1. " BYPASS_CLK_SRC ,Determines the bypass source."
        textline "        "
        bitfld.long 0x00 16. " BYPASS ,Bypass the pll." "0,1"
        textline "        "
        bitfld.long 0x00 31. " LOCK ,1 - PLL is currently locked." "0,1"
width 8.
group.long 0x30++0x3
    line.long 0x00 "PLL_SYS,Analog System PLL Control Register"
        bitfld.long 0x00 0. " DIV_SELECT ,This field controls the pll loop divider." "0,1"
        textline "       "
        bitfld.long 0x00 12. " POWERDOWN ,Powers down the PLL." "0,1"
        textline "       "
        bitfld.long 0x00 13. " ENABLE ,Enable PLL output" "0,1"
        textline "       "
        hexmask.long.byte 0x00 14.--16. 1. " BYPASS_CLK_SRC ,Determines the bypass source."
        textline "       "
        bitfld.long 0x00 16. " BYPASS ,Bypass the pll." "0,1"
        textline "       "
        bitfld.long 0x00 18. " PFD_OFFSET_EN ,Enables an offset in the phase frequency detector." "0,1"
        textline "       "
        bitfld.long 0x00 31. " LOCK ,1 - PLL is currently locked; 0 - PLL is not currently locked." "0,1"
width 10.
group.long 0x70++0x3
    line.long 0x00 "PLL_AUDIO,Analog Audio PLL control Register"
        hexmask.long.byte 0x00 0.--7. 1. " DIV_SELECT ,This field controls the pll loop divider."
        textline "         "
        bitfld.long 0x00 12. " POWERDOWN ,Powers down the PLL." "0,1"
        textline "         "
        bitfld.long 0x00 13. " ENABLE ,Enable PLL output" "0,1"
        textline "         "
        hexmask.long.byte 0x00 14.--16. 1. " BYPASS_CLK_SRC ,Determines the bypass source."
        textline "         "
        bitfld.long 0x00 16. " BYPASS ,Bypass the pll." "0,1"
        textline "         "
        bitfld.long 0x00 18. " PFD_OFFSET_EN ,Enables an offset in the phase frequency detector." "0,1"
        textline "         "
        hexmask.long.byte 0x00 19.--21. 1. " POST_DIV_SELECT ,These bits implement a divider after the PLL, but before the enable and bypass mux."
        textline "         "
        bitfld.long 0x00 21. " SSC_EN ,Reserved Bit" "0,1"
        textline "         "
        bitfld.long 0x00 31. " LOCK ,1 - PLL is currently locked." "0,1"
width 14.
group.long 0x80++0x3
    line.long 0x00 "PLL_AUDIO_NUM,Numerator of Audio PLL Fractional Loop Divider Register"
        hexmask.long.long 0x00 0.--30. 1. " A ,30 bit numerator of fractional loop divider."
width 16.
group.long 0x90++0x3
    line.long 0x00 "PLL_AUDIO_DENOM,Denominator of Audio PLL Fractional Loop Divider Register"
        hexmask.long.long 0x00 0.--30. 1. " B ,30 bit Denominator of fractional loop divider."
width 10.
group.long 0xa0++0x3
    line.long 0x00 "PLL_VIDEO,Analog Video PLL control Register"
        hexmask.long.byte 0x00 0.--7. 1. " DIV_SELECT ,This field controls the pll loop divider."
        textline "         "
        bitfld.long 0x00 12. " POWERDOWN ,Powers down the PLL." "0,1"
        textline "         "
        bitfld.long 0x00 13. " ENABLE ,Enalbe PLL output" "0,1"
        textline "         "
        hexmask.long.byte 0x00 14.--16. 1. " BYPASS_CLK_SRC ,Determines the bypass source."
        textline "         "
        bitfld.long 0x00 16. " BYPASS ,Bypass the pll." "0,1"
        textline "         "
        bitfld.long 0x00 18. " PFD_OFFSET_EN ,Enables an offset in the phase frequency detector." "0,1"
        textline "         "
        hexmask.long.byte 0x00 19.--21. 1. " POST_DIV_SELECT ,These bits implement a divider after the PLL, but before the enable and bypass mux."
        textline "         "
        bitfld.long 0x00 21. " SSC_EN ,Revserved BIt" "0,1"
        textline "         "
        bitfld.long 0x00 31. " LOCK ,1 - PLL is currently locked; 0 - PLL is not currently locked." "0,1"
width 14.
group.long 0xb0++0x3
    line.long 0x00 "PLL_VIDEO_NUM,Numerator of Video PLL Fractional Loop Divider Register"
        hexmask.long.long 0x00 0.--30. 1. " A ,30 bit numerator of fractional loop divider(Signed number), absolute value should be less than denominator"
width 16.
group.long 0xc0++0x3
    line.long 0x00 "PLL_VIDEO_DENOM,Denominator of Video PLL Fractional Loop Divider Register"
        hexmask.long.long 0x00 0.--30. 1. " B ,30 bit Denominator of fractional loop divider."
width 9.
group.long 0xe0++0x3
    line.long 0x00 "PLL_ENET,Analog ENET PLL Control Register"
        hexmask.long.byte 0x00 0.--2. 1. " DIV_SELECT ,Controls the frequency of the ethernet reference clock.00 - 25MHz; 01 - 50MHz; 10 - 100MHz (not 50% duty cycle); 11 - 125MHz;"
        textline "        "
        bitfld.long 0x00 12. " POWERDOWN ,Powers down the PLL." "0,1"
        textline "        "
        bitfld.long 0x00 13. " ENABLE ,Enable the ethernet clock output." "0,1"
        textline "        "
        hexmask.long.byte 0x00 14.--16. 1. " BYPASS_CLK_SRC ,Determines the bypass source."
        textline "        "
        bitfld.long 0x00 16. " BYPASS ,Bypass the pll." "0,1"
        textline "        "
        bitfld.long 0x00 18. " PFD_OFFSET_EN ,Enables an offset in the phase frequency detector." "0,1"
        textline "        "
        bitfld.long 0x00 19. " ENABLE_125M ,Enables an offset in the phase frequency detector." "0,1"
        textline "        "
        bitfld.long 0x00 20. " ENABLE_100M ,Enables an offset in the phase frequency detector." "0,1"
        textline "        "
        bitfld.long 0x00 31. " LOCK ,1 - PLL is currently locked; 0 - PLL is not currently locked." "0,1"
width 8.
group.long 0xf0++0x3
    line.long 0x00 "PFD_480,480MHz Clock (from PLL_USB2) Phase Fractional Divider Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " PFD0_FRAC ,This field controls the fractional divide value."
        textline "       "
        bitfld.long 0x00 6. " PFD0_STABLE ,This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code." "0,1"
        textline "       "
        bitfld.long 0x00 7. " PFD0_CLKGATE ,If set to 1, the IO fractional divider clock (reference ref_pfd0) is off (power savings)." "0,1"
        textline "       "
        hexmask.long.byte 0x00 8.--14. 1. " PFD1_FRAC ,This field controls the fractional divide value."
        textline "       "
        bitfld.long 0x00 14. " PFD1_STABLE ,This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code." "0,1"
        textline "       "
        bitfld.long 0x00 15. " PFD1_CLKGATE ,IO Clock Gate." "0,1"
        textline "       "
        hexmask.long.byte 0x00 16.--22. 1. " PFD2_FRAC ,This field controls the fractional divide value."
        textline "       "
        bitfld.long 0x00 22. " PFD2_STABLE ,This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code." "0,1"
        textline "       "
        bitfld.long 0x00 23. " PFD2_CLKGATE ,IO Clock Gate." "0,1"
        textline "       "
        hexmask.long.byte 0x00 24.--30. 1. " PFD3_FRAC ,This field controls the fractional divide value."
        textline "       "
        bitfld.long 0x00 30. " PFD3_STABLE ,This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code." "0,1"
        textline "       "
        bitfld.long 0x00 31. " PFD3_CLKGATE ,IO Clock Gate." "0,1"
width 8.
group.long 0x100++0x3
    line.long 0x00 "PFD_528,528MHz Clock (From PLL_SYS) Phase Fractional Divider Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " PFD0_FRAC ,This field controls the fractional divide value."
        textline "       "
        bitfld.long 0x00 6. " PFD0_STABLE ,This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code." "0,1"
        textline "       "
        bitfld.long 0x00 7. " PFD0_CLKGATE ,If set to 1, the IO fractional divider clock (reference ref_pfd0) is off (power savings)." "0,1"
        textline "       "
        hexmask.long.byte 0x00 8.--14. 1. " PFD1_FRAC ,This field controls the fractional divide value."
        textline "       "
        bitfld.long 0x00 14. " PFD1_STABLE ,This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code." "0,1"
        textline "       "
        bitfld.long 0x00 15. " PFD1_CLKGATE ,IO Clock Gate." "0,1"
        textline "       "
        hexmask.long.byte 0x00 16.--22. 1. " PFD2_FRAC ,This field controls the fractional divide value."
        textline "       "
        bitfld.long 0x00 22. " PFD2_STABLE ,This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code." "0,1"
        textline "       "
        bitfld.long 0x00 23. " PFD2_CLKGATE ,IO Clock Gate." "0,1"
        textline "       "
        hexmask.long.byte 0x00 24.--30. 1. " PFD3_FRAC ,This field controls the fractional divide value."
        textline "       "
        bitfld.long 0x00 30. " PFD3_STABLE ,This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code." "0,1"
        textline "       "
        bitfld.long 0x00 31. " PFD3_CLKGATE ,IO Clock Gate." "0,1"
width 6.
group.long 0x150++0x3
    line.long 0x00 "MISC0,Miscellaneous Control Register"
        hexmask.long.byte 0x00 11.--13. 1. " STOP_MODE_CONFIG ,Configure the analog behavior in stop mode."
width 6.
group.long 0x170++0x3
    line.long 0x00 "MISC2,Miscellaneous Control Register"
        bitfld.long 0x00 7. " PLL3_DISABLE ,Default value of ""0""." "0,1"
        textline "     "
        bitfld.long 0x00 15. " AUDIO_DIV_LSB ,LSB of Post-divider for Audio PLL." "0,1"
        textline "     "
        bitfld.long 0x00 23. " AUDIO_DIV_MSB ,MSB of Post-divider for Audio PLL." "0,1"
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " VIDEO_DIV ,Post-divider for video."


tree.end



;--------------------------------------------------------------------------------
; CSI
;--------------------------------------------------------------------------------
tree "CSI"
    base ad:0x020e4000

width 7.
group.long 0x0++0x3
    line.long 0x00 "CSICR1,CSI Control Register 1"
        bitfld.long 0x00 0. " PIXEL_BIT ,Pixel Bit." "0,1"
        textline "      "
        bitfld.long 0x00 1. " REDGE ,Valid Pixel Clock Edge Select." "0,1"
        textline "      "
        bitfld.long 0x00 2. " INV_PCLK ,Invert Pixel Clock Input." "0,1"
        textline "      "
        bitfld.long 0x00 3. " INV_DATA ,Invert Data Input." "0,1"
        textline "      "
        bitfld.long 0x00 4. " GCLK_MODE ,Gated Clock Mode Enable." "0,1"
        textline "      "
        bitfld.long 0x00 5. " CLR_RXFIFO ,Asynchronous RXFIFO Clear." "0,1"
        textline "      "
        bitfld.long 0x00 6. " CLR_STATFIFO ,Asynchronous STATFIFO Clear." "0,1"
        textline "      "
        bitfld.long 0x00 7. " PACK_DIR ,Data Packing Direction." "0,1"
        textline "      "
        bitfld.long 0x00 8. " FCC ,FIFO Clear Control." "0,1"
        textline "      "
        bitfld.long 0x00 10. " CCIR_EN ,CCIR656 Interface Enable." "0,1"
        textline "      "
        bitfld.long 0x00 11. " HSYNC_POL ,HSYNC Polarity Select." "0,1"
        textline "      "
        bitfld.long 0x00 16. " SOF_INTEN ,Start Of Frame (SOF) Interrupt Enable." "0,1"
        textline "      "
        bitfld.long 0x00 17. " SOF_POL ,SOF Interrupt Polarity." "0,1"
        textline "      "
        bitfld.long 0x00 18. " RXFF_INTEN ,RxFIFO Full Interrupt Enable." "0,1"
        textline "      "
        bitfld.long 0x00 19. " FB1_DMA_DONE_INTEN ,Frame Buffer1 DMA Transfer Done Interrupt Enable." "0,1"
        textline "      "
        bitfld.long 0x00 20. " FB2_DMA_DONE_INTEN ,Frame Buffer2 DMA Transfer Done Interrupt Enable." "0,1"
        textline "      "
        bitfld.long 0x00 21. " STATFF_INTEN ,STATFIFO Full Interrupt Enable." "0,1"
        textline "      "
        bitfld.long 0x00 22. " SFF_DMA_DONE_INTEN ,STATFIFO DMA Transfer Done Interrupt Enable." "0,1"
        textline "      "
        bitfld.long 0x00 24. " RF_OR_INTEN ,RxFIFO Overrun Interrupt Enable." "0,1"
        textline "      "
        bitfld.long 0x00 25. " SF_OR_INTEN ,STAT FIFO Overrun Interrupt Enable." "0,1"
        textline "      "
        bitfld.long 0x00 26. " COF_INT_EN ,Change Of Image Field (COF) Interrupt Enable." "0,1"
        textline "      "
        bitfld.long 0x00 27. " CCIR_MODE ,CCIR Mode Select." "0,1"
        textline "      "
        bitfld.long 0x00 28. " PRP_IF_EN ,CSI-PrP Interface Enable." "0,1"
        textline "      "
        bitfld.long 0x00 29. " EOF_INT_EN ,End-of-Frame Interrupt Enable." "0,1"
        textline "      "
        bitfld.long 0x00 30. " EXT_VSYNC ,External VSYNC Enable." "0,1"
        textline "      "
        bitfld.long 0x00 31. " SWAP16_EN ,SWAP 16-Bit Enable." "0,1"
width 7.
group.long 0x4++0x3
    line.long 0x00 "CSICR2,CSI Control Register 2"
        hexmask.long.byte 0x00 0.--8. 1. " HSC ,Horizontal Skip Count."
        textline "      "
        hexmask.long.byte 0x00 8.--16. 1. " VSC ,Vertical Skip Count."
        textline "      "
        hexmask.long.byte 0x00 16.--19. 1. " LVRM ,Live View Resolution Mode."
        textline "      "
        hexmask.long.byte 0x00 19.--21. 1. " BTS ,Bayer Tile Start."
        textline "      "
        bitfld.long 0x00 23. " SCE ,Skip Count Enable." "0,1"
        textline "      "
        hexmask.long.byte 0x00 24.--26. 1. " AFS ,Auto Focus Spread."
        textline "      "
        bitfld.long 0x00 26. " DRM ,Double Resolution Mode." "0,1"
        textline "      "
        hexmask.long.byte 0x00 28.--30. 1. " DMA_BURST_TYPE_SFF ,Burst Type of DMA Transfer from STATFIFO."
        textline "      "
        hexmask.long.byte 0x00 30.--32. 1. " DMA_BURST_TYPE_RFF ,Burst Type of DMA Transfer from RxFIFO."
width 7.
group.long 0x8++0x3
    line.long 0x00 "CSICR3,CSI Control Register 3"
        bitfld.long 0x00 0. " ECC_AUTO_EN ,Automatic Error Correction Enable." "0,1"
        textline "      "
        bitfld.long 0x00 1. " ECC_INT_EN ,Error Detection Interrupt Enable." "0,1"
        textline "      "
        bitfld.long 0x00 2. " ZERO_PACK_EN ,Dummy Zero Packing Enable." "0,1"
        textline "      "
        bitfld.long 0x00 3. " TWO_8BIT_SENSOR ,Two 8-bit Sensor Mode." "0,1"
        textline "      "
        hexmask.long.byte 0x00 4.--7. 1. " RXFF_LEVEL ,RxFIFO Full Level ."
        textline "      "
        bitfld.long 0x00 7. " HRESP_ERR_EN ,Hresponse Error Enable." "0,1"
        textline "      "
        hexmask.long.byte 0x00 8.--11. 1. " STATFF_LEVEL ,STATFIFO Full Level."
        textline "      "
        bitfld.long 0x00 11. " DMA_REQ_EN_SFF ,DMA Request Enable for STATFIFO." "0,1"
        textline "      "
        bitfld.long 0x00 12. " DMA_REQ_EN_RFF ,DMA Request Enable for RxFIFO." "0,1"
        textline "      "
        bitfld.long 0x00 13. " DMA_REFLASH_SFF ,Reflash DMA Controller for STATFIFO." "0,1"
        textline "      "
        bitfld.long 0x00 14. " DMA_REFLASH_RFF ,Reflash DMA Controller for RxFIFO." "0,1"
        textline "      "
        bitfld.long 0x00 15. " FRMCNT_RST ,Frame Count Reset." "0,1"
        textline "      "
        hexmask.long.word 0x00 16.--32. 1. " FRMCNT ,Frame Counter."
width 12.
rgroup.long 0xc++0x3
    line.long 0x00 "CSISTATFIFO,CSI Statistic FIFO Register"
        hexmask.long.long 0x00 0.--32. 1. " STAT ,Static data from sensor"
width 9.
rgroup.long 0x10++0x3
    line.long 0x00 "CSIRFIFO,CSI RX FIFO Register"
        hexmask.long.long 0x00 0.--32. 1. " IMAGE ,Received image data"
width 9.
group.long 0x14++0x3
    line.long 0x00 "CSIRXCNT,CSI RX Count Register"
        hexmask.long.long 0x00 0.--22. 1. " RXCNT ,RxFIFO Count."
width 6.
group.long 0x18++0x3
    line.long 0x00 "CSISR,CSI Status Register"
        bitfld.long 0x00 0. " DRDY ,RXFIFO Data Ready." "0,1"
        textline "     "
        bitfld.long 0x00 1. " ECC_INT ,CCIR Error Interrupt." "0,1"
        textline "     "
        bitfld.long 0x00 7. " HRESP_ERR_INT ,Hresponse Error Interrupt Status." "0,1"
        textline "     "
        bitfld.long 0x00 13. " COF_INT ,Change Of Field Interrupt Status." "0,1"
        textline "     "
        bitfld.long 0x00 14. " F1_INT ,CCIR Field 1 Interrupt Status." "0,1"
        textline "     "
        bitfld.long 0x00 15. " F2_INT ,CCIR Field 2 Interrupt Status." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SOF_INT ,Start of Frame Interrupt Status." "0,1"
        textline "     "
        bitfld.long 0x00 17. " EOF_INT ,End of Frame (EOF) Interrupt Status." "0,1"
        textline "     "
        bitfld.long 0x00 18. " RXFF_INT ,RXFIFO Full Interrupt Status." "0,1"
        textline "     "
        bitfld.long 0x00 19. " DMA_TSF_DONE_FB1 ,DMA Transfer Done in Frame Buffer1." "0,1"
        textline "     "
        bitfld.long 0x00 20. " DMA_TSF_DONE_FB2 ,DMA Transfer Done in Frame Buffer2." "0,1"
        textline "     "
        bitfld.long 0x00 21. " STATFF_INT ,STATFIFO Full Interrupt Status." "0,1"
        textline "     "
        bitfld.long 0x00 22. " DMA_TSF_DONE_SFF ,DMA Transfer Done from StatFIFO." "0,1"
        textline "     "
        bitfld.long 0x00 24. " RF_OR_INT ,RxFIFO Overrun Interrupt Status." "0,1"
        textline "     "
        bitfld.long 0x00 25. " SF_OR_INT ,STATFIFO Overrun Interrupt Status." "0,1"
width 18.
group.long 0x20++0x3
    line.long 0x00 "CSIDMASA_STATFIFO,CSI DMA Start Address Register - for STATFIFO"
        hexmask.long.long 0x00 2.--32. 1. " DMA_START_ADDR_SFF ,DMA Start Address for STATFIFO."
width 18.
group.long 0x24++0x3
    line.long 0x00 "CSIDMATS_STATFIFO,CSI DMA Transfer Size Register - for STATFIFO"
        hexmask.long.long 0x00 0.--32. 1. " DMA_TSF_SIZE_SFF ,DMA Transfer Size for STATFIFO."
width 13.
group.long 0x28++0x3
    line.long 0x00 "CSIDMASA_FB1,CSI DMA Start Address Register - for Frame Buffer1"
        hexmask.long.long 0x00 2.--32. 1. " DMA_START_ADDR_FB1 ,DMA Start Address in Frame Buffer1."
width 13.
group.long 0x2c++0x3
    line.long 0x00 "CSIDMASA_FB2,CSI DMA Transfer Size Register - for Frame Buffer2"
        hexmask.long.long 0x00 2.--32. 1. " DMA_START_ADDR_FB2 ,DMA Start Address in Frame Buffer2."
width 13.
group.long 0x30++0x3
    line.long 0x00 "CSIFBUF_PARA,CSI Frame Buffer Parameter Register"
        hexmask.long.word 0x00 0.--16. 1. " FBUF_STRIDE ,Frame Buffer Parameter."
width 13.
group.long 0x34++0x3
    line.long 0x00 "CSIIMAG_PARA,CSI Image Parameter Register"
        hexmask.long.word 0x00 0.--16. 1. " IMAGE_HEIGHT ,Image Height."
        textline "            "
        hexmask.long.word 0x00 16.--32. 1. " IMAGE_WIDTH ,Image Width."


tree.end



;--------------------------------------------------------------------------------
; CSU
;--------------------------------------------------------------------------------
tree "CSU"
    base ad:0x021c0000

width 5.
group.long 0x0++0x3
    line.long 0x00 "CSL0,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "    "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 5.
group.long 0x4++0x3
    line.long 0x00 "CSL1,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "    "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 5.
group.long 0x8++0x3
    line.long 0x00 "CSL2,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "    "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 5.
group.long 0xc++0x3
    line.long 0x00 "CSL3,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "    "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 5.
group.long 0x10++0x3
    line.long 0x00 "CSL4,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "    "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 5.
group.long 0x14++0x3
    line.long 0x00 "CSL5,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "    "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 5.
group.long 0x18++0x3
    line.long 0x00 "CSL6,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "    "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 5.
group.long 0x1c++0x3
    line.long 0x00 "CSL7,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "    "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 5.
group.long 0x20++0x3
    line.long 0x00 "CSL8,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "    "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 5.
group.long 0x24++0x3
    line.long 0x00 "CSL9,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "    "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x28++0x3
    line.long 0x00 "CSL10,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x2c++0x3
    line.long 0x00 "CSL11,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x30++0x3
    line.long 0x00 "CSL12,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x34++0x3
    line.long 0x00 "CSL13,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x38++0x3
    line.long 0x00 "CSL14,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x3c++0x3
    line.long 0x00 "CSL15,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x40++0x3
    line.long 0x00 "CSL16,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x44++0x3
    line.long 0x00 "CSL17,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x48++0x3
    line.long 0x00 "CSL18,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x4c++0x3
    line.long 0x00 "CSL19,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x50++0x3
    line.long 0x00 "CSL20,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x54++0x3
    line.long 0x00 "CSL21,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x58++0x3
    line.long 0x00 "CSL22,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x5c++0x3
    line.long 0x00 "CSL23,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x60++0x3
    line.long 0x00 "CSL24,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x64++0x3
    line.long 0x00 "CSL25,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x68++0x3
    line.long 0x00 "CSL26,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x6c++0x3
    line.long 0x00 "CSL27,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x70++0x3
    line.long 0x00 "CSL28,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x74++0x3
    line.long 0x00 "CSL29,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x78++0x3
    line.long 0x00 "CSL30,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x7c++0x3
    line.long 0x00 "CSL31,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x80++0x3
    line.long 0x00 "CSL32,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x84++0x3
    line.long 0x00 "CSL33,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x88++0x3
    line.long 0x00 "CSL34,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x8c++0x3
    line.long 0x00 "CSL35,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x90++0x3
    line.long 0x00 "CSL36,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x94++0x3
    line.long 0x00 "CSL37,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x98++0x3
    line.long 0x00 "CSL38,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x9c++0x3
    line.long 0x00 "CSL39,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 4.
group.long 0x200++0x3
    line.long 0x00 "HP0,HP register"
        bitfld.long 0x00 0. " HP ,Privilege indicator bits" "0,1"
        textline "   "
        bitfld.long 0x00 1. " L ,Lock bit set by secure software" "0,1"
        textline "   "
        bitfld.long 0x00 2. " HP1 ,Privilege indicator bits" "0,1"
        textline "   "
        bitfld.long 0x00 3. " L1 ,Lock bit set by secure software" "0,1"
        textline "   "
        bitfld.long 0x00 4. " HP2 ,Privilege indicator bits" "0,1"
        textline "   "
        bitfld.long 0x00 5. " L2 ,Lock bit set by secure software" "0,1"
        textline "   "
        bitfld.long 0x00 6. " HP3 ,Privilege indicator bits" "0,1"
        textline "   "
        bitfld.long 0x00 7. " L3 ,Lock bit set by secure software" "0,1"
        textline "   "
        bitfld.long 0x00 8. " HP4 ,Privilege indicator bits" "0,1"
        textline "   "
        bitfld.long 0x00 9. " L4 ,Lock bit set by secure software" "0,1"
        textline "   "
        bitfld.long 0x00 10. " HP5 ,Privilege indicator bits" "0,1"
        textline "   "
        bitfld.long 0x00 11. " L5 ,Lock bit set by secure software" "0,1"
        textline "   "
        bitfld.long 0x00 12. " HP6 ,Privilege indicator bits" "0,1"
        textline "   "
        bitfld.long 0x00 13. " L6 ,Lock bit set by secure software" "0,1"
        textline "   "
        bitfld.long 0x00 14. " HP7 ,Privilege indicator bits" "0,1"
        textline "   "
        bitfld.long 0x00 15. " L7 ,Lock bit set by secure software" "0,1"
        textline "   "
        bitfld.long 0x00 16. " HP8 ,Privilege indicator bits" "0,1"
        textline "   "
        bitfld.long 0x00 17. " L8 ,Lock bit set by secure software" "0,1"
        textline "   "
        bitfld.long 0x00 18. " HP9 ,Privilege indicator bits" "0,1"
        textline "   "
        bitfld.long 0x00 19. " L9 ,Lock bit set by secure software" "0,1"
        textline "   "
        bitfld.long 0x00 20. " HP10 ,Privilege indicator bits" "0,1"
        textline "   "
        bitfld.long 0x00 21. " L10 ,Lock bit set by secure software" "0,1"
        textline "   "
        bitfld.long 0x00 22. " HP11 ,Privilege indicator bits" "0,1"
        textline "   "
        bitfld.long 0x00 23. " L11 ,Lock bit set by secure software" "0,1"
        textline "   "
        bitfld.long 0x00 24. " HP12 ,Privilege indicator bits" "0,1"
        textline "   "
        bitfld.long 0x00 25. " L12 ,Lock bit set by secure software" "0,1"
        textline "   "
        bitfld.long 0x00 26. " HP13 ,Privilege indicator bits" "0,1"
        textline "   "
        bitfld.long 0x00 27. " L13 ,Lock bit set by secure software" "0,1"
        textline "   "
        bitfld.long 0x00 28. " HP14 ,Privilege indicator bits" "0,1"
        textline "   "
        bitfld.long 0x00 29. " L14 ,Lock bit set by secure software" "0,1"
        textline "   "
        bitfld.long 0x00 30. " HP15 ,Privilege indicator bits" "0,1"
        textline "   "
        bitfld.long 0x00 31. " L15 ,Lock bit set by secure software" "0,1"
width 4.
group.long 0x204++0x3
    line.long 0x00 "HP1,HP register"
        bitfld.long 0x00 0. " HP ,Privilege indicator bits" "0,1"
        textline "   "
        bitfld.long 0x00 1. " L ,Lock bit set by secure software" "0,1"
        textline "   "
        bitfld.long 0x00 2. " HP1 ,Privilege indicator bits" "0,1"
        textline "   "
        bitfld.long 0x00 3. " L1 ,Lock bit set by secure software" "0,1"
        textline "   "
        bitfld.long 0x00 4. " HP2 ,Privilege indicator bits" "0,1"
        textline "   "
        bitfld.long 0x00 5. " L2 ,Lock bit set by secure software" "0,1"
        textline "   "
        bitfld.long 0x00 6. " HP3 ,Privilege indicator bits" "0,1"
        textline "   "
        bitfld.long 0x00 7. " L3 ,Lock bit set by secure software" "0,1"
        textline "   "
        bitfld.long 0x00 8. " HP4 ,Privilege indicator bits" "0,1"
        textline "   "
        bitfld.long 0x00 9. " L4 ,Lock bit set by secure software" "0,1"
        textline "   "
        bitfld.long 0x00 10. " HP5 ,Privilege indicator bits" "0,1"
        textline "   "
        bitfld.long 0x00 11. " L5 ,Lock bit set by secure software" "0,1"
        textline "   "
        bitfld.long 0x00 12. " HP6 ,Privilege indicator bits" "0,1"
        textline "   "
        bitfld.long 0x00 13. " L6 ,Lock bit set by secure software" "0,1"
        textline "   "
        bitfld.long 0x00 14. " HP7 ,Privilege indicator bits" "0,1"
        textline "   "
        bitfld.long 0x00 15. " L7 ,Lock bit set by secure software" "0,1"
        textline "   "
        bitfld.long 0x00 16. " HP8 ,Privilege indicator bits" "0,1"
        textline "   "
        bitfld.long 0x00 17. " L8 ,Lock bit set by secure software" "0,1"
        textline "   "
        bitfld.long 0x00 18. " HP9 ,Privilege indicator bits" "0,1"
        textline "   "
        bitfld.long 0x00 19. " L9 ,Lock bit set by secure software" "0,1"
        textline "   "
        bitfld.long 0x00 20. " HP10 ,Privilege indicator bits" "0,1"
        textline "   "
        bitfld.long 0x00 21. " L10 ,Lock bit set by secure software" "0,1"
        textline "   "
        bitfld.long 0x00 22. " HP11 ,Privilege indicator bits" "0,1"
        textline "   "
        bitfld.long 0x00 23. " L11 ,Lock bit set by secure software" "0,1"
        textline "   "
        bitfld.long 0x00 24. " HP12 ,Privilege indicator bits" "0,1"
        textline "   "
        bitfld.long 0x00 25. " L12 ,Lock bit set by secure software" "0,1"
        textline "   "
        bitfld.long 0x00 26. " HP13 ,Privilege indicator bits" "0,1"
        textline "   "
        bitfld.long 0x00 27. " L13 ,Lock bit set by secure software" "0,1"
        textline "   "
        bitfld.long 0x00 28. " HP14 ,Privilege indicator bits" "0,1"
        textline "   "
        bitfld.long 0x00 29. " L14 ,Lock bit set by secure software" "0,1"
        textline "   "
        bitfld.long 0x00 30. " HP15 ,Privilege indicator bits" "0,1"
        textline "   "
        bitfld.long 0x00 31. " L15 ,Lock bit set by secure software" "0,1"
width 3.
group.long 0x218++0x3
    line.long 0x00 "SA,Secure access register"
        bitfld.long 0x00 0. " NSA ,Non-Secure Access Policy indicator bits" "0,1"
        textline "  "
        bitfld.long 0x00 1. " L ,Lock bit set by secure software" "0,1"
        textline "  "
        bitfld.long 0x00 2. " NSA1 ,Non-Secure Access Policy indicator bits" "0,1"
        textline "  "
        bitfld.long 0x00 3. " L1 ,Lock bit set by secure software" "0,1"
        textline "  "
        bitfld.long 0x00 4. " NSA2 ,Non-Secure Access Policy indicator bits" "0,1"
        textline "  "
        bitfld.long 0x00 5. " L2 ,Lock bit set by secure software" "0,1"
        textline "  "
        bitfld.long 0x00 6. " NSA3 ,Non-Secure Access Policy indicator bits" "0,1"
        textline "  "
        bitfld.long 0x00 7. " L3 ,Lock bit set by secure software" "0,1"
        textline "  "
        bitfld.long 0x00 8. " NSA4 ,Non-Secure Access Policy indicator bits" "0,1"
        textline "  "
        bitfld.long 0x00 9. " L4 ,Lock bit set by secure software" "0,1"
        textline "  "
        bitfld.long 0x00 10. " NSA5 ,Non-Secure Access Policy indicator bits" "0,1"
        textline "  "
        bitfld.long 0x00 11. " L5 ,Lock bit set by secure software" "0,1"
        textline "  "
        bitfld.long 0x00 12. " NSA6 ,Non-Secure Access Policy indicator bits" "0,1"
        textline "  "
        bitfld.long 0x00 13. " L6 ,Lock bit set by secure software" "0,1"
        textline "  "
        bitfld.long 0x00 14. " NSA7 ,Non-Secure Access Policy indicator bits" "0,1"
        textline "  "
        bitfld.long 0x00 15. " L7 ,Lock bit set by secure software" "0,1"
        textline "  "
        bitfld.long 0x00 16. " NSA8 ,Non-Secure Access Policy indicator bits" "0,1"
        textline "  "
        bitfld.long 0x00 17. " L8 ,Lock bit set by secure software" "0,1"
        textline "  "
        bitfld.long 0x00 18. " NSA9 ,Non-Secure Access Policy indicator bits" "0,1"
        textline "  "
        bitfld.long 0x00 19. " L9 ,Lock bit set by secure software" "0,1"
        textline "  "
        bitfld.long 0x00 20. " NSA10 ,Non-Secure Access Policy indicator bits" "0,1"
        textline "  "
        bitfld.long 0x00 21. " L10 ,Lock bit set by secure software" "0,1"
        textline "  "
        bitfld.long 0x00 22. " NSA11 ,Non-Secure Access Policy indicator bits" "0,1"
        textline "  "
        bitfld.long 0x00 23. " L11 ,Lock bit set by secure software" "0,1"
        textline "  "
        bitfld.long 0x00 24. " NSA12 ,Non-Secure Access Policy indicator bits" "0,1"
        textline "  "
        bitfld.long 0x00 25. " L12 ,Lock bit set by secure software" "0,1"
        textline "  "
        bitfld.long 0x00 26. " NSA13 ,Non-Secure Access Policy indicator bits" "0,1"
        textline "  "
        bitfld.long 0x00 27. " L13 ,Lock bit set by secure software" "0,1"
        textline "  "
        bitfld.long 0x00 28. " NSA14 ,Non-Secure Access Policy indicator bits" "0,1"
        textline "  "
        bitfld.long 0x00 29. " L14 ,Lock bit set by secure software" "0,1"
        textline "  "
        bitfld.long 0x00 30. " NSA15 ,Non-Secure Access Policy indicator bits" "0,1"
        textline "  "
        bitfld.long 0x00 31. " L15 ,Lock bit set by secure software" "0,1"


tree.end



;--------------------------------------------------------------------------------
; DBGMON
;--------------------------------------------------------------------------------
tree "DBGMON"
    base ad:0x02090000

width 15.
group.long 0x0++0x3
    line.long 0x00 "HW_DBGMON_CTRL,HW_DBGMON_CTRL"
        bitfld.long 0x00 0. " RUN ,Set this bit to one to enable the DBGMON operation" "0,1"
        textline "              "
        bitfld.long 0x00 1. " SNAP ,Set this bit to snapshot the registers selected by REQSEL to SNVS domain registers" "0,1"
        textline "              "
        bitfld.long 0x00 2. " CLR ,Set this bit to clear the registers in SOC domain." "0,1"
        textline "              "
        bitfld.long 0x00 3. " CLR_SNVS ,Set this bit to clear the registers in SNVS domain" "0,1"
        textline "              "
        bitfld.long 0x00 4. " ADDR_TRAPMODE ,The bit defines the address trap function." "0,1"
        textline "              "
        bitfld.long 0x00 5. " ID_TRAPMODE ,The bit defines the ID trap function." "0,1"
        textline "              "
        hexmask.long.byte 0x00 8.--10. 1. " REQSEL ,This field defines which sets of AXI transaction will be snaped to SNVS domain registers."
        textline "              "
        bitfld.long 0x00 16. " WORKMODE ,This field defines whether ignore the transaction in IRQ" "0,1"
        textline "              "
        bitfld.long 0x00 20. " ADDR_MASKEN ,This field control the address mask function," "0,1"
        textline "              "
        bitfld.long 0x00 24. " WDOG_IRQ_SEL ,Select the source of WDOG IRQ." "0,1"
        textline "              "
        bitfld.long 0x00 30. " CLKGATE ,This bit must be set to zero for normal oepration." "0,1"
        textline "              "
        bitfld.long 0x00 31. " SFTRST ,Set to zero for normal operation." "0,1"
width 20.
group.long 0x10++0x3
    line.long 0x00 "HW_DBGMON_MASTER_EN,HW_DBGMON_MASTER_EN"
        bitfld.long 0x00 0. " MID0 ,Set to 1 to enable monitoring on MasterID 0." "0,1"
        textline "                   "
        bitfld.long 0x00 1. " MID1 ,Set to 1 to enable monitoring on MasterID 1." "0,1"
        textline "                   "
        bitfld.long 0x00 2. " MID2 ,Set to 1 to enable monitoring on MasterID 2." "0,1"
        textline "                   "
        bitfld.long 0x00 3. " MID3 ,Set to 1 to enable monitoring on MasterID 3." "0,1"
        textline "                   "
        bitfld.long 0x00 4. " MID4 ,Set to 1 to enable monitoring on MasterID 4." "0,1"
        textline "                   "
        bitfld.long 0x00 5. " MID5 ,Set to 1 to enable monitoring on MasterID 5" "0,1"
        textline "                   "
        bitfld.long 0x00 6. " MID6 ,Set to 1 to enable monitoring on MasterID 6." "0,1"
        textline "                   "
        bitfld.long 0x00 7. " MID7 ,Set to 1 to enable monitoring on MasterID 7." "0,1"
        textline "                   "
        bitfld.long 0x00 8. " MID8 ,Set to 1 to enable monitoring on MasterID 8." "0,1"
        textline "                   "
        bitfld.long 0x00 9. " MID9 ,Set to 1 to enable monitoring on MasterID 9." "0,1"
        textline "                   "
        bitfld.long 0x00 10. " MID10 ,Set to 1 to enable monitoring on MasterID 10." "0,1"
        textline "                   "
        bitfld.long 0x00 11. " MID11 ,Set to 1 to enable monitoring on MasterID 11." "0,1"
        textline "                   "
        bitfld.long 0x00 12. " MID12 ,Set to 1 to enable monitoring on MasterID 12." "0,1"
        textline "                   "
        bitfld.long 0x00 13. " MID13 ,Set to 1 to enable monitoring on MasterID 13." "0,1"
        textline "                   "
        bitfld.long 0x00 14. " MID14 ,Set to 1 to enable monitoring on MasterID 14." "0,1"
        textline "                   "
        bitfld.long 0x00 15. " MID15 ,Set to 1 to enable monitoring on MasterID 15." "0,1"
width 14.
group.long 0x20++0x3
    line.long 0x00 "HW_DBGMON_IRQ,HW_DBGMON_IRQ"
        bitfld.long 0x00 0. " ADDR_TRAP_IRQEN ,Address trap interrupt control." "0,1"
        textline "             "
        bitfld.long 0x00 1. " ID_TRAP_IRQEN ,ID trap interrupt control." "0,1"
        textline "             "
        bitfld.long 0x00 2. " ADDR_TRAP_IRQ ,This bit indicates the Address trap interrupt is happening." "0,1"
        textline "             "
        bitfld.long 0x00 3. " ID_TRAP_IRQ ,This bit indicates the ID trap interrupt is happening." "0,1"
        textline "             "
        hexmask.long.word 0x00 16.--32. 1. " IRQ_MID ,This field indicate which master sends the interrupt, will not update until all interrupts are cleared."
width 24.
group.long 0x30++0x3
    line.long 0x00 "HW_DBGMON_TRAP_ADDR_LOW,HW_DBGMON_TRAP_ADDR_LOW"
        hexmask.long.long 0x00 0.--32. 1. " ADDRESS ,This field contains 32-bit low address for the address trap range"
width 25.
group.long 0x40++0x3
    line.long 0x00 "HW_DBGMON_TRAP_ADDR_HIGH,HW_DBGMON_TRAP_ADDR_HIGH"
        hexmask.long.long 0x00 0.--32. 1. " ADDRESS ,This field contains 32-bit high address for the address trap range"
width 18.
group.long 0x50++0x3
    line.long 0x00 "HW_DBGMON_TRAP_ID,HW_DBGMON_TRAP_ID"
        hexmask.long.word 0x00 0.--16. 1. " TRAP_ID_LOW ,This field contains 16-bit low ID for ID trap range"
        textline "                 "
        hexmask.long.word 0x00 16.--32. 1. " TRAP_ID_HIGH ,This field contains 16-bit high ID for ID trap range"
width 20.
rgroup.long 0x60++0x3
    line.long 0x00 "HW_DBGMON_SNVS_ADDR,HW_DBGMON_SNVS_ADDR"
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,This field contains 32-bit Address in SNVS domain register"
width 20.
rgroup.long 0x70++0x3
    line.long 0x00 "HW_DBGMON_SNVS_DATA,HW_DBGMON_SNVS_DATA"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,This field contains 32-bit Data of AXI transaction in SNVS domain register"
width 20.
rgroup.long 0x80++0x3
    line.long 0x00 "HW_DBGMON_SNVS_INFO,HW_DBGMON_SNVS_INFO"
        bitfld.long 0x00 0. " COMPLETE ,The field indicates whether the AXI transaction in SNVS domain complete." "0,1"
        textline "                   "
        bitfld.long 0x00 1. " RDWR ,The field indicates the read/write attribute of AXI transaction in SNVS domain." "0,1"
        textline "                   "
        hexmask.long.word 0x00 16.--32. 1. " ID ,The field contain the ID of the AXI transaction in SNVS domain"
width 18.
rgroup.long 0x90++0x3
    line.long 0x00 "HW_DBGMON_VERSION,HW_DBGMON_VERSION"
        hexmask.long.word 0x00 0.--16. 1. " STEP ,Fixed read-only value reflecting the stepping of the RTL version"
        textline "                 "
        hexmask.long.byte 0x00 16.--24. 1. " MINOR ,Fixed read-only value reflecting the MINOR field of the RTL version"
        textline "                 "
        hexmask.long.byte 0x00 24.--32. 1. " MAJOR ,Fixed read-only value reflecting the MAJOR field of the RTL version"


tree.end



;--------------------------------------------------------------------------------
; DCP
;--------------------------------------------------------------------------------
tree "DCP"
    base ad:0x020fc000

width 5.
group.long 0x0++0x3
    line.long 0x00 "CTRL,DCP Control Register 0"
        hexmask.long.byte 0x00 0.--8. 1. " CHANNEL_INTERRUPT_ENABLE ,Per-channel interrupt enable bit."
        textline "    "
        bitfld.long 0x00 21. " ENABLE_CONTEXT_SWITCHING ,Enable automatic context switching for the channels." "0,1"
        textline "    "
        bitfld.long 0x00 22. " ENABLE_CONTEXT_CACHING ,Software should set this bit to enable caching of contexts between operations." "0,1"
        textline "    "
        bitfld.long 0x00 23. " GATHER_RESIDUAL_WRITES ,Software should set this bit to enable ragged writes to unaligned buffers to be gathered between multiple write operations." "0,1"
        textline "    "
        bitfld.long 0x00 28. " PRESENT_SHA ,Indicates whether the SHA1/SHA2 functions are present." "0,1"
        textline "    "
        bitfld.long 0x00 29. " PRESENT_CRYPTO ,Indicates whether the crypto (Cipher/Hash) functions are present." "0,1"
        textline "    "
        bitfld.long 0x00 30. " CLKGATE ,This bit must be set to zero for normal operation." "0,1"
        textline "    "
        bitfld.long 0x00 31. " SFTRST ,Set this bit to zero to enable normal DCP operation." "0,1"
width 5.
group.long 0x10++0x3
    line.long 0x00 "STAT,DCP Status Register"
        hexmask.long.byte 0x00 0.--4. 1. " IRQ ,Indicates which channels have pending interrupt requests."
        textline "    "
        hexmask.long.byte 0x00 16.--24. 1. " READY_CHANNELS ,Indicates which channels are ready to proceed with a transfer (active channel also included)."
        textline "    "
        hexmask.long.byte 0x00 24.--28. 1. " CUR_CHANNEL ,Current (active) channel (encoded)."
        textline "    "
        bitfld.long 0x00 28. " OTP_KEY_READY ,When set, indicates that the OTP key has been shifted from the fuse block and is ready for use." "0,1"
width 12.
group.long 0x20++0x3
    line.long 0x00 "CHANNELCTRL,DCP Channel Control Register"
        hexmask.long.byte 0x00 0.--8. 1. " ENABLE_CHANNEL ,Setting a bit in this field will enabled the DMA channel associated with it."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " HIGH_PRIORITY_CHANNEL ,Setting a bit in this field causes the corresponding channel to have high-priority arbitration."
        textline "           "
        bitfld.long 0x00 16. " CH0_IRQ_MERGED ,Indicates that the interrupt for channel 0 should be merged with the other interrupts on the shared dcp_irq interrupt." "0,1"
width 12.
group.long 0x30++0x3
    line.long 0x00 "CAPABILITY0,DCP Capability 0 Register"
        hexmask.long.byte 0x00 0.--8. 1. " NUM_KEYS ,Encoded value indicating the number of key storage locations implemented in the design."
        textline "           "
        hexmask.long.byte 0x00 8.--12. 1. " NUM_CHANNELS ,Encoded value indicating the number of channels implemented in the design."
        textline "           "
        bitfld.long 0x00 29. " DISABLE_UNIQUE_KEY ,Write to a 1 disable the per-device unique key." "0,1"
        textline "           "
        bitfld.long 0x00 31. " DISABLE_DECRYPT ,Write to a 1 to disable decryption." "0,1"
width 12.
rgroup.long 0x40++0x3
    line.long 0x00 "CAPABILITY1,DCP Capability 1 Register"
        hexmask.long.word 0x00 0.--16. 1. " CIPHER_ALGORITHMS ,One-hot field indicating which cipher algorithms are available."
        textline "           "
        hexmask.long.word 0x00 16.--32. 1. " HASH_ALGORITHMS ,One-hot field indicating which hashing features are implemented in HW."
width 8.
group.long 0x50++0x3
    line.long 0x00 "CONTEXT,DCP Context Buffer Pointer"
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,Context pointer address."
width 4.
group.long 0x60++0x3
    line.long 0x00 "KEY,DCP Key Index"
        hexmask.long.byte 0x00 0.--2. 1. " SUBWORD ,Key subword pointer."
        textline "   "
        hexmask.long.byte 0x00 4.--6. 1. " INDEX ,Key index pointer."
width 8.
group.long 0x70++0x3
    line.long 0x00 "KEYDATA,DCP Key Data"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Word 0 data for key."
width 8.
rgroup.long 0x80++0x3
    line.long 0x00 "PACKET0,DCP Work Packet 0 Status Register"
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,Next Pointer Register,"
width 8.
rgroup.long 0x90++0x3
    line.long 0x00 "PACKET1,DCP Work Packet 1 Status Register"
        bitfld.long 0x00 0. " INTERRUPT ,Reflects whether the channel should issue an interrupt upon completion of the packet." "0,1"
        textline "       "
        bitfld.long 0x00 1. " DECR_SEMAPHORE ,Reflects whether the channel's semaphore should be decremented at the end of the current operation." "0,1"
        textline "       "
        bitfld.long 0x00 2. " CHAIN ,Reflects whether the next command pointer register should be loaded into the channel's current descriptor pointer." "0,1"
        textline "       "
        bitfld.long 0x00 3. " CHAIN_CONTIGUOUS ,Reflects whether the next packet's address is located following this packet's payload." "0,1"
        textline "       "
        bitfld.long 0x00 4. " ENABLE_MEMCOPY ,Reflects whether the selected hashing function should be enabled for this operation." "0,1"
        textline "       "
        bitfld.long 0x00 5. " ENABLE_CIPHER ,Reflects whether the selected cipher function should be enabled for this operation." "0,1"
        textline "       "
        bitfld.long 0x00 6. " ENABLE_HASH ,Reflects whether the selected hashing function should be enabled for this operation." "0,1"
        textline "       "
        bitfld.long 0x00 7. " ENABLE_BLIT ,Reflects whether the DCP should perform a blit operation." "0,1"
        textline "       "
        bitfld.long 0x00 8. " CIPHER_ENCRYPT ,When the cipher block is enabled, this bit indicates whether the operation is encryption or decryption." "0,1"
        textline "       "
        bitfld.long 0x00 9. " CIPHER_INIT ,Reflects whether the cipher block should load the initialization vector from the payload for this operation." "0,1"
        textline "       "
        bitfld.long 0x00 10. " OTP_KEY ,Reflects whether a hardware-based key should be used." "0,1"
        textline "       "
        bitfld.long 0x00 11. " PAYLOAD_KEY ,When set, indicates the payload contains the key." "0,1"
        textline "       "
        bitfld.long 0x00 12. " HASH_INIT ,Reflects whether the current hashing block is the initial block in the hashing operation, so the hash registers should be initialized before the operation." "0,1"
        textline "       "
        bitfld.long 0x00 13. " HASH_TERM ,Reflects whether the current hashing block is the final block in the hashing operation, so the hash padding should be applied by hardware." "0,1"
        textline "       "
        bitfld.long 0x00 14. " CHECK_HASH ,Reflects whether the calculated hash value should be compared against the hash provided in the payload." "0,1"
        textline "       "
        bitfld.long 0x00 15. " HASH_OUTPUT ,When hashing is enabled, this bit controls whether the input or output data is hashed." "0,1"
        textline "       "
        bitfld.long 0x00 16. " CONSTANT_FILL ,When this bit is set (MEMCOPY and BLIT modes only), the DCP will simply fill the destination buffer with the value found in the Source Address field." "0,1"
        textline "       "
        bitfld.long 0x00 17. " TEST_SEMA_IRQ ,This bit is used to test the channel semaphore transition to 0." "0,1"
        textline "       "
        bitfld.long 0x00 18. " KEY_BYTESWAP ,Reflects whether the DCP engine will swap key bytes (big-endian key)." "0,1"
        textline "       "
        bitfld.long 0x00 19. " KEY_WORDSWAP ,Reflects whether the DCP engine will swap key words (big-endian key)." "0,1"
        textline "       "
        bitfld.long 0x00 20. " INPUT_BYTESWAP ,Reflects whether the DCP engine will byteswap input data (big-endian data)." "0,1"
        textline "       "
        bitfld.long 0x00 21. " INPUT_WORDSWAP ,Reflects whether the DCP engine will wordswap input data (big-endian data)." "0,1"
        textline "       "
        bitfld.long 0x00 22. " OUTPUT_BYTESWAP ,Reflects whether the DCP engine will byteswap output data (big-endian data)." "0,1"
        textline "       "
        bitfld.long 0x00 23. " OUTPUT_WORDSWAP ,Reflects whether the DCP engine will wordswap output data (big-endian data)." "0,1"
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " TAG ,Packet Tag"
width 8.
rgroup.long 0xa0++0x3
    line.long 0x00 "PACKET2,DCP Work Packet 2 Status Register"
        hexmask.long.byte 0x00 0.--4. 1. " CIPHER_SELECT ,Cipher Selection Field"
        textline "       "
        hexmask.long.byte 0x00 4.--8. 1. " CIPHER_MODE ,Cipher Mode Selection Field."
        textline "       "
        hexmask.long.byte 0x00 8.--16. 1. " KEY_SELECT ,Key Selection Field."
        textline "       "
        hexmask.long.byte 0x00 16.--20. 1. " HASH_SELECT ,Hash Selection Field"
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " CIPHER_CFG ,Cipher configuration bits."
width 8.
rgroup.long 0xb0++0x3
    line.long 0x00 "PACKET3,DCP Work Packet 3 Status Register"
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,Source Buffer Address Pointer."
width 8.
rgroup.long 0xc0++0x3
    line.long 0x00 "PACKET4,DCP Work Packet 4 Status Register"
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,Destination Buffer Address Pointer."
width 8.
rgroup.long 0xd0++0x3
    line.long 0x00 "PACKET5,DCP Work Packet 5 Status Register"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Byte Count register."
width 8.
rgroup.long 0xe0++0x3
    line.long 0x00 "PACKET6,DCP Work Packet 6 Status Register"
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,This regiser reflects the payload pointer for the current control packet."
width 10.
group.long 0x100++0x3
    line.long 0x00 "CH0CMDPTR,DCP Channel 0 Command Pointer Address Register"
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,Pointer to descriptor structure to be processed for channel 0."
width 8.
group.long 0x110++0x3
    line.long 0x00 "CH0SEMA,DCP Channel 0 Semaphore Register"
        hexmask.long.byte 0x00 0.--8. 1. " INCREMENT ,The value written to this field is added to the semaphore count in an atomic way such that simultaneous software adds and DCP hardware substracts happening on the same clock are protected."
        textline "       "
        hexmask.long.byte 0x00 16.--24. 1. " VALUE ,This read-only field shows the current (instantaneous) value of the semaphore counter."
width 8.
group.long 0x120++0x3
    line.long 0x00 "CH0STAT,DCP Channel 0 Status Register"
        bitfld.long 0x00 1. " HASH_MISMATCH ,The bit indicates that a hashing check operation mismatched for control packets that enable the HASH_CHECK bit." "0,1"
        textline "       "
        bitfld.long 0x00 2. " ERROR_SETUP ,This bit indicates that the hardware has detected an invalid programming configuration such as a buffer length that is not a multiple of the natural data size for the operation." "0,1"
        textline "       "
        bitfld.long 0x00 3. " ERROR_PACKET ,This bit indicates that a a bus error occurred when reading the packet or payload or when writing status back to the packet payload." "0,1"
        textline "       "
        bitfld.long 0x00 4. " ERROR_SRC ,This bit indicates a bus error occurred when reading from the source buffer." "0,1"
        textline "       "
        bitfld.long 0x00 5. " ERROR_DST ,This bit indicates a bus error occurred when storing to the destination buffer." "0,1"
        textline "       "
        bitfld.long 0x00 6. " ERROR_PAGEFAULT ,This bit indicates a page fault occurred while converting a virtual address to a physical address.." "0,1"
        textline "       "
        hexmask.long.byte 0x00 16.--24. 1. " ERROR_CODE ,Indicates additional error codes for some error conditions."
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " TAG ,Indicates the tag from the last completed packet in the command structure"
width 8.
group.long 0x130++0x3
    line.long 0x00 "CH0OPTS,DCP Channel 0 Options Register"
        hexmask.long.word 0x00 0.--16. 1. " RECOVERY_TIMER ,This field indicates the recovery time for the channel."
width 10.
group.long 0x140++0x3
    line.long 0x00 "CH1CMDPTR,DCP Channel 1 Command Pointer Address Register"
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,Pointer to descriptor structure to be processed for channel 1."
width 8.
group.long 0x150++0x3
    line.long 0x00 "CH1SEMA,DCP Channel 1 Semaphore Register"
        hexmask.long.byte 0x00 0.--8. 1. " INCREMENT ,The value written to this field is added to the semaphore count in an atomic way such that simultaneous software adds and DCP hardware substracts happening on the same clock are protected."
        textline "       "
        hexmask.long.byte 0x00 16.--24. 1. " VALUE ,This read-only field shows the current (instantaneous) value of the semaphore counter."
width 8.
group.long 0x160++0x3
    line.long 0x00 "CH1STAT,DCP Channel 1 Status Register"
        bitfld.long 0x00 1. " HASH_MISMATCH ,The bit indicates that a hashing check operation mismatched for control packets that enable the HASH_CHECK bit." "0,1"
        textline "       "
        bitfld.long 0x00 2. " ERROR_SETUP ,This bit indicates that the hardware detected an invalid programming configuration such as a buffer length that is not a multiple of the natural data size for the operation." "0,1"
        textline "       "
        bitfld.long 0x00 3. " ERROR_PACKET ,This bit indicates that a bus error occurs when reading the packet or payload or when writing status back to the packet paylaod." "0,1"
        textline "       "
        bitfld.long 0x00 4. " ERROR_SRC ,This bit indicates a bus error occurred when reading from the source buffer." "0,1"
        textline "       "
        bitfld.long 0x00 5. " ERROR_DST ,This bit indicates a bus error occurred when storing to the destination buffer." "0,1"
        textline "       "
        bitfld.long 0x00 6. " ERROR_PAGEFAULT ,This bit indicates a page fault occurred while converting a virtual address to a physical address.." "0,1"
        textline "       "
        hexmask.long.byte 0x00 16.--24. 1. " ERROR_CODE ,Indicates additional error codes for some error conditions."
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " TAG ,Indicates the tag from the last completed packet in the command structure"
width 8.
group.long 0x170++0x3
    line.long 0x00 "CH1OPTS,DCP Channel 1 Options Register"
        hexmask.long.word 0x00 0.--16. 1. " RECOVERY_TIMER ,This field indicates the recovery time for the channel."
width 10.
group.long 0x180++0x3
    line.long 0x00 "CH2CMDPTR,DCP Channel 2 Command Pointer Address Register"
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,Pointer to descriptor structure to be processed for channel 2."
width 8.
group.long 0x190++0x3
    line.long 0x00 "CH2SEMA,DCP Channel 2 Semaphore Register"
        hexmask.long.byte 0x00 0.--8. 1. " INCREMENT ,The value written to this field is added to the semaphore count in an atomic way such that simultaneous software adds and DCP hardware substracts happening on the same clock are protected."
        textline "       "
        hexmask.long.byte 0x00 16.--24. 1. " VALUE ,This read-only field shows the current (instantaneous) value of the semaphore counter."
width 8.
group.long 0x1a0++0x3
    line.long 0x00 "CH2STAT,DCP Channel 2 Status Register"
        bitfld.long 0x00 1. " HASH_MISMATCH ,The bit indicates that a hashing check operation mismatched for control packets that enable the HASH_CHECK bit." "0,1"
        textline "       "
        bitfld.long 0x00 2. " ERROR_SETUP ,This bit indicates that the hardware detected an invalid programming configuration such as a buffer length that is not a multiple of the natural data size for the operation." "0,1"
        textline "       "
        bitfld.long 0x00 3. " ERROR_PACKET ,This bit indicates that a bus error occurred when reading the packet or payload or when writing status back to the packet paylaod." "0,1"
        textline "       "
        bitfld.long 0x00 4. " ERROR_SRC ,This bit indicates a bus error occurred when reading from the source buffer." "0,1"
        textline "       "
        bitfld.long 0x00 5. " ERROR_DST ,This bit indicates a bus error occurred when storing to the destination buffer." "0,1"
        textline "       "
        bitfld.long 0x00 6. " ERROR_PAGEFAULT ,This bit indicates a page fault occurred while converting a virtual address to a physical address.." "0,1"
        textline "       "
        hexmask.long.byte 0x00 16.--24. 1. " ERROR_CODE ,Indicates additional error codes for some error conditions."
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " TAG ,Indicates the tag from the last completed packet in the command structure"
width 8.
group.long 0x1b0++0x3
    line.long 0x00 "CH2OPTS,DCP Channel 2 Options Register"
        hexmask.long.word 0x00 0.--16. 1. " RECOVERY_TIMER ,This field indicates the recovery time for the channel."
width 10.
group.long 0x1c0++0x3
    line.long 0x00 "CH3CMDPTR,DCP Channel 3 Command Pointer Address Register"
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,Pointer to descriptor structure to be processed for channel 3."
width 8.
group.long 0x1d0++0x3
    line.long 0x00 "CH3SEMA,DCP Channel 3 Semaphore Register"
        hexmask.long.byte 0x00 0.--8. 1. " INCREMENT ,The value written to this field is added to the semaphore count in an atomic way such that simultaneous software adds and DCP hardware substracts happening on the same clock are protected."
        textline "       "
        hexmask.long.byte 0x00 16.--24. 1. " VALUE ,This read-only field shows the current (instantaneous) value of the semaphore counter."
width 8.
group.long 0x1e0++0x3
    line.long 0x00 "CH3STAT,DCP Channel 3 Status Register"
        bitfld.long 0x00 1. " HASH_MISMATCH ,The bit indicates that a hashing check operation mismatched for control packets that enable the HASH_CHECK bit." "0,1"
        textline "       "
        bitfld.long 0x00 2. " ERROR_SETUP ,This bit indicates that the hardware detected an invalid programming configuration such as a buffer length that is not a multiple of the natural data size for the operation." "0,1"
        textline "       "
        bitfld.long 0x00 3. " ERROR_PACKET ,This bit indicates that a bus error occurred when reading the packet or payload or when writing status back to the packet paylaod." "0,1"
        textline "       "
        bitfld.long 0x00 4. " ERROR_SRC ,This bit indicates a bus error occurred when reading from the source buffer." "0,1"
        textline "       "
        bitfld.long 0x00 5. " ERROR_DST ,This bit indicates a bus error occurred when storing to the destination buffer." "0,1"
        textline "       "
        bitfld.long 0x00 6. " ERROR_PAGEFAULT ,This bit indicates a page fault occurred while converting a virtual address to a physical address.." "0,1"
        textline "       "
        hexmask.long.byte 0x00 16.--24. 1. " ERROR_CODE ,Indicates additional error codes for some error conditions."
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " TAG ,Indicates the tag from the last completed packet in the command structure"
width 8.
group.long 0x1f0++0x3
    line.long 0x00 "CH3OPTS,DCP Channel 3 Options Register"
        hexmask.long.word 0x00 0.--16. 1. " RECOVERY_TIMER ,This field indicates the recovery time for the channel."
width 10.
group.long 0x400++0x3
    line.long 0x00 "DBGSELECT,DCP Debug Select Register"
        hexmask.long.byte 0x00 0.--8. 1. " INDEX ,Selects a value to read via the debug data register."
width 8.
rgroup.long 0x410++0x3
    line.long 0x00 "DBGDATA,DCP Debug Data Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Debug Data"
width 10.
group.long 0x420++0x3
    line.long 0x00 "PAGETABLE,DCP Page Table Register"
        bitfld.long 0x00 0. " ENABLE ,Page Table Enable control." "0,1"
        textline "         "
        bitfld.long 0x00 1. " FLUSH ,Page Table Flush control." "0,1"
        textline "         "
        hexmask.long.long 0x00 2.--32. 1. " BASE ,Page Table Base Address."
width 8.
rgroup.long 0x430++0x3
    line.long 0x00 "VERSION,DCP Version Register"
        hexmask.long.word 0x00 0.--16. 1. " STEP ,Fixed read-onlyl value reflecting the stepping of version of the design implementation."
        textline "       "
        hexmask.long.byte 0x00 16.--24. 1. " MINOR ,Fixed read-onlyl value reflecting the MINOR version of the design implementation."
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " MAJOR ,Fixed read-onlyl value reflecting the MAJOR version of the design implementation."


tree.end



;--------------------------------------------------------------------------------
; DVFSC
;--------------------------------------------------------------------------------
tree "DVFSC"
    base ad:0x020dc180

width 5.
group.long 0x0++0x3
    line.long 0x00 "THRS,DVFS Thresholds"
        hexmask.long.byte 0x00 0.--6. 1. " PNCTHR ,Panic threshold for load tracking"
        textline "    "
        hexmask.long.byte 0x00 16.--22. 1. " DWTHR ,Down threshold for load tracking"
        textline "    "
        hexmask.long.byte 0x00 22.--28. 1. " UPTHR ,Upper threshold for load tracking"
width 5.
group.long 0x4++0x3
    line.long 0x00 "COUN,DVFS Counters thresholds"
        hexmask.long.byte 0x00 0.--8. 1. " UPCNT ,UP counter threshold value"
        textline "    "
        hexmask.long.byte 0x00 16.--24. 1. " DN_CNT ,Down counter threshold value"
width 5.
group.long 0x8++0x3
    line.long 0x00 "SIG1,DVFS general purpose bits weight"
        hexmask.long.byte 0x00 2.--5. 1. " WSW6 ,General purpose load tracking signal weight dvfs_w_sig[6]"
        textline "    "
        hexmask.long.byte 0x00 5.--8. 1. " WSW7 ,General purpose load tracking signal weight dvfs_w_sig[7]"
        textline "    "
        hexmask.long.byte 0x00 8.--11. 1. " WSW8 ,General purpose load tracking signal weight dvfs_w_sig[8]"
        textline "    "
        hexmask.long.byte 0x00 11.--14. 1. " WSW9 ,General purpose load tracking signal weight dvfs_w_sig[9]"
        textline "    "
        hexmask.long.byte 0x00 14.--17. 1. " WSW10 ,General purpose load tracking signal weight dvfs_w_sig[10]"
        textline "    "
        hexmask.long.byte 0x00 17.--20. 1. " WSW11 ,General purpose load tracking signal weight dvfs_w_sig[11]"
        textline "    "
        hexmask.long.byte 0x00 20.--23. 1. " WSW12 ,General purpose load tracking signal weight dvfs_w_sig[12]"
        textline "    "
        hexmask.long.byte 0x00 23.--26. 1. " WSW13 ,General purpose load tracking signal weight dvfs_w_sig[13]"
        textline "    "
        hexmask.long.byte 0x00 26.--29. 1. " WSW14 ,General purpose load tracking signal weight dvfs_w_sig[14]"
        textline "    "
        hexmask.long.byte 0x00 29.--32. 1. " WSW15 ,General purpose load tracking signal weight dvfs_w_sig[15]"
width 9.
group.long 0xc++0x3
    line.long 0x00 "DVFSSIG0,DVFS general purpose bits weight"
        hexmask.long.byte 0x00 0.--6. 1. " WSW0 ,General purpose load tracking signal weight dvfs_w_sig[0]."
        textline "        "
        hexmask.long.byte 0x00 6.--12. 1. " WSW1 ,General purpose load tracking signal weight dvfs_w_sig[1]."
        textline "        "
        hexmask.long.byte 0x00 20.--23. 1. " WSW2 ,General purpose load tracking signal weight dvfs_w_sig[2]"
        textline "        "
        hexmask.long.byte 0x00 23.--26. 1. " WSW3 ,General purpose load tracking signal weight dvfs_w_sig[3]"
        textline "        "
        hexmask.long.byte 0x00 26.--29. 1. " WSW4 ,General purpose load tracking signal weight dvfs_w_sig[4]"
        textline "        "
        hexmask.long.byte 0x00 29.--32. 1. " WSW5 ,General purpose load tracking signal weight dvfs_w_sig[5]"
width 9.
group.long 0x10++0x3
    line.long 0x00 "DVFSGPC0,DVFS general purpose bit 0 weight counter"
        hexmask.long.long 0x00 0.--17. 1. " GPBC0 ,GPBC0 - General Purpose bits Counter 0 During period of this counter the GeP bit 0 will be set and WSW0 will be added to the calculations."
        textline "        "
        bitfld.long 0x00 30. " C0ACT ,C0ACT - Counter 0 active indicator" "0,1"
        textline "        "
        bitfld.long 0x00 31. " C0STRT ,C0STRT - Counter 0 start Setting of this bit will initialize down counting of the GPC0 value." "0,1"
width 9.
group.long 0x14++0x3
    line.long 0x00 "DVFSGPC1,DVFS general purpose bit 1 weight counter"
        hexmask.long.long 0x00 0.--17. 1. " GPBC1 ,GPBC1 - General Purpose bits Counter 1 During period of this counter the GeP bit 1 will be set and WSW1 will be added to the calculations."
        textline "        "
        bitfld.long 0x00 30. " C1ACT ,C1ACT - Counter 1 active indicator" "0,1"
        textline "        "
        bitfld.long 0x00 31. " C1STRT ,C1STRT - Counter 1start Setting of this bit will initialize down counting of the GPC1 value." "0,1"
width 9.
group.long 0x18++0x3
    line.long 0x00 "DVFSGPBT,DVFS general purpose bits enables"
        bitfld.long 0x00 0. " GPB0 ,General purpose bit 0." "0,1"
        textline "        "
        bitfld.long 0x00 1. " GPB1 ,General purpose bit 1." "0,1"
        textline "        "
        bitfld.long 0x00 2. " GPB2 ,General purpose bit 2." "0,1"
        textline "        "
        bitfld.long 0x00 3. " GPB3 ,General purpose bit 3." "0,1"
        textline "        "
        bitfld.long 0x00 4. " GPB4 ,General purpose bit 4." "0,1"
        textline "        "
        bitfld.long 0x00 5. " GPB5 ,General purpose bit 5." "0,1"
        textline "        "
        bitfld.long 0x00 6. " GPB6 ,General purpose bit 6." "0,1"
        textline "        "
        bitfld.long 0x00 7. " GPB7 ,General purpose bit 7." "0,1"
        textline "        "
        bitfld.long 0x00 8. " GPB8 ,General purpose bit 8." "0,1"
        textline "        "
        bitfld.long 0x00 9. " GPB9 ,General purpose bit 9." "0,1"
        textline "        "
        bitfld.long 0x00 10. " GPB10 ,General purpose bit 10." "0,1"
        textline "        "
        bitfld.long 0x00 11. " GPB11 ,General purpose bit 11." "0,1"
        textline "        "
        bitfld.long 0x00 12. " GPB12 ,General purpose bit 12." "0,1"
        textline "        "
        bitfld.long 0x00 13. " GPB13 ,General purpose bit 13." "0,1"
        textline "        "
        bitfld.long 0x00 14. " GPB14 ,General purpose bit 14." "0,1"
        textline "        "
        bitfld.long 0x00 15. " GPB15 ,General purpose bit 15." "0,1"
width 9.
group.long 0x1c++0x3
    line.long 0x00 "DVFSEMAC,DVFS EMAC settings"
        hexmask.long.word 0x00 0.--9. 1. " EMAC ,EMAC - EMA control value"
        textline "        "
        bitfld.long 0x00 9. " DVFEN0 ,DVFS tracking for core0 enable." "0,1"
        textline "        "
        hexmask.long.byte 0x00 16.--18. 1. " FSVAI0 ,DVFS Frequency adjustment status of core 0."
        textline "        "
        bitfld.long 0x00 24. " WFIM0 ,DVFS Wait for Interrupt of core 0 mask bit" "0,1"
width 5.
group.long 0x20++0x3
    line.long 0x00 "CNTR,DVFS Control"
        hexmask.long.byte 0x00 3.--5. 1. " LTBRSR ,LTBRSR - Load Tracking Buffer Register Source:"
        textline "    "
        bitfld.long 0x00 5. " LTBRSH ,LTBRSH - Load Tracking Buffer Register Shift:" "0,1"
        textline "    "
        hexmask.long.byte 0x00 6.--9. 1. " PFUS ,PFUS - Periodic Frequency Update Status"
        textline "    "
        bitfld.long 0x00 9. " PFUE ,PFUE - Period Frequency Update Enable" "0,1"
        textline "    "
        hexmask.long.byte 0x00 11.--17. 1. " DIV_RATIO ,DIV_RATIO - Divider value."
        textline "    "
        bitfld.long 0x00 17. " MINF ,Minimum frequency reached." "0,1"
        textline "    "
        bitfld.long 0x00 18. " MAXF ,Maximum frequency reached." "0,1"
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " FSVAI ,FSVAI DVFS Frequency adjustment interrupt."
        textline "    "
        bitfld.long 0x00 22. " FSVAIM ,DVFS Frequency adjustment interrupt mask." "0,1"
        textline "    "
        bitfld.long 0x00 23. " PIRQS ,PIRQS - Pattern IRQ Source * write '1' to clear." "0,1"
        textline "    "
        bitfld.long 0x00 24. " DVFIS ,DVFS Interrupt select." "0,1"
        textline "    "
        bitfld.long 0x00 25. " LBFL0 ,Load buffer 0 - full status bit." "0,1"
        textline "    "
        bitfld.long 0x00 26. " LBFL1 ,Load buffer 1 - full status bit." "0,1"
        textline "    "
        bitfld.long 0x00 27. " LBMI ,Load buffer full mask interrupt." "0,1"
        textline "    "
        bitfld.long 0x00 28. " DVFEV ,Always give a DVFS event." "0,1"
        textline "    "
        hexmask.long.byte 0x00 29.--32. 1. " DIV3CK ,DIV3CK - div_3_clk division ratio inside the DVFS module."
width 11.
rgroup.long 0x24++0x3
    line.long 0x00 "DVFSLTR0_0,DVFS Load Tracking Register 0, portion 0"
        hexmask.long.byte 0x00 0.--4. 1. " LTS0_0 ,core 0 Load Tracking Sample 0"
        textline "          "
        hexmask.long.byte 0x00 4.--8. 1. " LTS0_1 ,core 0 Load Tracking Sample 1"
        textline "          "
        hexmask.long.byte 0x00 8.--12. 1. " LTS0_2 ,core 0 Load Tracking Sample 2"
        textline "          "
        hexmask.long.byte 0x00 12.--16. 1. " LTS0_3 ,core 0 Load Tracking Sample 3"
        textline "          "
        hexmask.long.byte 0x00 16.--20. 1. " LTS0_4 ,core 0 Load Tracking Sample 4"
        textline "          "
        hexmask.long.byte 0x00 20.--24. 1. " LTS0_5 ,core 0 Load Tracking Sample 5"
        textline "          "
        hexmask.long.byte 0x00 24.--28. 1. " LTS0_6 ,core 0 Load Tracking Sample 6"
        textline "          "
        hexmask.long.byte 0x00 28.--32. 1. " LTS0_7 ,core 0 Load Tracking Sample 7"
width 11.
rgroup.long 0x28++0x3
    line.long 0x00 "DVFSLTR0_1,DVFS Load Tracking Register 0, portion 1"
        hexmask.long.byte 0x00 0.--4. 1. " LTS0_8 ,core 0 Load Tracking Sample 8"
        textline "          "
        hexmask.long.byte 0x00 4.--8. 1. " LTS0_9 ,core 0 Load Tracking Sample 9"
        textline "          "
        hexmask.long.byte 0x00 8.--12. 1. " LTS0_10 ,core 0 Load Tracking Sample 10"
        textline "          "
        hexmask.long.byte 0x00 12.--16. 1. " LTS0_11 ,core 0 Load Tracking Sample 11"
        textline "          "
        hexmask.long.byte 0x00 16.--20. 1. " LTS0_12 ,core 0 Load Tracking Sample 12"
        textline "          "
        hexmask.long.byte 0x00 20.--24. 1. " LTS0_13 ,core 0 Load Tracking Sample 13"
        textline "          "
        hexmask.long.byte 0x00 24.--28. 1. " LTS0_14 ,core 0 Load Tracking Sample 14"
        textline "          "
        hexmask.long.byte 0x00 28.--32. 1. " LTS0_15 ,core 0 Load Tracking Sample 15"
width 11.
rgroup.long 0x2c++0x3
    line.long 0x00 "DVFSLTR1_0,DVFS Load Tracking Register 1, portion 0"
        hexmask.long.byte 0x00 0.--4. 1. " LTS1_0 ,core 0 Load Tracking Sample 0"
        textline "          "
        hexmask.long.byte 0x00 4.--8. 1. " LTS1_1 ,core 0 Load Tracking Sample 1"
        textline "          "
        hexmask.long.byte 0x00 8.--12. 1. " LTS1_2 ,core 0 Load Tracking Sample 2"
        textline "          "
        hexmask.long.byte 0x00 12.--16. 1. " LTS1_3 ,core 0 Load Tracking Sample 3"
        textline "          "
        hexmask.long.byte 0x00 16.--20. 1. " LTS1_4 ,core 0 Load Tracking Sample 4"
        textline "          "
        hexmask.long.byte 0x00 20.--24. 1. " LTS1_5 ,core 0 Load Tracking Sample 5"
        textline "          "
        hexmask.long.byte 0x00 24.--28. 1. " LTS1_6 ,core 0 Load Tracking Sample 6"
        textline "          "
        hexmask.long.byte 0x00 28.--32. 1. " LTS1_7 ,core 0 Load Tracking Sample 7"
width 11.
rgroup.long 0x30++0x3
    line.long 0x00 "DVFSLTR1_1,DVFS Load Tracking Register 3, portion 1"
        hexmask.long.byte 0x00 0.--4. 1. " LTS1_8 ,core 0 Load Tracking Sample 8"
        textline "          "
        hexmask.long.byte 0x00 4.--8. 1. " LTS1_9 ,core 0 Load Tracking Sample 9"
        textline "          "
        hexmask.long.byte 0x00 8.--12. 1. " LTS1_10 ,core 0 Load Tracking Sample 10"
        textline "          "
        hexmask.long.byte 0x00 12.--16. 1. " LTS1_11 ,core 0 Load Tracking Sample 11"
        textline "          "
        hexmask.long.byte 0x00 16.--20. 1. " LTS1_12 ,core 0 Load Tracking Sample 12"
        textline "          "
        hexmask.long.byte 0x00 20.--24. 1. " LTS1_13 ,core 0 Load Tracking Sample 13"
        textline "          "
        hexmask.long.byte 0x00 24.--28. 1. " LTS1_14 ,core 0 Load Tracking Sample 14"
        textline "          "
        hexmask.long.byte 0x00 28.--32. 1. " LTS1_15 ,core 0 Load Tracking Sample 15"
width 8.
group.long 0x34++0x3
    line.long 0x00 "DVFSPT0,DVFS pattern 0 length"
        hexmask.long.long 0x00 0.--17. 1. " FPTN0 ,FPTN0 - Frequency pattern 0 counter During period of this counter the frequency will be reduced from the EMA-detected level."
        textline "       "
        bitfld.long 0x00 17. " PT0A ,PT0A - Pattern 0 currently active (read-only)" "0,1"
width 8.
group.long 0x38++0x3
    line.long 0x00 "DVFSPT1,DVFS pattern 1 length"
        hexmask.long.long 0x00 0.--17. 1. " FPTN1 ,FPTN1 - Frequency pattern 1 counter During period of this counter the frequency will be set to the EMA-detected level."
        textline "       "
        bitfld.long 0x00 17. " PT1A ,PT1A - Pattern 1 currently active (read-only)" "0,1"
width 8.
group.long 0x3c++0x3
    line.long 0x00 "DVFSPT2,DVFS pattern 2 length"
        hexmask.long.long 0x00 0.--17. 1. " FPTN2 ,FPTN2 - Frequency pattern 2 counter During period of this counter the frequency will be increased to higher, than detected by the EMA-detected level."
        textline "       "
        bitfld.long 0x00 17. " PT2A ,PT2A - Pattern 2 currently active (read-only)" "0,1"
        textline "       "
        hexmask.long.byte 0x00 26.--32. 1. " P2THR ,P2THR - Pattern 2 Threshold Threshold of current DVFS load (after EMA), for generating interrupts with PFUS indicators 110, 111."
width 8.
group.long 0x40++0x3
    line.long 0x00 "DVFSPT3,DVFS pattern 3 length"
        hexmask.long.long 0x00 0.--17. 1. " FPTN3 ,FPTN3 - Frequency pattern 3 counter During period of this counter the frequency will be set to the EMA-detected level."
        textline "       "
        bitfld.long 0x00 17. " PT3A ,PT3A - Pattern 3 currently active (read-only)" "0,1"


tree.end



;--------------------------------------------------------------------------------
; ECSPI
;--------------------------------------------------------------------------------
tree.open "ECSPI"
    tree "ECSPI1"
        base ad:0x02008000

width 7.
rgroup.long 0x0++0x3
    line.long 0x00 "RXDATA,Receive Data Register"
        hexmask.long.long 0x00 0.--32. 1. " ECSPI_RXDATA ,Receive Data."
width 7.
wgroup.long 0x4++0x3
    line.long 0x00 "TXDATA,Transmit Data Register"
        hexmask.long.long 0x00 0.--32. 1. " ECSPI_TXDATA ,Transmit Data."
width 7.
group.long 0x8++0x3
    line.long 0x00 "CONREG,Control Register"
        bitfld.long 0x00 0. " EN ,SPI Block Enable Control." "0,1"
        textline "      "
        bitfld.long 0x00 1. " HT ,Hardware Trigger Enable." "0,1"
        textline "      "
        bitfld.long 0x00 2. " XCH ,SPI Exchange Bit." "0,1"
        textline "      "
        bitfld.long 0x00 3. " SMC ,Start Mode Control." "0,1"
        textline "      "
        hexmask.long.byte 0x00 4.--8. 1. " CHANNEL_MODE ,SPI CHANNEL MODE selects the mode for each SPI channel."
        textline "      "
        hexmask.long.byte 0x00 8.--12. 1. " POST_DIVIDER ,SPI Post Divider."
        textline "      "
        hexmask.long.byte 0x00 12.--16. 1. " PRE_DIVIDER ,SPI Pre Divider."
        textline "      "
        hexmask.long.byte 0x00 16.--18. 1. " DRCTL ,SPI Data Ready Control."
        textline "      "
        hexmask.long.byte 0x00 18.--20. 1. " CHANNEL_SELECT ,SPI CHANNEL SELECT bits."
        textline "      "
        hexmask.long.word 0x00 20.--32. 1. " BURST_LENGTH ,Burst Length."
width 10.
group.long 0xc++0x3
    line.long 0x00 "CONFIGREG,Config Register"
        hexmask.long.byte 0x00 0.--4. 1. " SCLK_PHA ,SPI Clock/Data Phase Control."
        textline "         "
        hexmask.long.byte 0x00 4.--8. 1. " SCLK_POL ,SPI Clock Polarity Control."
        textline "         "
        hexmask.long.byte 0x00 8.--12. 1. " SS_CTL ,SPI SS Wave Form Select."
        textline "         "
        hexmask.long.byte 0x00 12.--16. 1. " SS_POL ,SPI SS Polarity Select."
        textline "         "
        hexmask.long.byte 0x00 16.--20. 1. " DATA_CTL ,DATA CTL."
        textline "         "
        hexmask.long.byte 0x00 20.--24. 1. " SCLK_CTL ,SCLK CTL."
        textline "         "
        hexmask.long.byte 0x00 24.--29. 1. " HT_LENGTH ,HT LENGTH."
width 7.
group.long 0x10++0x3
    line.long 0x00 "INTREG,Interrupt Control Register"
        bitfld.long 0x00 0. " TEEN ,TXFIFO Empty Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 1. " TDREN ,TXFIFO Data Request Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 2. " TFEN ,TXFIFO Full Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 3. " RREN ,RXFIFO Ready Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 4. " RDREN ,RXFIFO Data Request Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 5. " RFEN ,RXFIFO Full Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 6. " ROEN ,RXFIFO Overflow Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 7. " TCEN ,Transfer Completed Interrupt enable." "0,1"
width 7.
group.long 0x14++0x3
    line.long 0x00 "DMAREG,DMA Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " TX_THRESHOLD ,TX THRESHOLD."
        textline "      "
        bitfld.long 0x00 7. " TEDEN ,TXFIFO Empty DMA Request Enable." "0,1"
        textline "      "
        hexmask.long.byte 0x00 16.--22. 1. " RX_THRESHOLD ,RX THRESHOLD."
        textline "      "
        bitfld.long 0x00 23. " RXDEN ,RXFIFO DMA Request Enable." "0,1"
        textline "      "
        hexmask.long.byte 0x00 24.--30. 1. " RX_DMA_LENGTH ,RX DMA LENGTH."
        textline "      "
        bitfld.long 0x00 31. " RXTDEN ,RXFIFO TAIL DMA Request Enable." "0,1"
width 8.
group.long 0x18++0x3
    line.long 0x00 "STATREG,Status Register"
        bitfld.long 0x00 0. " TE ,TXFIFO Empty." "0,1"
        textline "       "
        bitfld.long 0x00 1. " TDR ,TXFIFO Data Request." "0,1"
        textline "       "
        bitfld.long 0x00 2. " TF ,TXFIFO Full." "0,1"
        textline "       "
        bitfld.long 0x00 3. " RR ,RXFIFO Ready." "0,1"
        textline "       "
        bitfld.long 0x00 4. " RDR ,RXFIFO Data Request." "0,1"
        textline "       "
        bitfld.long 0x00 5. " RF ,RXFIFO Full." "0,1"
        textline "       "
        bitfld.long 0x00 6. " RO ,RXFIFO Overflow." "0,1"
        textline "       "
        bitfld.long 0x00 7. " TC ,Transfer Completed Status bit." "0,1"
width 10.
group.long 0x1c++0x3
    line.long 0x00 "PERIODREG,Sample Period Control Register"
        hexmask.long.word 0x00 0.--15. 1. " SAMPLE_PERIOD ,Sample Period Control."
        textline "         "
        bitfld.long 0x00 15. " CSRC ,Clock Source Control." "0,1"
        textline "         "
        hexmask.long.byte 0x00 16.--22. 1. " CSD_CTL ,Chip Select Delay Control bits."
width 8.
group.long 0x20++0x3
    line.long 0x00 "TESTREG,Test Control Register"
        hexmask.long.byte 0x00 0.--7. 1. " TXCNT ,TXFIFO Counter."
        textline "       "
        hexmask.long.byte 0x00 8.--15. 1. " RXCNT ,RXFIFO Counter."
        textline "       "
        bitfld.long 0x00 31. " LBC ,Loop Back Control." "0,1"
width 8.
wgroup.long 0x40++0x3
    line.long 0x00 "MSGDATA,Message Data Register"
        hexmask.long.long 0x00 0.--32. 1. " ECSPI_MSGDATA ,ECSPI_MSGDATA holds the top word of MSG Data FIFO."


    tree.end
    tree "ECSPI2"
        base ad:0x0200c000

width 7.
rgroup.long 0x0++0x3
    line.long 0x00 "RXDATA,Receive Data Register"
        hexmask.long.long 0x00 0.--32. 1. " ECSPI_RXDATA ,Receive Data."
width 7.
wgroup.long 0x4++0x3
    line.long 0x00 "TXDATA,Transmit Data Register"
        hexmask.long.long 0x00 0.--32. 1. " ECSPI_TXDATA ,Transmit Data."
width 7.
group.long 0x8++0x3
    line.long 0x00 "CONREG,Control Register"
        bitfld.long 0x00 0. " EN ,SPI Block Enable Control." "0,1"
        textline "      "
        bitfld.long 0x00 1. " HT ,Hardware Trigger Enable." "0,1"
        textline "      "
        bitfld.long 0x00 2. " XCH ,SPI Exchange Bit." "0,1"
        textline "      "
        bitfld.long 0x00 3. " SMC ,Start Mode Control." "0,1"
        textline "      "
        hexmask.long.byte 0x00 4.--8. 1. " CHANNEL_MODE ,SPI CHANNEL MODE selects the mode for each SPI channel."
        textline "      "
        hexmask.long.byte 0x00 8.--12. 1. " POST_DIVIDER ,SPI Post Divider."
        textline "      "
        hexmask.long.byte 0x00 12.--16. 1. " PRE_DIVIDER ,SPI Pre Divider."
        textline "      "
        hexmask.long.byte 0x00 16.--18. 1. " DRCTL ,SPI Data Ready Control."
        textline "      "
        hexmask.long.byte 0x00 18.--20. 1. " CHANNEL_SELECT ,SPI CHANNEL SELECT bits."
        textline "      "
        hexmask.long.word 0x00 20.--32. 1. " BURST_LENGTH ,Burst Length."
width 10.
group.long 0xc++0x3
    line.long 0x00 "CONFIGREG,Config Register"
        hexmask.long.byte 0x00 0.--4. 1. " SCLK_PHA ,SPI Clock/Data Phase Control."
        textline "         "
        hexmask.long.byte 0x00 4.--8. 1. " SCLK_POL ,SPI Clock Polarity Control."
        textline "         "
        hexmask.long.byte 0x00 8.--12. 1. " SS_CTL ,SPI SS Wave Form Select."
        textline "         "
        hexmask.long.byte 0x00 12.--16. 1. " SS_POL ,SPI SS Polarity Select."
        textline "         "
        hexmask.long.byte 0x00 16.--20. 1. " DATA_CTL ,DATA CTL."
        textline "         "
        hexmask.long.byte 0x00 20.--24. 1. " SCLK_CTL ,SCLK CTL."
        textline "         "
        hexmask.long.byte 0x00 24.--29. 1. " HT_LENGTH ,HT LENGTH."
width 7.
group.long 0x10++0x3
    line.long 0x00 "INTREG,Interrupt Control Register"
        bitfld.long 0x00 0. " TEEN ,TXFIFO Empty Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 1. " TDREN ,TXFIFO Data Request Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 2. " TFEN ,TXFIFO Full Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 3. " RREN ,RXFIFO Ready Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 4. " RDREN ,RXFIFO Data Request Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 5. " RFEN ,RXFIFO Full Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 6. " ROEN ,RXFIFO Overflow Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 7. " TCEN ,Transfer Completed Interrupt enable." "0,1"
width 7.
group.long 0x14++0x3
    line.long 0x00 "DMAREG,DMA Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " TX_THRESHOLD ,TX THRESHOLD."
        textline "      "
        bitfld.long 0x00 7. " TEDEN ,TXFIFO Empty DMA Request Enable." "0,1"
        textline "      "
        hexmask.long.byte 0x00 16.--22. 1. " RX_THRESHOLD ,RX THRESHOLD."
        textline "      "
        bitfld.long 0x00 23. " RXDEN ,RXFIFO DMA Request Enable." "0,1"
        textline "      "
        hexmask.long.byte 0x00 24.--30. 1. " RX_DMA_LENGTH ,RX DMA LENGTH."
        textline "      "
        bitfld.long 0x00 31. " RXTDEN ,RXFIFO TAIL DMA Request Enable." "0,1"
width 8.
group.long 0x18++0x3
    line.long 0x00 "STATREG,Status Register"
        bitfld.long 0x00 0. " TE ,TXFIFO Empty." "0,1"
        textline "       "
        bitfld.long 0x00 1. " TDR ,TXFIFO Data Request." "0,1"
        textline "       "
        bitfld.long 0x00 2. " TF ,TXFIFO Full." "0,1"
        textline "       "
        bitfld.long 0x00 3. " RR ,RXFIFO Ready." "0,1"
        textline "       "
        bitfld.long 0x00 4. " RDR ,RXFIFO Data Request." "0,1"
        textline "       "
        bitfld.long 0x00 5. " RF ,RXFIFO Full." "0,1"
        textline "       "
        bitfld.long 0x00 6. " RO ,RXFIFO Overflow." "0,1"
        textline "       "
        bitfld.long 0x00 7. " TC ,Transfer Completed Status bit." "0,1"
width 10.
group.long 0x1c++0x3
    line.long 0x00 "PERIODREG,Sample Period Control Register"
        hexmask.long.word 0x00 0.--15. 1. " SAMPLE_PERIOD ,Sample Period Control."
        textline "         "
        bitfld.long 0x00 15. " CSRC ,Clock Source Control." "0,1"
        textline "         "
        hexmask.long.byte 0x00 16.--22. 1. " CSD_CTL ,Chip Select Delay Control bits."
width 8.
group.long 0x20++0x3
    line.long 0x00 "TESTREG,Test Control Register"
        hexmask.long.byte 0x00 0.--7. 1. " TXCNT ,TXFIFO Counter."
        textline "       "
        hexmask.long.byte 0x00 8.--15. 1. " RXCNT ,RXFIFO Counter."
        textline "       "
        bitfld.long 0x00 31. " LBC ,Loop Back Control." "0,1"
width 8.
wgroup.long 0x40++0x3
    line.long 0x00 "MSGDATA,Message Data Register"
        hexmask.long.long 0x00 0.--32. 1. " ECSPI_MSGDATA ,ECSPI_MSGDATA holds the top word of MSG Data FIFO."


    tree.end
    tree "ECSPI3"
        base ad:0x02010000

width 7.
rgroup.long 0x0++0x3
    line.long 0x00 "RXDATA,Receive Data Register"
        hexmask.long.long 0x00 0.--32. 1. " ECSPI_RXDATA ,Receive Data."
width 7.
wgroup.long 0x4++0x3
    line.long 0x00 "TXDATA,Transmit Data Register"
        hexmask.long.long 0x00 0.--32. 1. " ECSPI_TXDATA ,Transmit Data."
width 7.
group.long 0x8++0x3
    line.long 0x00 "CONREG,Control Register"
        bitfld.long 0x00 0. " EN ,SPI Block Enable Control." "0,1"
        textline "      "
        bitfld.long 0x00 1. " HT ,Hardware Trigger Enable." "0,1"
        textline "      "
        bitfld.long 0x00 2. " XCH ,SPI Exchange Bit." "0,1"
        textline "      "
        bitfld.long 0x00 3. " SMC ,Start Mode Control." "0,1"
        textline "      "
        hexmask.long.byte 0x00 4.--8. 1. " CHANNEL_MODE ,SPI CHANNEL MODE selects the mode for each SPI channel."
        textline "      "
        hexmask.long.byte 0x00 8.--12. 1. " POST_DIVIDER ,SPI Post Divider."
        textline "      "
        hexmask.long.byte 0x00 12.--16. 1. " PRE_DIVIDER ,SPI Pre Divider."
        textline "      "
        hexmask.long.byte 0x00 16.--18. 1. " DRCTL ,SPI Data Ready Control."
        textline "      "
        hexmask.long.byte 0x00 18.--20. 1. " CHANNEL_SELECT ,SPI CHANNEL SELECT bits."
        textline "      "
        hexmask.long.word 0x00 20.--32. 1. " BURST_LENGTH ,Burst Length."
width 10.
group.long 0xc++0x3
    line.long 0x00 "CONFIGREG,Config Register"
        hexmask.long.byte 0x00 0.--4. 1. " SCLK_PHA ,SPI Clock/Data Phase Control."
        textline "         "
        hexmask.long.byte 0x00 4.--8. 1. " SCLK_POL ,SPI Clock Polarity Control."
        textline "         "
        hexmask.long.byte 0x00 8.--12. 1. " SS_CTL ,SPI SS Wave Form Select."
        textline "         "
        hexmask.long.byte 0x00 12.--16. 1. " SS_POL ,SPI SS Polarity Select."
        textline "         "
        hexmask.long.byte 0x00 16.--20. 1. " DATA_CTL ,DATA CTL."
        textline "         "
        hexmask.long.byte 0x00 20.--24. 1. " SCLK_CTL ,SCLK CTL."
        textline "         "
        hexmask.long.byte 0x00 24.--29. 1. " HT_LENGTH ,HT LENGTH."
width 7.
group.long 0x10++0x3
    line.long 0x00 "INTREG,Interrupt Control Register"
        bitfld.long 0x00 0. " TEEN ,TXFIFO Empty Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 1. " TDREN ,TXFIFO Data Request Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 2. " TFEN ,TXFIFO Full Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 3. " RREN ,RXFIFO Ready Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 4. " RDREN ,RXFIFO Data Request Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 5. " RFEN ,RXFIFO Full Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 6. " ROEN ,RXFIFO Overflow Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 7. " TCEN ,Transfer Completed Interrupt enable." "0,1"
width 7.
group.long 0x14++0x3
    line.long 0x00 "DMAREG,DMA Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " TX_THRESHOLD ,TX THRESHOLD."
        textline "      "
        bitfld.long 0x00 7. " TEDEN ,TXFIFO Empty DMA Request Enable." "0,1"
        textline "      "
        hexmask.long.byte 0x00 16.--22. 1. " RX_THRESHOLD ,RX THRESHOLD."
        textline "      "
        bitfld.long 0x00 23. " RXDEN ,RXFIFO DMA Request Enable." "0,1"
        textline "      "
        hexmask.long.byte 0x00 24.--30. 1. " RX_DMA_LENGTH ,RX DMA LENGTH."
        textline "      "
        bitfld.long 0x00 31. " RXTDEN ,RXFIFO TAIL DMA Request Enable." "0,1"
width 8.
group.long 0x18++0x3
    line.long 0x00 "STATREG,Status Register"
        bitfld.long 0x00 0. " TE ,TXFIFO Empty." "0,1"
        textline "       "
        bitfld.long 0x00 1. " TDR ,TXFIFO Data Request." "0,1"
        textline "       "
        bitfld.long 0x00 2. " TF ,TXFIFO Full." "0,1"
        textline "       "
        bitfld.long 0x00 3. " RR ,RXFIFO Ready." "0,1"
        textline "       "
        bitfld.long 0x00 4. " RDR ,RXFIFO Data Request." "0,1"
        textline "       "
        bitfld.long 0x00 5. " RF ,RXFIFO Full." "0,1"
        textline "       "
        bitfld.long 0x00 6. " RO ,RXFIFO Overflow." "0,1"
        textline "       "
        bitfld.long 0x00 7. " TC ,Transfer Completed Status bit." "0,1"
width 10.
group.long 0x1c++0x3
    line.long 0x00 "PERIODREG,Sample Period Control Register"
        hexmask.long.word 0x00 0.--15. 1. " SAMPLE_PERIOD ,Sample Period Control."
        textline "         "
        bitfld.long 0x00 15. " CSRC ,Clock Source Control." "0,1"
        textline "         "
        hexmask.long.byte 0x00 16.--22. 1. " CSD_CTL ,Chip Select Delay Control bits."
width 8.
group.long 0x20++0x3
    line.long 0x00 "TESTREG,Test Control Register"
        hexmask.long.byte 0x00 0.--7. 1. " TXCNT ,TXFIFO Counter."
        textline "       "
        hexmask.long.byte 0x00 8.--15. 1. " RXCNT ,RXFIFO Counter."
        textline "       "
        bitfld.long 0x00 31. " LBC ,Loop Back Control." "0,1"
width 8.
wgroup.long 0x40++0x3
    line.long 0x00 "MSGDATA,Message Data Register"
        hexmask.long.long 0x00 0.--32. 1. " ECSPI_MSGDATA ,ECSPI_MSGDATA holds the top word of MSG Data FIFO."


    tree.end
    tree "ECSPI4"
        base ad:0x02014000

width 7.
rgroup.long 0x0++0x3
    line.long 0x00 "RXDATA,Receive Data Register"
        hexmask.long.long 0x00 0.--32. 1. " ECSPI_RXDATA ,Receive Data."
width 7.
wgroup.long 0x4++0x3
    line.long 0x00 "TXDATA,Transmit Data Register"
        hexmask.long.long 0x00 0.--32. 1. " ECSPI_TXDATA ,Transmit Data."
width 7.
group.long 0x8++0x3
    line.long 0x00 "CONREG,Control Register"
        bitfld.long 0x00 0. " EN ,SPI Block Enable Control." "0,1"
        textline "      "
        bitfld.long 0x00 1. " HT ,Hardware Trigger Enable." "0,1"
        textline "      "
        bitfld.long 0x00 2. " XCH ,SPI Exchange Bit." "0,1"
        textline "      "
        bitfld.long 0x00 3. " SMC ,Start Mode Control." "0,1"
        textline "      "
        hexmask.long.byte 0x00 4.--8. 1. " CHANNEL_MODE ,SPI CHANNEL MODE selects the mode for each SPI channel."
        textline "      "
        hexmask.long.byte 0x00 8.--12. 1. " POST_DIVIDER ,SPI Post Divider."
        textline "      "
        hexmask.long.byte 0x00 12.--16. 1. " PRE_DIVIDER ,SPI Pre Divider."
        textline "      "
        hexmask.long.byte 0x00 16.--18. 1. " DRCTL ,SPI Data Ready Control."
        textline "      "
        hexmask.long.byte 0x00 18.--20. 1. " CHANNEL_SELECT ,SPI CHANNEL SELECT bits."
        textline "      "
        hexmask.long.word 0x00 20.--32. 1. " BURST_LENGTH ,Burst Length."
width 10.
group.long 0xc++0x3
    line.long 0x00 "CONFIGREG,Config Register"
        hexmask.long.byte 0x00 0.--4. 1. " SCLK_PHA ,SPI Clock/Data Phase Control."
        textline "         "
        hexmask.long.byte 0x00 4.--8. 1. " SCLK_POL ,SPI Clock Polarity Control."
        textline "         "
        hexmask.long.byte 0x00 8.--12. 1. " SS_CTL ,SPI SS Wave Form Select."
        textline "         "
        hexmask.long.byte 0x00 12.--16. 1. " SS_POL ,SPI SS Polarity Select."
        textline "         "
        hexmask.long.byte 0x00 16.--20. 1. " DATA_CTL ,DATA CTL."
        textline "         "
        hexmask.long.byte 0x00 20.--24. 1. " SCLK_CTL ,SCLK CTL."
        textline "         "
        hexmask.long.byte 0x00 24.--29. 1. " HT_LENGTH ,HT LENGTH."
width 7.
group.long 0x10++0x3
    line.long 0x00 "INTREG,Interrupt Control Register"
        bitfld.long 0x00 0. " TEEN ,TXFIFO Empty Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 1. " TDREN ,TXFIFO Data Request Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 2. " TFEN ,TXFIFO Full Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 3. " RREN ,RXFIFO Ready Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 4. " RDREN ,RXFIFO Data Request Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 5. " RFEN ,RXFIFO Full Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 6. " ROEN ,RXFIFO Overflow Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 7. " TCEN ,Transfer Completed Interrupt enable." "0,1"
width 7.
group.long 0x14++0x3
    line.long 0x00 "DMAREG,DMA Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " TX_THRESHOLD ,TX THRESHOLD."
        textline "      "
        bitfld.long 0x00 7. " TEDEN ,TXFIFO Empty DMA Request Enable." "0,1"
        textline "      "
        hexmask.long.byte 0x00 16.--22. 1. " RX_THRESHOLD ,RX THRESHOLD."
        textline "      "
        bitfld.long 0x00 23. " RXDEN ,RXFIFO DMA Request Enable." "0,1"
        textline "      "
        hexmask.long.byte 0x00 24.--30. 1. " RX_DMA_LENGTH ,RX DMA LENGTH."
        textline "      "
        bitfld.long 0x00 31. " RXTDEN ,RXFIFO TAIL DMA Request Enable." "0,1"
width 8.
group.long 0x18++0x3
    line.long 0x00 "STATREG,Status Register"
        bitfld.long 0x00 0. " TE ,TXFIFO Empty." "0,1"
        textline "       "
        bitfld.long 0x00 1. " TDR ,TXFIFO Data Request." "0,1"
        textline "       "
        bitfld.long 0x00 2. " TF ,TXFIFO Full." "0,1"
        textline "       "
        bitfld.long 0x00 3. " RR ,RXFIFO Ready." "0,1"
        textline "       "
        bitfld.long 0x00 4. " RDR ,RXFIFO Data Request." "0,1"
        textline "       "
        bitfld.long 0x00 5. " RF ,RXFIFO Full." "0,1"
        textline "       "
        bitfld.long 0x00 6. " RO ,RXFIFO Overflow." "0,1"
        textline "       "
        bitfld.long 0x00 7. " TC ,Transfer Completed Status bit." "0,1"
width 10.
group.long 0x1c++0x3
    line.long 0x00 "PERIODREG,Sample Period Control Register"
        hexmask.long.word 0x00 0.--15. 1. " SAMPLE_PERIOD ,Sample Period Control."
        textline "         "
        bitfld.long 0x00 15. " CSRC ,Clock Source Control." "0,1"
        textline "         "
        hexmask.long.byte 0x00 16.--22. 1. " CSD_CTL ,Chip Select Delay Control bits."
width 8.
group.long 0x20++0x3
    line.long 0x00 "TESTREG,Test Control Register"
        hexmask.long.byte 0x00 0.--7. 1. " TXCNT ,TXFIFO Counter."
        textline "       "
        hexmask.long.byte 0x00 8.--15. 1. " RXCNT ,RXFIFO Counter."
        textline "       "
        bitfld.long 0x00 31. " LBC ,Loop Back Control." "0,1"
width 8.
wgroup.long 0x40++0x3
    line.long 0x00 "MSGDATA,Message Data Register"
        hexmask.long.long 0x00 0.--32. 1. " ECSPI_MSGDATA ,ECSPI_MSGDATA holds the top word of MSG Data FIFO."


    tree.end

tree.end



;--------------------------------------------------------------------------------
; EIM
;--------------------------------------------------------------------------------
tree "EIM"
    base ad:0x021b8000

width 8.
group.long 0x0++0x3
    line.long 0x00 "CS0GCR1,Chip Select n General Configuration Register 1"
        bitfld.long 0x00 0. " CSEN ,CS Enable." "0,1"
        textline "       "
        bitfld.long 0x00 1. " SWR ,Synchronous Write Data." "0,1"
        textline "       "
        bitfld.long 0x00 2. " SRD ,Synchronous Read Data." "0,1"
        textline "       "
        bitfld.long 0x00 3. " MUM ,Multiplexed Mode." "0,1"
        textline "       "
        bitfld.long 0x00 4. " WFL ,Write Fix Latency." "0,1"
        textline "       "
        bitfld.long 0x00 5. " RFL ,Read Fix Latency." "0,1"
        textline "       "
        bitfld.long 0x00 6. " CRE ,Configuration Register Enable." "0,1"
        textline "       "
        bitfld.long 0x00 7. " CREP ,Configuration Register Enable Polarity." "0,1"
        textline "       "
        hexmask.long.byte 0x00 8.--11. 1. " BL ,Burst Length."
        textline "       "
        bitfld.long 0x00 11. " WC ,Write Continuous." "0,1"
        textline "       "
        hexmask.long.byte 0x00 12.--14. 1. " BCD ,Burst Clock Divisor."
        textline "       "
        hexmask.long.byte 0x00 14.--16. 1. " BCS ,Burst Clock Start."
        textline "       "
        hexmask.long.byte 0x00 16.--19. 1. " DSZ ,Data Port Size."
        textline "       "
        bitfld.long 0x00 19. " SP ,Supervisor Protect." "0,1"
        textline "       "
        hexmask.long.byte 0x00 20.--23. 1. " CSREC ,CS Recovery."
        textline "       "
        bitfld.long 0x00 23. " AUS ,Address UnShifted." "0,1"
        textline "       "
        hexmask.long.byte 0x00 24.--27. 1. " GBC ,Gap Between Chip Selects."
        textline "       "
        bitfld.long 0x00 27. " WP ,Write Protect." "0,1"
        textline "       "
        hexmask.long.byte 0x00 28.--32. 1. " PSZ ,Page Size."
width 8.
group.long 0x4++0x3
    line.long 0x00 "CS0GCR2,Chip Select n General Configuration Register 2"
        hexmask.long.byte 0x00 0.--2. 1. " ADH ,Address hold time - This bit field determine the address hold time after ADV negation when mum = 1 (muxed mode)."
        textline "       "
        hexmask.long.byte 0x00 4.--8. 1. " DAPS ,Data Acknowledge Poling Start."
        textline "       "
        bitfld.long 0x00 8. " DAE ,Data Acknowledge Enable." "0,1"
        textline "       "
        bitfld.long 0x00 9. " DAP ,Data Acknowledge Polarity." "0,1"
        textline "       "
        bitfld.long 0x00 12. " MUX16_BYP_GRANT ,Muxed 16 bypass grant." "0,1"
width 8.
group.long 0x8++0x3
    line.long 0x00 "CS0RCR1,Chip Select n Read Configuration Register 1"
        hexmask.long.byte 0x00 0.--3. 1. " RCSN ,Read CS Negation."
        textline "       "
        hexmask.long.byte 0x00 4.--7. 1. " RCSA ,Read CS Assertion."
        textline "       "
        hexmask.long.byte 0x00 8.--11. 1. " OEN ,OE Negation."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " OEA ,OE Assertion."
        textline "       "
        hexmask.long.byte 0x00 16.--19. 1. " RADVN ,ADV Negation."
        textline "       "
        bitfld.long 0x00 19. " RAL ,Read ADV Low." "0,1"
        textline "       "
        hexmask.long.byte 0x00 20.--23. 1. " RADVA ,ADV Assertion."
        textline "       "
        hexmask.long.byte 0x00 24.--30. 1. " RWSC ,Read Wait State Control."
width 8.
group.long 0xc++0x3
    line.long 0x00 "CS0RCR2,Chip Select n Read Configuration Register 2"
        hexmask.long.byte 0x00 0.--3. 1. " RBEN ,Read BE Negation."
        textline "       "
        bitfld.long 0x00 3. " RBE ,Read BE enable." "0,1"
        textline "       "
        hexmask.long.byte 0x00 4.--7. 1. " RBEA ,Read BE Assertion."
        textline "       "
        hexmask.long.byte 0x00 8.--10. 1. " RL ,Read Latency."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " PAT ,Page Access Time."
        textline "       "
        bitfld.long 0x00 15. " APR ,Asynchronous Page Read." "0,1"
width 8.
group.long 0x10++0x3
    line.long 0x00 "CS0WCR1,Chip Select n Write Configuration Register 1"
        hexmask.long.byte 0x00 0.--3. 1. " WCSN ,Write CS Negation."
        textline "       "
        hexmask.long.byte 0x00 3.--6. 1. " WCSA ,Write CS Assertion."
        textline "       "
        hexmask.long.byte 0x00 6.--9. 1. " WEN ,WE Negation."
        textline "       "
        hexmask.long.byte 0x00 9.--12. 1. " WEA ,WE Assertion."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " WBEN ,BE[3:0] Negation."
        textline "       "
        hexmask.long.byte 0x00 15.--18. 1. " WBEA ,BE Assertion."
        textline "       "
        hexmask.long.byte 0x00 18.--21. 1. " WADVN ,ADV Negation."
        textline "       "
        hexmask.long.byte 0x00 21.--24. 1. " WADVA ,ADV Assertion."
        textline "       "
        hexmask.long.byte 0x00 24.--30. 1. " WWSC ,Write Wait State Control."
        textline "       "
        bitfld.long 0x00 30. " WBED ,Write Byte Enable Disable." "0,1"
        textline "       "
        bitfld.long 0x00 31. " WAL ,Write ADV Low." "0,1"
width 8.
group.long 0x14++0x3
    line.long 0x00 "CS0WCR2,Chip Select n Write Configuration Register 2"
        bitfld.long 0x00 0. " WBCDD ,Write Burst Clock Divisor Decrement." "0,1"
width 8.
group.long 0x18++0x3
    line.long 0x00 "CS1GCR1,Chip Select n General Configuration Register 1"
        bitfld.long 0x00 0. " CSEN ,CS Enable." "0,1"
        textline "       "
        bitfld.long 0x00 1. " SWR ,Synchronous Write Data." "0,1"
        textline "       "
        bitfld.long 0x00 2. " SRD ,Synchronous Read Data." "0,1"
        textline "       "
        bitfld.long 0x00 3. " MUM ,Multiplexed Mode." "0,1"
        textline "       "
        bitfld.long 0x00 4. " WFL ,Write Fix Latency." "0,1"
        textline "       "
        bitfld.long 0x00 5. " RFL ,Read Fix Latency." "0,1"
        textline "       "
        bitfld.long 0x00 6. " CRE ,Configuration Register Enable." "0,1"
        textline "       "
        bitfld.long 0x00 7. " CREP ,Configuration Register Enable Polarity." "0,1"
        textline "       "
        hexmask.long.byte 0x00 8.--11. 1. " BL ,Burst Length."
        textline "       "
        bitfld.long 0x00 11. " WC ,Write Continuous." "0,1"
        textline "       "
        hexmask.long.byte 0x00 12.--14. 1. " BCD ,Burst Clock Divisor."
        textline "       "
        hexmask.long.byte 0x00 14.--16. 1. " BCS ,Burst Clock Start."
        textline "       "
        hexmask.long.byte 0x00 16.--19. 1. " DSZ ,Data Port Size."
        textline "       "
        bitfld.long 0x00 19. " SP ,Supervisor Protect." "0,1"
        textline "       "
        hexmask.long.byte 0x00 20.--23. 1. " CSREC ,CS Recovery."
        textline "       "
        bitfld.long 0x00 23. " AUS ,Address UnShifted." "0,1"
        textline "       "
        hexmask.long.byte 0x00 24.--27. 1. " GBC ,Gap Between Chip Selects."
        textline "       "
        bitfld.long 0x00 27. " WP ,Write Protect." "0,1"
        textline "       "
        hexmask.long.byte 0x00 28.--32. 1. " PSZ ,Page Size."
width 8.
group.long 0x1c++0x3
    line.long 0x00 "CS1GCR2,Chip Select n General Configuration Register 2"
        hexmask.long.byte 0x00 0.--2. 1. " ADH ,Address hold time - This bit field determine the address hold time after ADV negation when mum = 1 (muxed mode)."
        textline "       "
        hexmask.long.byte 0x00 4.--8. 1. " DAPS ,Data Acknowledge Poling Start."
        textline "       "
        bitfld.long 0x00 8. " DAE ,Data Acknowledge Enable." "0,1"
        textline "       "
        bitfld.long 0x00 9. " DAP ,Data Acknowledge Polarity." "0,1"
        textline "       "
        bitfld.long 0x00 12. " MUX16_BYP_GRANT ,Muxed 16 bypass grant." "0,1"
width 8.
group.long 0x20++0x3
    line.long 0x00 "CS1RCR1,Chip Select n Read Configuration Register 1"
        hexmask.long.byte 0x00 0.--3. 1. " RCSN ,Read CS Negation."
        textline "       "
        hexmask.long.byte 0x00 4.--7. 1. " RCSA ,Read CS Assertion."
        textline "       "
        hexmask.long.byte 0x00 8.--11. 1. " OEN ,OE Negation."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " OEA ,OE Assertion."
        textline "       "
        hexmask.long.byte 0x00 16.--19. 1. " RADVN ,ADV Negation."
        textline "       "
        bitfld.long 0x00 19. " RAL ,Read ADV Low." "0,1"
        textline "       "
        hexmask.long.byte 0x00 20.--23. 1. " RADVA ,ADV Assertion."
        textline "       "
        hexmask.long.byte 0x00 24.--30. 1. " RWSC ,Read Wait State Control."
width 8.
group.long 0x24++0x3
    line.long 0x00 "CS1RCR2,Chip Select n Read Configuration Register 2"
        hexmask.long.byte 0x00 0.--3. 1. " RBEN ,Read BE Negation."
        textline "       "
        bitfld.long 0x00 3. " RBE ,Read BE enable." "0,1"
        textline "       "
        hexmask.long.byte 0x00 4.--7. 1. " RBEA ,Read BE Assertion."
        textline "       "
        hexmask.long.byte 0x00 8.--10. 1. " RL ,Read Latency."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " PAT ,Page Access Time."
        textline "       "
        bitfld.long 0x00 15. " APR ,Asynchronous Page Read." "0,1"
width 8.
group.long 0x28++0x3
    line.long 0x00 "CS1WCR1,Chip Select n Write Configuration Register 1"
        hexmask.long.byte 0x00 0.--3. 1. " WCSN ,Write CS Negation."
        textline "       "
        hexmask.long.byte 0x00 3.--6. 1. " WCSA ,Write CS Assertion."
        textline "       "
        hexmask.long.byte 0x00 6.--9. 1. " WEN ,WE Negation."
        textline "       "
        hexmask.long.byte 0x00 9.--12. 1. " WEA ,WE Assertion."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " WBEN ,BE[3:0] Negation."
        textline "       "
        hexmask.long.byte 0x00 15.--18. 1. " WBEA ,BE Assertion."
        textline "       "
        hexmask.long.byte 0x00 18.--21. 1. " WADVN ,ADV Negation."
        textline "       "
        hexmask.long.byte 0x00 21.--24. 1. " WADVA ,ADV Assertion."
        textline "       "
        hexmask.long.byte 0x00 24.--30. 1. " WWSC ,Write Wait State Control."
        textline "       "
        bitfld.long 0x00 30. " WBED ,Write Byte Enable Disable." "0,1"
        textline "       "
        bitfld.long 0x00 31. " WAL ,Write ADV Low." "0,1"
width 8.
group.long 0x2c++0x3
    line.long 0x00 "CS1WCR2,Chip Select n Write Configuration Register 2"
        bitfld.long 0x00 0. " WBCDD ,Write Burst Clock Divisor Decrement." "0,1"
width 8.
group.long 0x30++0x3
    line.long 0x00 "CS2GCR1,Chip Select n General Configuration Register 1"
        bitfld.long 0x00 0. " CSEN ,CS Enable." "0,1"
        textline "       "
        bitfld.long 0x00 1. " SWR ,Synchronous Write Data." "0,1"
        textline "       "
        bitfld.long 0x00 2. " SRD ,Synchronous Read Data." "0,1"
        textline "       "
        bitfld.long 0x00 3. " MUM ,Multiplexed Mode." "0,1"
        textline "       "
        bitfld.long 0x00 4. " WFL ,Write Fix Latency." "0,1"
        textline "       "
        bitfld.long 0x00 5. " RFL ,Read Fix Latency." "0,1"
        textline "       "
        bitfld.long 0x00 6. " CRE ,Configuration Register Enable." "0,1"
        textline "       "
        bitfld.long 0x00 7. " CREP ,Configuration Register Enable Polarity." "0,1"
        textline "       "
        hexmask.long.byte 0x00 8.--11. 1. " BL ,Burst Length."
        textline "       "
        bitfld.long 0x00 11. " WC ,Write Continuous." "0,1"
        textline "       "
        hexmask.long.byte 0x00 12.--14. 1. " BCD ,Burst Clock Divisor."
        textline "       "
        hexmask.long.byte 0x00 14.--16. 1. " BCS ,Burst Clock Start."
        textline "       "
        hexmask.long.byte 0x00 16.--19. 1. " DSZ ,Data Port Size."
        textline "       "
        bitfld.long 0x00 19. " SP ,Supervisor Protect." "0,1"
        textline "       "
        hexmask.long.byte 0x00 20.--23. 1. " CSREC ,CS Recovery."
        textline "       "
        bitfld.long 0x00 23. " AUS ,Address UnShifted." "0,1"
        textline "       "
        hexmask.long.byte 0x00 24.--27. 1. " GBC ,Gap Between Chip Selects."
        textline "       "
        bitfld.long 0x00 27. " WP ,Write Protect." "0,1"
        textline "       "
        hexmask.long.byte 0x00 28.--32. 1. " PSZ ,Page Size."
width 8.
group.long 0x34++0x3
    line.long 0x00 "CS2GCR2,Chip Select n General Configuration Register 2"
        hexmask.long.byte 0x00 0.--2. 1. " ADH ,Address hold time - This bit field determine the address hold time after ADV negation when mum = 1 (muxed mode)."
        textline "       "
        hexmask.long.byte 0x00 4.--8. 1. " DAPS ,Data Acknowledge Poling Start."
        textline "       "
        bitfld.long 0x00 8. " DAE ,Data Acknowledge Enable." "0,1"
        textline "       "
        bitfld.long 0x00 9. " DAP ,Data Acknowledge Polarity." "0,1"
        textline "       "
        bitfld.long 0x00 12. " MUX16_BYP_GRANT ,Muxed 16 bypass grant." "0,1"
width 8.
group.long 0x38++0x3
    line.long 0x00 "CS2RCR1,Chip Select n Read Configuration Register 1"
        hexmask.long.byte 0x00 0.--3. 1. " RCSN ,Read CS Negation."
        textline "       "
        hexmask.long.byte 0x00 4.--7. 1. " RCSA ,Read CS Assertion."
        textline "       "
        hexmask.long.byte 0x00 8.--11. 1. " OEN ,OE Negation."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " OEA ,OE Assertion."
        textline "       "
        hexmask.long.byte 0x00 16.--19. 1. " RADVN ,ADV Negation."
        textline "       "
        bitfld.long 0x00 19. " RAL ,Read ADV Low." "0,1"
        textline "       "
        hexmask.long.byte 0x00 20.--23. 1. " RADVA ,ADV Assertion."
        textline "       "
        hexmask.long.byte 0x00 24.--30. 1. " RWSC ,Read Wait State Control."
width 8.
group.long 0x3c++0x3
    line.long 0x00 "CS2RCR2,Chip Select n Read Configuration Register 2"
        hexmask.long.byte 0x00 0.--3. 1. " RBEN ,Read BE Negation."
        textline "       "
        bitfld.long 0x00 3. " RBE ,Read BE enable." "0,1"
        textline "       "
        hexmask.long.byte 0x00 4.--7. 1. " RBEA ,Read BE Assertion."
        textline "       "
        hexmask.long.byte 0x00 8.--10. 1. " RL ,Read Latency."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " PAT ,Page Access Time."
        textline "       "
        bitfld.long 0x00 15. " APR ,Asynchronous Page Read." "0,1"
width 8.
group.long 0x40++0x3
    line.long 0x00 "CS2WCR1,Chip Select n Write Configuration Register 1"
        hexmask.long.byte 0x00 0.--3. 1. " WCSN ,Write CS Negation."
        textline "       "
        hexmask.long.byte 0x00 3.--6. 1. " WCSA ,Write CS Assertion."
        textline "       "
        hexmask.long.byte 0x00 6.--9. 1. " WEN ,WE Negation."
        textline "       "
        hexmask.long.byte 0x00 9.--12. 1. " WEA ,WE Assertion."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " WBEN ,BE[3:0] Negation."
        textline "       "
        hexmask.long.byte 0x00 15.--18. 1. " WBEA ,BE Assertion."
        textline "       "
        hexmask.long.byte 0x00 18.--21. 1. " WADVN ,ADV Negation."
        textline "       "
        hexmask.long.byte 0x00 21.--24. 1. " WADVA ,ADV Assertion."
        textline "       "
        hexmask.long.byte 0x00 24.--30. 1. " WWSC ,Write Wait State Control."
        textline "       "
        bitfld.long 0x00 30. " WBED ,Write Byte Enable Disable." "0,1"
        textline "       "
        bitfld.long 0x00 31. " WAL ,Write ADV Low." "0,1"
width 8.
group.long 0x44++0x3
    line.long 0x00 "CS2WCR2,Chip Select n Write Configuration Register 2"
        bitfld.long 0x00 0. " WBCDD ,Write Burst Clock Divisor Decrement." "0,1"
width 8.
group.long 0x48++0x3
    line.long 0x00 "CS3GCR1,Chip Select n General Configuration Register 1"
        bitfld.long 0x00 0. " CSEN ,CS Enable." "0,1"
        textline "       "
        bitfld.long 0x00 1. " SWR ,Synchronous Write Data." "0,1"
        textline "       "
        bitfld.long 0x00 2. " SRD ,Synchronous Read Data." "0,1"
        textline "       "
        bitfld.long 0x00 3. " MUM ,Multiplexed Mode." "0,1"
        textline "       "
        bitfld.long 0x00 4. " WFL ,Write Fix Latency." "0,1"
        textline "       "
        bitfld.long 0x00 5. " RFL ,Read Fix Latency." "0,1"
        textline "       "
        bitfld.long 0x00 6. " CRE ,Configuration Register Enable." "0,1"
        textline "       "
        bitfld.long 0x00 7. " CREP ,Configuration Register Enable Polarity." "0,1"
        textline "       "
        hexmask.long.byte 0x00 8.--11. 1. " BL ,Burst Length."
        textline "       "
        bitfld.long 0x00 11. " WC ,Write Continuous." "0,1"
        textline "       "
        hexmask.long.byte 0x00 12.--14. 1. " BCD ,Burst Clock Divisor."
        textline "       "
        hexmask.long.byte 0x00 14.--16. 1. " BCS ,Burst Clock Start."
        textline "       "
        hexmask.long.byte 0x00 16.--19. 1. " DSZ ,Data Port Size."
        textline "       "
        bitfld.long 0x00 19. " SP ,Supervisor Protect." "0,1"
        textline "       "
        hexmask.long.byte 0x00 20.--23. 1. " CSREC ,CS Recovery."
        textline "       "
        bitfld.long 0x00 23. " AUS ,Address UnShifted." "0,1"
        textline "       "
        hexmask.long.byte 0x00 24.--27. 1. " GBC ,Gap Between Chip Selects."
        textline "       "
        bitfld.long 0x00 27. " WP ,Write Protect." "0,1"
        textline "       "
        hexmask.long.byte 0x00 28.--32. 1. " PSZ ,Page Size."
width 8.
group.long 0x4c++0x3
    line.long 0x00 "CS3GCR2,Chip Select n General Configuration Register 2"
        hexmask.long.byte 0x00 0.--2. 1. " ADH ,Address hold time - This bit field determine the address hold time after ADV negation when mum = 1 (muxed mode)."
        textline "       "
        hexmask.long.byte 0x00 4.--8. 1. " DAPS ,Data Acknowledge Poling Start."
        textline "       "
        bitfld.long 0x00 8. " DAE ,Data Acknowledge Enable." "0,1"
        textline "       "
        bitfld.long 0x00 9. " DAP ,Data Acknowledge Polarity." "0,1"
        textline "       "
        bitfld.long 0x00 12. " MUX16_BYP_GRANT ,Muxed 16 bypass grant." "0,1"
width 8.
group.long 0x50++0x3
    line.long 0x00 "CS3RCR1,Chip Select n Read Configuration Register 1"
        hexmask.long.byte 0x00 0.--3. 1. " RCSN ,Read CS Negation."
        textline "       "
        hexmask.long.byte 0x00 4.--7. 1. " RCSA ,Read CS Assertion."
        textline "       "
        hexmask.long.byte 0x00 8.--11. 1. " OEN ,OE Negation."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " OEA ,OE Assertion."
        textline "       "
        hexmask.long.byte 0x00 16.--19. 1. " RADVN ,ADV Negation."
        textline "       "
        bitfld.long 0x00 19. " RAL ,Read ADV Low." "0,1"
        textline "       "
        hexmask.long.byte 0x00 20.--23. 1. " RADVA ,ADV Assertion."
        textline "       "
        hexmask.long.byte 0x00 24.--30. 1. " RWSC ,Read Wait State Control."
width 8.
group.long 0x54++0x3
    line.long 0x00 "CS3RCR2,Chip Select n Read Configuration Register 2"
        hexmask.long.byte 0x00 0.--3. 1. " RBEN ,Read BE Negation."
        textline "       "
        bitfld.long 0x00 3. " RBE ,Read BE enable." "0,1"
        textline "       "
        hexmask.long.byte 0x00 4.--7. 1. " RBEA ,Read BE Assertion."
        textline "       "
        hexmask.long.byte 0x00 8.--10. 1. " RL ,Read Latency."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " PAT ,Page Access Time."
        textline "       "
        bitfld.long 0x00 15. " APR ,Asynchronous Page Read." "0,1"
width 8.
group.long 0x58++0x3
    line.long 0x00 "CS3WCR1,Chip Select n Write Configuration Register 1"
        hexmask.long.byte 0x00 0.--3. 1. " WCSN ,Write CS Negation."
        textline "       "
        hexmask.long.byte 0x00 3.--6. 1. " WCSA ,Write CS Assertion."
        textline "       "
        hexmask.long.byte 0x00 6.--9. 1. " WEN ,WE Negation."
        textline "       "
        hexmask.long.byte 0x00 9.--12. 1. " WEA ,WE Assertion."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " WBEN ,BE[3:0] Negation."
        textline "       "
        hexmask.long.byte 0x00 15.--18. 1. " WBEA ,BE Assertion."
        textline "       "
        hexmask.long.byte 0x00 18.--21. 1. " WADVN ,ADV Negation."
        textline "       "
        hexmask.long.byte 0x00 21.--24. 1. " WADVA ,ADV Assertion."
        textline "       "
        hexmask.long.byte 0x00 24.--30. 1. " WWSC ,Write Wait State Control."
        textline "       "
        bitfld.long 0x00 30. " WBED ,Write Byte Enable Disable." "0,1"
        textline "       "
        bitfld.long 0x00 31. " WAL ,Write ADV Low." "0,1"
width 8.
group.long 0x5c++0x3
    line.long 0x00 "CS3WCR2,Chip Select n Write Configuration Register 2"
        bitfld.long 0x00 0. " WBCDD ,Write Burst Clock Divisor Decrement." "0,1"
width 8.
group.long 0x60++0x3
    line.long 0x00 "CS4GCR1,Chip Select n General Configuration Register 1"
        bitfld.long 0x00 0. " CSEN ,CS Enable." "0,1"
        textline "       "
        bitfld.long 0x00 1. " SWR ,Synchronous Write Data." "0,1"
        textline "       "
        bitfld.long 0x00 2. " SRD ,Synchronous Read Data." "0,1"
        textline "       "
        bitfld.long 0x00 3. " MUM ,Multiplexed Mode." "0,1"
        textline "       "
        bitfld.long 0x00 4. " WFL ,Write Fix Latency." "0,1"
        textline "       "
        bitfld.long 0x00 5. " RFL ,Read Fix Latency." "0,1"
        textline "       "
        bitfld.long 0x00 6. " CRE ,Configuration Register Enable." "0,1"
        textline "       "
        bitfld.long 0x00 7. " CREP ,Configuration Register Enable Polarity." "0,1"
        textline "       "
        hexmask.long.byte 0x00 8.--11. 1. " BL ,Burst Length."
        textline "       "
        bitfld.long 0x00 11. " WC ,Write Continuous." "0,1"
        textline "       "
        hexmask.long.byte 0x00 12.--14. 1. " BCD ,Burst Clock Divisor."
        textline "       "
        hexmask.long.byte 0x00 14.--16. 1. " BCS ,Burst Clock Start."
        textline "       "
        hexmask.long.byte 0x00 16.--19. 1. " DSZ ,Data Port Size."
        textline "       "
        bitfld.long 0x00 19. " SP ,Supervisor Protect." "0,1"
        textline "       "
        hexmask.long.byte 0x00 20.--23. 1. " CSREC ,CS Recovery."
        textline "       "
        bitfld.long 0x00 23. " AUS ,Address UnShifted." "0,1"
        textline "       "
        hexmask.long.byte 0x00 24.--27. 1. " GBC ,Gap Between Chip Selects."
        textline "       "
        bitfld.long 0x00 27. " WP ,Write Protect." "0,1"
        textline "       "
        hexmask.long.byte 0x00 28.--32. 1. " PSZ ,Page Size."
width 8.
group.long 0x64++0x3
    line.long 0x00 "CS4GCR2,Chip Select n General Configuration Register 2"
        hexmask.long.byte 0x00 0.--2. 1. " ADH ,Address hold time - This bit field determine the address hold time after ADV negation when mum = 1 (muxed mode)."
        textline "       "
        hexmask.long.byte 0x00 4.--8. 1. " DAPS ,Data Acknowledge Poling Start."
        textline "       "
        bitfld.long 0x00 8. " DAE ,Data Acknowledge Enable." "0,1"
        textline "       "
        bitfld.long 0x00 9. " DAP ,Data Acknowledge Polarity." "0,1"
        textline "       "
        bitfld.long 0x00 12. " MUX16_BYP_GRANT ,Muxed 16 bypass grant." "0,1"
width 8.
group.long 0x68++0x3
    line.long 0x00 "CS4RCR1,Chip Select n Read Configuration Register 1"
        hexmask.long.byte 0x00 0.--3. 1. " RCSN ,Read CS Negation."
        textline "       "
        hexmask.long.byte 0x00 4.--7. 1. " RCSA ,Read CS Assertion."
        textline "       "
        hexmask.long.byte 0x00 8.--11. 1. " OEN ,OE Negation."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " OEA ,OE Assertion."
        textline "       "
        hexmask.long.byte 0x00 16.--19. 1. " RADVN ,ADV Negation."
        textline "       "
        bitfld.long 0x00 19. " RAL ,Read ADV Low." "0,1"
        textline "       "
        hexmask.long.byte 0x00 20.--23. 1. " RADVA ,ADV Assertion."
        textline "       "
        hexmask.long.byte 0x00 24.--30. 1. " RWSC ,Read Wait State Control."
width 8.
group.long 0x6c++0x3
    line.long 0x00 "CS4RCR2,Chip Select n Read Configuration Register 2"
        hexmask.long.byte 0x00 0.--3. 1. " RBEN ,Read BE Negation."
        textline "       "
        bitfld.long 0x00 3. " RBE ,Read BE enable." "0,1"
        textline "       "
        hexmask.long.byte 0x00 4.--7. 1. " RBEA ,Read BE Assertion."
        textline "       "
        hexmask.long.byte 0x00 8.--10. 1. " RL ,Read Latency."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " PAT ,Page Access Time."
        textline "       "
        bitfld.long 0x00 15. " APR ,Asynchronous Page Read." "0,1"
width 8.
group.long 0x70++0x3
    line.long 0x00 "CS4WCR1,Chip Select n Write Configuration Register 1"
        hexmask.long.byte 0x00 0.--3. 1. " WCSN ,Write CS Negation."
        textline "       "
        hexmask.long.byte 0x00 3.--6. 1. " WCSA ,Write CS Assertion."
        textline "       "
        hexmask.long.byte 0x00 6.--9. 1. " WEN ,WE Negation."
        textline "       "
        hexmask.long.byte 0x00 9.--12. 1. " WEA ,WE Assertion."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " WBEN ,BE[3:0] Negation."
        textline "       "
        hexmask.long.byte 0x00 15.--18. 1. " WBEA ,BE Assertion."
        textline "       "
        hexmask.long.byte 0x00 18.--21. 1. " WADVN ,ADV Negation."
        textline "       "
        hexmask.long.byte 0x00 21.--24. 1. " WADVA ,ADV Assertion."
        textline "       "
        hexmask.long.byte 0x00 24.--30. 1. " WWSC ,Write Wait State Control."
        textline "       "
        bitfld.long 0x00 30. " WBED ,Write Byte Enable Disable." "0,1"
        textline "       "
        bitfld.long 0x00 31. " WAL ,Write ADV Low." "0,1"
width 8.
group.long 0x74++0x3
    line.long 0x00 "CS4WCR2,Chip Select n Write Configuration Register 2"
        bitfld.long 0x00 0. " WBCDD ,Write Burst Clock Divisor Decrement." "0,1"
width 8.
group.long 0x78++0x3
    line.long 0x00 "CS5GCR1,Chip Select n General Configuration Register 1"
        bitfld.long 0x00 0. " CSEN ,CS Enable." "0,1"
        textline "       "
        bitfld.long 0x00 1. " SWR ,Synchronous Write Data." "0,1"
        textline "       "
        bitfld.long 0x00 2. " SRD ,Synchronous Read Data." "0,1"
        textline "       "
        bitfld.long 0x00 3. " MUM ,Multiplexed Mode." "0,1"
        textline "       "
        bitfld.long 0x00 4. " WFL ,Write Fix Latency." "0,1"
        textline "       "
        bitfld.long 0x00 5. " RFL ,Read Fix Latency." "0,1"
        textline "       "
        bitfld.long 0x00 6. " CRE ,Configuration Register Enable." "0,1"
        textline "       "
        bitfld.long 0x00 7. " CREP ,Configuration Register Enable Polarity." "0,1"
        textline "       "
        hexmask.long.byte 0x00 8.--11. 1. " BL ,Burst Length."
        textline "       "
        bitfld.long 0x00 11. " WC ,Write Continuous." "0,1"
        textline "       "
        hexmask.long.byte 0x00 12.--14. 1. " BCD ,Burst Clock Divisor."
        textline "       "
        hexmask.long.byte 0x00 14.--16. 1. " BCS ,Burst Clock Start."
        textline "       "
        hexmask.long.byte 0x00 16.--19. 1. " DSZ ,Data Port Size."
        textline "       "
        bitfld.long 0x00 19. " SP ,Supervisor Protect." "0,1"
        textline "       "
        hexmask.long.byte 0x00 20.--23. 1. " CSREC ,CS Recovery."
        textline "       "
        bitfld.long 0x00 23. " AUS ,Address UnShifted." "0,1"
        textline "       "
        hexmask.long.byte 0x00 24.--27. 1. " GBC ,Gap Between Chip Selects."
        textline "       "
        bitfld.long 0x00 27. " WP ,Write Protect." "0,1"
        textline "       "
        hexmask.long.byte 0x00 28.--32. 1. " PSZ ,Page Size."
width 8.
group.long 0x7c++0x3
    line.long 0x00 "CS5GCR2,Chip Select n General Configuration Register 2"
        hexmask.long.byte 0x00 0.--2. 1. " ADH ,Address hold time - This bit field determine the address hold time after ADV negation when mum = 1 (muxed mode)."
        textline "       "
        hexmask.long.byte 0x00 4.--8. 1. " DAPS ,Data Acknowledge Poling Start."
        textline "       "
        bitfld.long 0x00 8. " DAE ,Data Acknowledge Enable." "0,1"
        textline "       "
        bitfld.long 0x00 9. " DAP ,Data Acknowledge Polarity." "0,1"
        textline "       "
        bitfld.long 0x00 12. " MUX16_BYP_GRANT ,Muxed 16 bypass grant." "0,1"
width 8.
group.long 0x80++0x3
    line.long 0x00 "CS5RCR1,Chip Select n Read Configuration Register 1"
        hexmask.long.byte 0x00 0.--3. 1. " RCSN ,Read CS Negation."
        textline "       "
        hexmask.long.byte 0x00 4.--7. 1. " RCSA ,Read CS Assertion."
        textline "       "
        hexmask.long.byte 0x00 8.--11. 1. " OEN ,OE Negation."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " OEA ,OE Assertion."
        textline "       "
        hexmask.long.byte 0x00 16.--19. 1. " RADVN ,ADV Negation."
        textline "       "
        bitfld.long 0x00 19. " RAL ,Read ADV Low." "0,1"
        textline "       "
        hexmask.long.byte 0x00 20.--23. 1. " RADVA ,ADV Assertion."
        textline "       "
        hexmask.long.byte 0x00 24.--30. 1. " RWSC ,Read Wait State Control."
width 8.
group.long 0x84++0x3
    line.long 0x00 "CS5RCR2,Chip Select n Read Configuration Register 2"
        hexmask.long.byte 0x00 0.--3. 1. " RBEN ,Read BE Negation."
        textline "       "
        bitfld.long 0x00 3. " RBE ,Read BE enable." "0,1"
        textline "       "
        hexmask.long.byte 0x00 4.--7. 1. " RBEA ,Read BE Assertion."
        textline "       "
        hexmask.long.byte 0x00 8.--10. 1. " RL ,Read Latency."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " PAT ,Page Access Time."
        textline "       "
        bitfld.long 0x00 15. " APR ,Asynchronous Page Read." "0,1"
width 8.
group.long 0x88++0x3
    line.long 0x00 "CS5WCR1,Chip Select n Write Configuration Register 1"
        hexmask.long.byte 0x00 0.--3. 1. " WCSN ,Write CS Negation."
        textline "       "
        hexmask.long.byte 0x00 3.--6. 1. " WCSA ,Write CS Assertion."
        textline "       "
        hexmask.long.byte 0x00 6.--9. 1. " WEN ,WE Negation."
        textline "       "
        hexmask.long.byte 0x00 9.--12. 1. " WEA ,WE Assertion."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " WBEN ,BE[3:0] Negation."
        textline "       "
        hexmask.long.byte 0x00 15.--18. 1. " WBEA ,BE Assertion."
        textline "       "
        hexmask.long.byte 0x00 18.--21. 1. " WADVN ,ADV Negation."
        textline "       "
        hexmask.long.byte 0x00 21.--24. 1. " WADVA ,ADV Assertion."
        textline "       "
        hexmask.long.byte 0x00 24.--30. 1. " WWSC ,Write Wait State Control."
        textline "       "
        bitfld.long 0x00 30. " WBED ,Write Byte Enable Disable." "0,1"
        textline "       "
        bitfld.long 0x00 31. " WAL ,Write ADV Low." "0,1"
width 8.
group.long 0x8c++0x3
    line.long 0x00 "CS5WCR2,Chip Select n Write Configuration Register 2"
        bitfld.long 0x00 0. " WBCDD ,Write Burst Clock Divisor Decrement." "0,1"
width 4.
group.long 0x90++0x3
    line.long 0x00 "WCR,EIM Configuration Register"
        bitfld.long 0x00 0. " BCM ,Burst Clock Mode." "0,1"
        textline "   "
        hexmask.long.byte 0x00 1.--3. 1. " GBCD ,General Burst Clock Divisor."
        textline "   "
        bitfld.long 0x00 3. " CONT_BCLK_SEL ,When this bit is set BCLK pin output continuous clock." "0,1"
        textline "   "
        bitfld.long 0x00 4. " INTEN ,Interrupt Enable." "0,1"
        textline "   "
        bitfld.long 0x00 5. " INTPOL ,Interrupt Polarity." "0,1"
        textline "   "
        bitfld.long 0x00 8. " WDOG_EN ,Memory WDog enable." "0,1"
        textline "   "
        hexmask.long.byte 0x00 9.--11. 1. " WDOG_LIMIT ,Memory Watch Dog (WDog) cycle limit."
        textline "   "
        bitfld.long 0x00 11. " FRUN_ACLK_EN ," "0,1"
width 4.
group.long 0x94++0x3
    line.long 0x00 "DCR,DLL Control Register"
        bitfld.long 0x00 0. " DLL_CTRL_ENABLE ,Set this bit to 1 to enable the DLL and delay chain; otherwise; set to 0 to bypasses DLL." "0,1"
        textline "   "
        bitfld.long 0x00 1. " DLL_CTRL_RESET ,Setting this bit to 1 force a reset on DLL." "0,1"
        textline "   "
        bitfld.long 0x00 2. " DLL_CTRL_SLV_FORCE_UPD ,Setting this bit to 1, forces the slave delay line to update to the DLL calibrated value immediately." "0,1"
        textline "   "
        bitfld.long 0x00 3. " DLL_CTRL_SLV_OFFSET_DEC ,Decrease(or increase) the value defined by DLL_CTRL_SLV_OFFSET when calculating DLL_STS_SLV_SEL" "0,1"
        textline "   "
        hexmask.long.byte 0x00 4.--7. 1. " DLL_CTRL_SLV_OFFSET ,OFFSET value for DLL_CTRL_SLV_SEL"
        textline "   "
        bitfld.long 0x00 7. " DLL_CTRL_GATE_UPDATE ,Set this bit to 1 to force DLL not update from now on." "0,1"
        textline "   "
        bitfld.long 0x00 8. " DLL_CTRL_SLV_OVERRIDE ,Set this bit to 1 to Enable manual override for slave delay chain using SLV_OVERRIDE_VAL; to set 0 to disable manual override." "0,1"
        textline "   "
        hexmask.long.byte 0x00 9.--16. 1. " DLL_CTRL_SLV_OVERRIDE_VAL ,When SLV_OVERRIDE=1 This field is used to select 1 of 128 physical taps manually."
        textline "   "
        hexmask.long.byte 0x00 16.--23. 1. " DLL_CTRL_REF_INITIAL_VAL ,This field is used to select the initial value of reference chain before DLL enabled."
        textline "   "
        hexmask.long.byte 0x00 23.--28. 1. " DLL_CTRL_SLV_UPDATE_INT ,If default 0 is used, it means 256 cycles of ref_clock."
        textline "   "
        hexmask.long.byte 0x00 28.--32. 1. " DLL_CTRL_REF_UPDATE_INT ,DLL control loop update interval."
width 4.
rgroup.long 0x98++0x3
    line.long 0x00 "DSR,DLL Status Register"
        bitfld.long 0x00 0. " DLL_STS_SLV_LOCK ,Slave delay-line lock status." "0,1"
        textline "   "
        bitfld.long 0x00 1. " DLL_STS_REF_LOCK ,Reference DLL lock status." "0,1"
        textline "   "
        hexmask.long.byte 0x00 2.--9. 1. " DLL_STS_SLV_SEL ,Slave delay line select status."
        textline "   "
        hexmask.long.byte 0x00 9.--16. 1. " DLL_STS_REF_SEL ,Reference delay line select taps."
width 5.
group.long 0x9c++0x3
    line.long 0x00 "WIAR,EIM IP Access Register"
        bitfld.long 0x00 0. " IPS_REQ ,IPS request." "0,1"
        textline "    "
        bitfld.long 0x00 1. " IPS_ACK ,IPS ACK." "0,1"
        textline "    "
        bitfld.long 0x00 2. " INT ,Interrupt." "0,1"
        textline "    "
        bitfld.long 0x00 3. " ERRST ,READY After Reset." "0,1"
        textline "    "
        bitfld.long 0x00 4. " ACLK_EN ,ACLK enable." "0,1"
width 4.
group.long 0xa0++0x3
    line.long 0x00 "EAR,Error Address Register"
        hexmask.long.long 0x00 0.--32. 1. " ERROR_ADDR ,Error Address."


tree.end



;--------------------------------------------------------------------------------
; LCDIF
;--------------------------------------------------------------------------------
tree "LCDIF"
    base ad:0x020f8000

width 5.
group.long 0x0++0x3
    line.long 0x00 "CTRL,eLCDIF General Control Register"
        bitfld.long 0x00 0. " RUN ,When this bit is set by software, the eLCDIF will begin transferring data between the SoC and the display." "0,1"
        textline "    "
        bitfld.long 0x00 1. " DATA_FORMAT_24_BIT ,Used only when WORD_LENGTH = 3, i.e." "0,1"
        textline "    "
        bitfld.long 0x00 2. " DATA_FORMAT_18_BIT ,Used only when WORD_LENGTH = 2, i.e." "0,1"
        textline "    "
        bitfld.long 0x00 3. " DATA_FORMAT_16_BIT ,When this bit is 1 and WORD_LENGTH = 0, it implies that the the 16-bit data is in ARGB555 format." "0,1"
        textline "    "
        bitfld.long 0x00 5. " MASTER ,Set this bit to make the eLCDIF act as a bus master." "0,1"
        textline "    "
        bitfld.long 0x00 6. " ENABLE_PXP_HANDSHAKE ,If this bit is set and LCDIF_MASTER bit is set, the eLCDIF will act as bus master and the handshake mechanism between eLCDIF and ePXP will be turned on." "0,1"
        textline "    "
        bitfld.long 0x00 7. " RGB_TO_YCBCR422_CSC ,Set this bit to 1 to enable conversion from RGB to YCbCr colorspace." "0,1"
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " WORD_LENGTH ,Input data format."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " LCD_DATABUS_WIDTH ,LCD Data bus transfer width."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " CSC_DATA_SWIZZLE ,This field specifies how to swap the bytes after the data has been converted into an internal representation of 24 bits per pixel and before it is transmitted over the LCD interface bus."
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " INPUT_DATA_SWIZZLE ,This field specifies how to swap the bytes fetched by the bus master interface."
        textline "    "
        bitfld.long 0x00 16. " DATA_SELECT ,Command Mode polarity bit." "0,1"
        textline "    "
        bitfld.long 0x00 17. " DOTCLK_MODE ,Set this bit to 1 to make the hardware go into the DOTCLK mode, i.e." "0,1"
        textline "    "
        bitfld.long 0x00 18. " VSYNC_MODE ,Setting this bit to 1 will make the eLCDIF hardware go into VSYNC mode." "0,1"
        textline "    "
        bitfld.long 0x00 19. " BYPASS_COUNT ,When this bit is 0, it means that eLCDIF will stop the block operation and turn off the RUN bit after the amount of data indicated by the LCDIF_TRANSFER_COUNT register has been transferred out." "0,1"
        textline "    "
        bitfld.long 0x00 20. " DVI_MODE ,Set this bit to 1 to get into theITU-R BT.656 digital video interface mode." "0,1"
        textline "    "
        hexmask.long.byte 0x00 21.--26. 1. " SHIFT_NUM_BITS ,The data to be transmitted is shifted left or right by this number of bits."
        textline "    "
        bitfld.long 0x00 26. " DATA_SHIFT_DIR ,Use this bit to determine the direction of shift of transmit data." "0,1"
        textline "    "
        bitfld.long 0x00 27. " WAIT_FOR_VSYNC_EDGE ,Setting this bit to 1 will make the hardware wait for the triggering VSYNC edge before starting write transfers to the LCD." "0,1"
        textline "    "
        bitfld.long 0x00 28. " READ_WRITEB ,By default, eLCDIF is in the write mode." "0,1"
        textline "    "
        bitfld.long 0x00 29. " YCBCR422_INPUT ,Zero implies input data is in RGB color space." "0,1"
        textline "    "
        bitfld.long 0x00 30. " CLKGATE ,This bit must be set to zero for normal operation." "0,1"
        textline "    "
        bitfld.long 0x00 31. " SFTRST ,This bit must be set to zero to enable normal operation of the eLCDIF." "0,1"
width 6.
group.long 0x10++0x3
    line.long 0x00 "CTRL1,eLCDIF General Control1 Register"
        bitfld.long 0x00 0. " RESET ,Reset bit for the external LCD controller." "0,1"
        textline "     "
        bitfld.long 0x00 1. " MODE86 ,This bit is used to select between the 8080 and 6800 series of microprocessor modes." "0,1"
        textline "     "
        bitfld.long 0x00 2. " BUSY_ENABLE ,This bit enables the use of the interface's busy signal input." "0,1"
        textline "     "
        bitfld.long 0x00 8. " VSYNC_EDGE_IRQ ,This bit is set to indicate that an interrupt is requested by the eLCDIF block." "0,1"
        textline "     "
        bitfld.long 0x00 9. " CUR_FRAME_DONE_IRQ ,This bit is set to indicate that an interrupt is requested by the eLCDIF block." "0,1"
        textline "     "
        bitfld.long 0x00 10. " UNDERFLOW_IRQ ,This bit is set to indicate that an interrupt is requested by the eLCDIF block." "0,1"
        textline "     "
        bitfld.long 0x00 11. " OVERFLOW_IRQ ,This bit is set to indicate that an interrupt is requested by the eLCDIF block." "0,1"
        textline "     "
        bitfld.long 0x00 12. " VSYNC_EDGE_IRQ_EN ,This bit is set to enable an interrupt every time the hardware encounters the leading VSYNC edge in the VSYNC and DOTCLK modes, or the beginning of every field in DVI mode." "0,1"
        textline "     "
        bitfld.long 0x00 13. " CUR_FRAME_DONE_IRQ_EN ,This bit is set to 1 enable an interrupt every time the hardware enters in the vertical blanking state." "0,1"
        textline "     "
        bitfld.long 0x00 14. " UNDERFLOW_IRQ_EN ,This bit is set to enable an underflow interrupt in the TXFIFO in the write mode." "0,1"
        textline "     "
        bitfld.long 0x00 15. " OVERFLOW_IRQ_EN ,This bit is set to enable an overflow interrupt in the TXFIFO in the write mode." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--20. 1. " BYTE_PACKING_FORMAT ,This bitfield is used to show which data bytes in a 32-bit word are valid."
        textline "     "
        bitfld.long 0x00 20. " IRQ_ON_ALTERNATE_FIELDS ,If this bit is set, the eLCDIF block will assert the cur_frame_done interrupt only on alternate fields, otherwise it will issue the interrupt on both odd and even field." "0,1"
        textline "     "
        bitfld.long 0x00 21. " FIFO_CLEAR ,Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO and the RXFIFO." "0,1"
        textline "     "
        bitfld.long 0x00 22. " START_INTERLACE_FROM_SECOND_FIELD ,The default is to grab the odd lines first and then the even lines." "0,1"
        textline "     "
        bitfld.long 0x00 23. " INTERLACE_FIELDS ,Set this bit if it is required that the eLCDIF block fetches odd lines in one field and even lines in the other field." "0,1"
        textline "     "
        bitfld.long 0x00 24. " RECOVER_ON_UNDERFLOW ,Set this bit to enable the eLCDIF block to recover in the next field/frame if there was an underflow in the current field/frame." "0,1"
        textline "     "
        bitfld.long 0x00 25. " BM_ERROR_IRQ ,This bit is set to indicate that an interrupt is requested by the eLCDIF block." "0,1"
        textline "     "
        bitfld.long 0x00 26. " BM_ERROR_IRQ_EN ,This bit is set to enable bus master error interrupt in the eLCDIF master mode." "0,1"
        textline "     "
        bitfld.long 0x00 27. " COMBINE_MPU_WR_STRB ,If this bit is not set, the write strobe will be driven on LCD_WR_RWn pin in the 8080 mode and on the LCD_RD_E pin in the 6800 mode." "0,1"
width 6.
group.long 0x20++0x3
    line.long 0x00 "CTRL2,eLCDIF General Control2 Register"
        hexmask.long.byte 0x00 1.--4. 1. " INITIAL_DUMMY_READ ,The value in this field determines the number of dummy 8/16/18/24-bit subwords that have to be read back from the LCD panel/controller."
        textline "     "
        hexmask.long.byte 0x00 4.--7. 1. " READ_MODE_NUM_PACKED_SUBWORDS ,Indicates the number of valid 8/16/18/24-bit subwords that will be packed into the 32-bit word in read mode."
        textline "     "
        bitfld.long 0x00 8. " READ_MODE_6_BIT_INPUT ,Setting this bit to 1 indicates to eLCDIF that even though LCD_DATABUS_WIDTH is set to 8 bits, the input data is actually only 6 bits wide and exists on D5-D0." "0,1"
        textline "     "
        bitfld.long 0x00 9. " READ_MODE_OUTPUT_IN_RGB_FORMAT ,Setting this bit will enable the eLCDIF to convert the incoming data to the RGB format given by WORD_LENGTH bitfield." "0,1"
        textline "     "
        bitfld.long 0x00 10. " READ_PACK_DIR ,The default value of 0 indicates data is stored in the little endian format." "0,1"
        textline "     "
        hexmask.long.byte 0x00 12.--15. 1. " EVEN_LINE_PATTERN ,This field determines the order of the RGB components of each pixel in EVEN lines (line numbers 2,4,6,..)."
        textline "     "
        hexmask.long.byte 0x00 16.--19. 1. " ODD_LINE_PATTERN ,This field determines the order of the RGB components of each pixel in ODD lines (line numbers 1,3,5,..)."
        textline "     "
        bitfld.long 0x00 20. " BURST_LEN_8 ,By default, when the eLCDIF is in the bus master mode, it will issue AXI bursts of length 16 (except when in packed 24 bpp mode, it will issue bursts of length 15)." "0,1"
        textline "     "
        hexmask.long.byte 0x00 21.--24. 1. " OUTSTANDING_REQS ,This bitfield indicates the maximum number of outstanding transactions that eLCDIF should request when it is acting as a bus master."
width 15.
group.long 0x30++0x3
    line.long 0x00 "TRANSFER_COUNT,eLCDIF Horizontal and Vertical Valid Data Count Register"
        hexmask.long.word 0x00 0.--16. 1. " H_COUNT ,Total valid data (pixels) in each horizontal line."
        textline "              "
        hexmask.long.word 0x00 16.--32. 1. " V_COUNT ,Number of horizontal lines per frame which contain valid data."
width 8.
group.long 0x40++0x3
    line.long 0x00 "CUR_BUF,LCD Interface Current Buffer Address Register"
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,-"
width 9.
group.long 0x50++0x3
    line.long 0x00 "NEXT_BUF,LCD Interface Next Buffer Address Register"
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,-"
width 7.
group.long 0x60++0x3
    line.long 0x00 "TIMING,LCD Interface Timing Register"
        hexmask.long.byte 0x00 0.--8. 1. " DATA_SETUP ,Data bus setup time in CLK_DIS_LCDIFn cycles."
        textline "      "
        hexmask.long.byte 0x00 8.--16. 1. " DATA_HOLD ,Data bus hold time in CLK_DIS_LCDIFn cycles."
        textline "      "
        hexmask.long.byte 0x00 16.--24. 1. " CMD_SETUP ,Number of CLK_DIS_LCDIFn cycles that the the DCn signal is active before CEn is asserted."
        textline "      "
        hexmask.long.byte 0x00 24.--32. 1. " CMD_HOLD ,Number of CLK_DIS_LCDIFn cycles that the DCn signal is active after CEn is deasserted."
width 8.
group.long 0x70++0x3
    line.long 0x00 "VDCTRL0,eLCDIF VSYNC Mode and Dotclk Mode Control Register0"
        hexmask.long.long 0x00 0.--18. 1. " VSYNC_PULSE_WIDTH ,Number of units for which VSYNC signal is active."
        textline "       "
        bitfld.long 0x00 18. " HALF_LINE_MODE ,When this bit is 0, the first field (VSYNC period) will end in half a horizontal line and the second field will begin with half a horizontal line." "0,1"
        textline "       "
        bitfld.long 0x00 19. " HALF_LINE ,Setting this bit to 1 will make the total VSYNC period equal to the VSYNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i.e." "0,1"
        textline "       "
        bitfld.long 0x00 20. " VSYNC_PULSE_WIDTH_UNIT ,Default 0 for counting VSYNC_PULSE_WIDTH in terms of CLK_DIS_LCDIFn cycles." "0,1"
        textline "       "
        bitfld.long 0x00 21. " VSYNC_PERIOD_UNIT ,Default 0 for counting VSYNC_PERIOD in terms of CLK_DIS_LCDIFn cycles." "0,1"
        textline "       "
        bitfld.long 0x00 24. " ENABLE_POL ,Default 0 active low during valid data transfer on each horizontal line." "0,1"
        textline "       "
        bitfld.long 0x00 25. " DOTCLK_POL ,Default is data launched at negative edge of DOTCLK and captured at positive edge." "0,1"
        textline "       "
        bitfld.long 0x00 26. " HSYNC_POL ,Default 0 active low during HSYNC_PULSE_WIDTH time and will be high during the rest of the HSYNC period." "0,1"
        textline "       "
        bitfld.long 0x00 27. " VSYNC_POL ,Default 0 active low during VSYNC_PULSE_WIDTH time and will be high during the rest of the VSYNC period." "0,1"
        textline "       "
        bitfld.long 0x00 28. " ENABLE_PRESENT ,Setting this bit to 1 will make the hardware generate the ENABLE signal in the DOTCLK mode, thereby making it the true RGB interface along with the remaining three signals VSYNC, HSYNC and DOTCLK." "0,1"
        textline "       "
        bitfld.long 0x00 29. " VSYNC_OEB ,0 means the VSYNC signal is an output, 1 means it is an input." "0,1"
width 8.
group.long 0x80++0x3
    line.long 0x00 "VDCTRL1,eLCDIF VSYNC Mode and Dotclk Mode Control Register1"
        hexmask.long.long 0x00 0.--32. 1. " VSYNC_PERIOD ,Total number of units between two positive or two negative edges of the VSYNC signal."
width 8.
group.long 0x90++0x3
    line.long 0x00 "VDCTRL2,LCDIF VSYNC Mode and Dotclk Mode Control Register2"
        hexmask.long.long 0x00 0.--18. 1. " HSYNC_PERIOD ,Total number of CLK_DIS_LCDIFn cycles between two positive or two negative edges of the HSYNC signal."
        textline "       "
        hexmask.long.word 0x00 18.--32. 1. " HSYNC_PULSE_WIDTH ,Number of CLK_DIS_LCDIFn cycles for which HSYNC signal is active."
width 8.
group.long 0xa0++0x3
    line.long 0x00 "VDCTRL3,eLCDIF VSYNC Mode and Dotclk Mode Control Register3"
        hexmask.long.word 0x00 0.--16. 1. " VERTICAL_WAIT_CNT ,In the VSYNC interface mode, wait for this number of CLK_DIS_LCDIFn cycles from the falling VSYNC edge (or rising if VSYNC_POL is 1) before starting LCD transactions and is applicable only if WAIT_FOR_VSYNC_EDGE is set."
        textline "       "
        hexmask.long.word 0x00 16.--28. 1. " HORIZONTAL_WAIT_CNT ,In the DOTCLK mode, wait for this number of clocks from falling edge (or rising if HSYNC_POL is 1) of HSYNC signal to account for horizontal back porch plus the number of DOTCLKs before the moving picture information begins."
        textline "       "
        bitfld.long 0x00 28. " VSYNC_ONLY ,This bit must be set to 1 in the VSYNC mode of operation, and 0 in the DOTCLK mode of operation." "0,1"
        textline "       "
        bitfld.long 0x00 29. " MUX_SYNC_SIGNALS ,When this bit is set, the eLCDIF block will internally mux HSYNC with LCD_D14, DOTCLK with LCD_D13 and ENABLE with LCD_D12, otherwise these signals will go out on separate pins." "0,1"
width 8.
group.long 0xb0++0x3
    line.long 0x00 "VDCTRL4,eLCDIF VSYNC Mode and Dotclk Mode Control Register4"
        hexmask.long.long 0x00 0.--18. 1. " DOTCLK_H_VALID_DATA_CNT ,Total number of CLK_DIS_LCDIFn cycles on each horizontal line that carry valid data in DOTCLK mode."
        textline "       "
        bitfld.long 0x00 18. " SYNC_SIGNALS_ON ,Set this field to 1 if the LCD controller requires that the VSYNC or VSYNC/HSYNC/DOTCLK control signals should be active atleast one frame before the data transfers actually start and remain active atleast one frame after the data transfers end." "0,1"
        textline "       "
        hexmask.long.byte 0x00 29.--32. 1. " DOTCLK_DLY_SEL ,This bitfield selects the amount of time by which the DOTCLK signal should be delayed before coming out of the LCD_DOTCK pin."
width 9.
group.long 0xc0++0x3
    line.long 0x00 "DVICTRL0,Digital Video Interface Control0 Register"
        hexmask.long.word 0x00 0.--12. 1. " H_BLANKING_CNT ,Number of blanking samples to be inserted between EAV and SAV during horizontal blanking interval."
        textline "        "
        hexmask.long.word 0x00 16.--28. 1. " H_ACTIVE_CNT ,Number of active video samples to be transmitted."
width 9.
group.long 0xd0++0x3
    line.long 0x00 "DVICTRL1,Digital Video Interface Control1 Register"
        hexmask.long.word 0x00 0.--10. 1. " F2_START_LINE ,Vertical line number from which Field 2 begins."
        textline "        "
        hexmask.long.word 0x00 10.--20. 1. " F1_END_LINE ,Vertical line number at which Field1 ends."
        textline "        "
        hexmask.long.word 0x00 20.--30. 1. " F1_START_LINE ,Vertical line number from which Field 1 begins."
width 9.
group.long 0xe0++0x3
    line.long 0x00 "DVICTRL2,Digital Video Interface Control2 Register"
        hexmask.long.word 0x00 0.--10. 1. " V1_BLANK_END_LINE ,Vertical line number in the beginning part of Field2 where first Vertical Blanking interval ends."
        textline "        "
        hexmask.long.word 0x00 10.--20. 1. " V1_BLANK_START_LINE ,Vertical line number towards the end of Field1 where first Vertical Blanking interval starts."
        textline "        "
        hexmask.long.word 0x00 20.--30. 1. " F2_END_LINE ,Vertical line number at which Field 2 ends."
width 9.
group.long 0xf0++0x3
    line.long 0x00 "DVICTRL3,Digital Video Interface Control3 Register"
        hexmask.long.word 0x00 0.--10. 1. " V_LINES_CNT ,Total number of vertical lines per frame (generally 525 or 625)"
        textline "        "
        hexmask.long.word 0x00 10.--20. 1. " V2_BLANK_END_LINE ,Vertical line number in the beginning part of Field1 where second Vertical Blanking interval ends."
        textline "        "
        hexmask.long.word 0x00 20.--30. 1. " V2_BLANK_START_LINE ,Vertical line number towards the end of Field2 where second Vertical Blanking interval starts."
width 9.
group.long 0x100++0x3
    line.long 0x00 "DVICTRL4,Digital Video Interface Control4 Register"
        hexmask.long.byte 0x00 0.--8. 1. " H_FILL_CNT ,Number of active video samples that have to be filled with the filler data in the front and back portions of the active horizontal interval."
        textline "        "
        hexmask.long.byte 0x00 8.--16. 1. " CR_FILL_VALUE ,Value of CR component of filler data."
        textline "        "
        hexmask.long.byte 0x00 16.--24. 1. " CB_FILL_VALUE ,Value of CB component of filler data"
        textline "        "
        hexmask.long.byte 0x00 24.--32. 1. " Y_FILL_VALUE ,Value of Y component of filler data"
width 11.
group.long 0x110++0x3
    line.long 0x00 "CSC_COEFF0,RGB to YCbCr 4:2:2 CSC Coefficient0 Register"
        hexmask.long.byte 0x00 0.--2. 1. " CSC_SUBSAMPLE_FILTER ,This register describes the filtering and subsampling scheme to be performed on the chroma components in order to convert from YCbCr 4:4:4 to YCbCr 4:2:2 space."
        textline "          "
        hexmask.long.word 0x00 16.--26. 1. " C0 ,Two's complement red multiplier coefficient for Y"
width 11.
group.long 0x120++0x3
    line.long 0x00 "CSC_COEFF1,RGB to YCbCr 4:2:2 CSC Coefficient1 Register"
        hexmask.long.word 0x00 0.--10. 1. " C1 ,Two's complement green multiplier coefficient for Y"
        textline "          "
        hexmask.long.word 0x00 16.--26. 1. " C2 ,Two's complement blue multiplier coefficient for Y"
width 11.
group.long 0x130++0x3
    line.long 0x00 "CSC_COEFF2,RGB to YCbCr 4:2:2 CSC Coefficent2 Register"
        hexmask.long.word 0x00 0.--10. 1. " C3 ,Two's complement red multiplier coefficient for Cb"
        textline "          "
        hexmask.long.word 0x00 16.--26. 1. " C4 ,Two's complement green multiplier coefficient for Cb"
width 11.
group.long 0x140++0x3
    line.long 0x00 "CSC_COEFF3,RGB to YCbCr 4:2:2 CSC Coefficient3 Register"
        hexmask.long.word 0x00 0.--10. 1. " C5 ,Two's complement blue multiplier coefficient for Cb"
        textline "          "
        hexmask.long.word 0x00 16.--26. 1. " C6 ,Two's complement red multiplier coefficient for Cr"
width 11.
group.long 0x150++0x3
    line.long 0x00 "CSC_COEFF4,RGB to YCbCr 4:2:2 CSC Coefficient4 Register"
        hexmask.long.word 0x00 0.--10. 1. " C7 ,Two's complement green multiplier coefficient for Cr"
        textline "          "
        hexmask.long.word 0x00 16.--26. 1. " C8 ,Two's complement blue multiplier coefficient for Cr"
width 11.
group.long 0x160++0x3
    line.long 0x00 "CSC_OFFSET,RGB to YCbCr 4:2:2 CSC Offset Register"
        hexmask.long.word 0x00 0.--9. 1. " Y_OFFSET ,Two's complement offset for the Y component"
        textline "          "
        hexmask.long.word 0x00 16.--25. 1. " CBCR_OFFSET ,Two's complement offset for the Cb and Cr components"
width 10.
group.long 0x170++0x3
    line.long 0x00 "CSC_LIMIT,RGB to YCbCr 4:2:2 CSC Limit Register"
        hexmask.long.byte 0x00 0.--8. 1. " Y_MAX ,Upper limit of Y after RGB to 4:2:2 YCbCr conversion"
        textline "         "
        hexmask.long.byte 0x00 8.--16. 1. " Y_MIN ,Lower limit of Y after RGB to 4:2:2 YCbCr conversion"
        textline "         "
        hexmask.long.byte 0x00 16.--24. 1. " CBCR_MAX ,Upper limit of Cb and Cr after RGB to 4:2:2 YCbCr conversion"
        textline "         "
        hexmask.long.byte 0x00 24.--32. 1. " CBCR_MIN ,Lower limit of Cb and Cr after RGB to 4:2:2 YCbCr conversion"
width 5.
group.long 0x180++0x3
    line.long 0x00 "DATA,LCD Interface Data Register"
        hexmask.long.byte 0x00 0.--8. 1. " DATA_ZERO ,Byte 0 (least significant byte) of data written to eLCDIF."
        textline "    "
        hexmask.long.byte 0x00 8.--16. 1. " DATA_ONE ,Byte 1 of data written to eLCDIF."
        textline "    "
        hexmask.long.byte 0x00 16.--24. 1. " DATA_TWO ,Byte 2 of data written to eLCDIF."
        textline "    "
        hexmask.long.byte 0x00 24.--32. 1. " DATA_THREE ,Byte 3 (most significant byte) of data written to LCDIF."
width 14.
group.long 0x190++0x3
    line.long 0x00 "BM_ERROR_STAT,Bus Master Error Status Register"
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,Virtual address at which bus master error occurred."
width 9.
group.long 0x1a0++0x3
    line.long 0x00 "CRC_STAT,CRC Status Register"
        hexmask.long.long 0x00 0.--32. 1. " CRC_VALUE ,Calculated CRC value."
width 5.
rgroup.long 0x1b0++0x3
    line.long 0x00 "STAT,LCD Interface Status Register"
        hexmask.long.word 0x00 0.--9. 1. " LFIFO_COUNT ,Read only view of the current count in Latency buffer (LFIFO)."
        textline "    "
        bitfld.long 0x00 24. " DVI_CURRENT_FIELD ,Read only view of the current field being transmitted." "0,1"
        textline "    "
        bitfld.long 0x00 25. " BUSY ,Read only view of the input busy signal from the external LCD controller." "0,1"
        textline "    "
        bitfld.long 0x00 26. " TXFIFO_EMPTY ,Read only view of the signal that indicates that LCD write dapatath FIFO is empty, will be generally used in the read mode of the LCD interface." "0,1"
        textline "    "
        bitfld.long 0x00 27. " TXFIFO_FULL ,Read only view of the signal that indicates that LCD write datapath FIFO is full, will be generally used in the write mode of the LCD interface." "0,1"
        textline "    "
        bitfld.long 0x00 28. " LFIFO_EMPTY ,Read only view of the signal that indicates that LCD read dapatath FIFO is empty, will be generally used in the read mode of the LCD interface." "0,1"
        textline "    "
        bitfld.long 0x00 29. " LFIFO_FULL ,Read only view of the signal that indicates that LCD read datapath FIFO is full, will be generally used in the write mode of the LCD interface." "0,1"
        textline "    "
        bitfld.long 0x00 31. " PRESENT ,0: eLCDIF not present on this product 1: eLCDIF is present." "0,1"
width 8.
rgroup.long 0x1c0++0x3
    line.long 0x00 "VERSION,LCD Interface Version Register"
        hexmask.long.word 0x00 0.--16. 1. " STEP ,Fixed read-only value reflecting the stepping of RTL version."
        textline "       "
        hexmask.long.byte 0x00 16.--24. 1. " MINOR ,Fixed read-only value reflecting the MINOR field of RTL version."
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " MAJOR ,Fixed read-only value reflecting the MAJOR field of RTL version."
width 7.
rgroup.long 0x1d0++0x3
    line.long 0x00 "DEBUG0,LCD Interface Debug0 Register"
        hexmask.long.byte 0x00 0.--4. 1. " MST_WORDS ,Read only view of the current bursts issued by the AXI bus master."
        textline "      "
        hexmask.long.byte 0x00 4.--9. 1. " MST_OUTSTANDING_REQS ,Read only view of the current outstanding requests issued by the AXI bus master."
        textline "      "
        bitfld.long 0x00 9. " MST_AVALID ,Read only view of the mst_avalid signal issued by the AXI bus master." "0,1"
        textline "      "
        hexmask.long.byte 0x00 10.--12. 1. " CUR_REQ_STATE ,Read only view of the request state machine."
        textline "      "
        bitfld.long 0x00 12. " PXP_B1_DONE ,Buffer1 done signal issued by eLCDIF." "0,1"
        textline "      "
        bitfld.long 0x00 13. " PXP_LCDIF_B1_READY ,Buffer1 ready signal issued by ePXP." "0,1"
        textline "      "
        bitfld.long 0x00 14. " PXP_B0_DONE ,Buffer0 done signal issued by eLCDIF." "0,1"
        textline "      "
        bitfld.long 0x00 15. " PXP_LCDIF_B0_READY ,Buffer0 ready signal issued by ePXP." "0,1"
        textline "      "
        hexmask.long.byte 0x00 16.--23. 1. " CUR_STATE ,Read only view of the current state machine state in the current mode of operation."
        textline "      "
        bitfld.long 0x00 23. " EMPTY_WORD ,Indicates that the current word is empty." "0,1"
        textline "      "
        bitfld.long 0x00 24. " CUR_FRAME_TX ,This bit is 1 for the time the current frame is being transmitted in the VSYNC mode." "0,1"
        textline "      "
        bitfld.long 0x00 25. " VSYNC ,Read only view of VSYNC signal." "0,1"
        textline "      "
        bitfld.long 0x00 26. " HSYNC ,Read only view of HSYNC signal." "0,1"
        textline "      "
        bitfld.long 0x00 27. " ENABLE ,Read only view of ENABLE signal." "0,1"
        textline "      "
        bitfld.long 0x00 29. " SYNC_SIGNALS_ON_REG ,Read only view of internal sync_signals_on_reg signal." "0,1"
        textline "      "
        bitfld.long 0x00 30. " WAIT_FOR_VSYNC_EDGE_OUT ,Read only view of WAIT_FOR_VSYNC_EDGE bit in the VSYNC mode after it comes out of the TXFIFO." "0,1"
        textline "      "
        bitfld.long 0x00 31. " STREAMING_END_DETECTED ,Read only view of the DOTCLK_MODE or DVI_MODE bit going from 1 to 0." "0,1"
width 7.
rgroup.long 0x1e0++0x3
    line.long 0x00 "DEBUG1,LCD Interface Debug1 Register"
        hexmask.long.word 0x00 0.--16. 1. " V_DATA_COUNT ,Read only view of the current state of the vertical data counter."
        textline "      "
        hexmask.long.word 0x00 16.--32. 1. " H_DATA_COUNT ,Read only view of the current state of the horizontal data counter."
width 7.
rgroup.long 0x1f0++0x3
    line.long 0x00 "DEBUG2,LCD Interface Debug2 Register"
        hexmask.long.long 0x00 0.--32. 1. " MST_ADDRESS ,Read only view of the current address issued by the AXI bus master."
width 6.
group.long 0x200++0x3
    line.long 0x00 "THRES,eLCDIF Threshold Register"
        hexmask.long.word 0x00 0.--9. 1. " PANIC ,This value should be set to a value of pixels, from 0 to 511."
        textline "     "
        hexmask.long.word 0x00 16.--25. 1. " FASTCLOCK ,This value should be set to a value of pixels, from 0 to 511."


tree.end



;--------------------------------------------------------------------------------
; EPDC
;--------------------------------------------------------------------------------
tree "EPDC"
    base ad:0x020f4000

width 5.
group.long 0x0++0x3
    line.long 0x00 "CTRL,EPDC Control Register"
        bitfld.long 0x00 0. " BURST_LEN_8 ,0- EPDC display fifo logic will issue AXI bursts of length 16." "0,1"
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " LUT_DATA_SWIZZLE ,Specifies how to swap the bytes for the LUT data before store to LUTRAM."
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " UPD_DATA_SWIZZLE ,Specifies how to swap the bytes for the UPD data before the WB construction."
        textline "    "
        bitfld.long 0x00 30. " CLKGATE ,This bit must be set to zero for normal operation." "0,1"
        textline "    "
        bitfld.long 0x00 31. " SFTRST ,Set this bit to zero to enable normal EPDC operation." "0,1"
width 7.
group.long 0x20++0x3
    line.long 0x00 "WVADDR,EPDC Waveform Address Pointer"
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,Start address of waveform tables."
width 8.
group.long 0x30++0x3
    line.long 0x00 "WB_ADDR,EPDC Working Buffer Address"
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,Address for EPDC working buffer."
width 4.
group.long 0x40++0x3
    line.long 0x00 "RES,EPDC Screen Resolution"
        hexmask.long.word 0x00 0.--13. 1. " HORIZONTAL ,Horizontal Resolution (in pixels)"
        textline "   "
        hexmask.long.word 0x00 16.--29. 1. " VERTICAL ,Vertical Resoltion (in pixels)"
width 7.
group.long 0x50++0x3
    line.long 0x00 "FORMAT,EPDC Format Control Register"
        hexmask.long.byte 0x00 0.--2. 1. " TFT_PIXEL_FORMAT ,EPDC TFT Pixel Format."
        textline "      "
        hexmask.long.byte 0x00 8.--11. 1. " BUF_PIXEL_FORMAT ,EPDC Input Buffer Pixel format."
        textline "      "
        hexmask.long.byte 0x00 16.--24. 1. " DEFAULT_TFT_PIXEL ,Default TFT pixel value."
        textline "      "
        bitfld.long 0x00 24. " BUF_PIXEL_SCALE ,Selects method of conversion from 8-bit input" "0,1"
width 9.
group.long 0xa0++0x3
    line.long 0x00 "FIFOCTRL,EPDC FIFO control register"
        hexmask.long.byte 0x00 0.--8. 1. " FIFO_L_LEVEL ,Lower level value of FIFO watermark."
        textline "        "
        hexmask.long.byte 0x00 8.--16. 1. " FIFO_H_LEVEL ,Upper level value of FIFO watermark."
        textline "        "
        hexmask.long.byte 0x00 16.--24. 1. " FIFO_INIT_LEVEL ,This register sets the watermark for the pixel-fifo."
        textline "        "
        bitfld.long 0x00 31. " ENABLE_PRIORITY ,Enable watermark-based priority elevation mechanism." "0,1"
width 9.
group.long 0x100++0x3
    line.long 0x00 "UPD_ADDR,EPDC Update Region Address"
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,Address for incoming region update."
width 11.
group.long 0x110++0x3
    line.long 0x00 "UPD_STRIDE,EPDC Update Region Stride"
        hexmask.long.long 0x00 0.--32. 1. " STRIDE ,line stride for incoming region update"
width 9.
group.long 0x120++0x3
    line.long 0x00 "UPD_CORD,EPDC Update Command Co-ordinate"
        hexmask.long.word 0x00 0.--13. 1. " XCORD ,X co-ordinate for incoming region update"
        textline "        "
        hexmask.long.word 0x00 16.--29. 1. " YCORD ,Y co-ordinate for incoming region update"
width 9.
group.long 0x140++0x3
    line.long 0x00 "UPD_SIZE,EPDC Update Command Size"
        hexmask.long.word 0x00 0.--13. 1. " WIDTH ,Width (in pixels)"
        textline "        "
        hexmask.long.word 0x00 16.--29. 1. " HEIGHT ,Height (in pixels)"
width 9.
group.long 0x160++0x3
    line.long 0x00 "UPD_CTRL,EPDC Update Command Control"
        bitfld.long 0x00 0. " UPDATE_MODE ,Update Mode" "0,1"
        textline "        "
        bitfld.long 0x00 1. " DRY_RUN ,Enable Dry Run mode(set to 1)." "0,1"
        textline "        "
        bitfld.long 0x00 2. " AUTOWV ,enable automatical waveform mode selection" "0,1"
        textline "        "
        bitfld.long 0x00 3. " AUTOWV_PAUSE ," "0,1"
        textline "        "
        bitfld.long 0x00 4. " NO_LUT_CANCEL ,EPDC will cancel LUT loading for void update (no real update needed because of partial or collision), set this bit to 1 to disable this feature" "0,1"
        textline "        "
        hexmask.long.byte 0x00 8.--16. 1. " WAVEFORM_MODE ,Waveform Mode 0-255"
        textline "        "
        hexmask.long.byte 0x00 16.--22. 1. " LUT_SEL ,LUT select 0-63"
        textline "        "
        bitfld.long 0x00 31. " USE_FIXED ,Use fixed pixel values (requires programming of EPDC_UPD_FIXED)" "0,1"
width 10.
group.long 0x180++0x3
    line.long 0x00 "UPD_FIXED,EPDC Update Fixed Pixel Control"
        hexmask.long.byte 0x00 0.--8. 1. " FIXCP ,CP value if fixecp_en is set to 1."
        textline "         "
        hexmask.long.byte 0x00 8.--16. 1. " FIXNP ,NP value if fixenp_en is set to 1."
        textline "         "
        bitfld.long 0x00 30. " FIXCP_EN ,If set to 1, current updated region has the CP value defined by FIXCP" "0,1"
        textline "         "
        bitfld.long 0x00 31. " FIXNP_EN ,If set to 1, current updated region has the NP value defined by FIXNP" "0,1"
width 5.
group.long 0x1a0++0x3
    line.long 0x00 "TEMP,EPDC Temperature Register"
        hexmask.long.long 0x00 0.--32. 1. " TEMPERATURE ,Temperature Value."
width 11.
group.long 0x1c0++0x3
    line.long 0x00 "AUTOWV_LUT,Waveform Mode Lookup Table Control Register."
        hexmask.long.byte 0x00 0.--3. 1. " ADDR ,ADDR"
        textline "          "
        hexmask.long.byte 0x00 16.--24. 1. " DATA ,DATA"
width 9.
group.long 0x200++0x3
    line.long 0x00 "TCE_CTRL,EPDC Timing Control Engine Control Register"
        hexmask.long.byte 0x00 0.--2. 1. " PIXELS_PER_SDCLK ,Number of TFT pixels per SDCLK period."
        textline "        "
        bitfld.long 0x00 2. " SDDO_WIDTH ,Selects either 8 or 16 bit SDDO bus format" "0,1"
        textline "        "
        bitfld.long 0x00 3. " DUAL_SCAN ,Enables dual scan-mode." "0,1"
        textline "        "
        bitfld.long 0x00 4. " SCAN_DIR_0 ,Determines scan direction for each half of the TFT panel" "0,1"
        textline "        "
        bitfld.long 0x00 5. " SCAN_DIR_1 ,Determines scan direction for each half of the TFT panel" "0,1"
        textline "        "
        bitfld.long 0x00 6. " LVDS_MODE ,If set, the upper 8-bit of the SDDO bus are used for LVDS differential signalling." "0,1"
        textline "        "
        bitfld.long 0x00 7. " LVDS_MODE_CE ,If set (together with LVDS_MODE=1), SDCE[9:5] shall be driven as the differential inverse of SDCE[4:0]." "0,1"
        textline "        "
        bitfld.long 0x00 8. " DDR_MODE ,If set, SDDO data is driven on both positive and negative edges of SDCLK." "0,1"
        textline "        "
        bitfld.long 0x00 9. " VCOM_MODE ,This field determines the method used to drive the VCOM signal." "0,1"
        textline "        "
        hexmask.long.byte 0x00 10.--12. 1. " VCOM_VAL ,When VCOM_MODE = MANUAL, this value is used to manually set the VCOM value for the VCOM[1:0] pins"
        textline "        "
        hexmask.long.word 0x00 16.--25. 1. " VSCAN_HOLDOFF ,This period (expressed in vertical lines), sets the portion of the vertical blanking available for new LUTs to be activated."
width 10.
group.long 0x220++0x3
    line.long 0x00 "TCE_SDCFG,EPDC Timing Control Engine Source-Driver Config Register"
        hexmask.long.word 0x00 0.--13. 1. " PIXELS_PER_CE ,Number of pixels (outputs) per source-driver IC."
        textline "         "
        bitfld.long 0x00 13. " SDDO_INVERT ,Setting this bit to 1 reverses the polarity of each SDDO bit so 0xAAAA in 16-bit mode for example becomes 0x5555." "0,1"
        textline "         "
        hexmask.long.byte 0x00 14.--16. 1. " SDDO_REFORMAT ,This register defines the various re-formatting options to enable more flexibility in the source-driver interface:"
        textline "         "
        hexmask.long.byte 0x00 16.--20. 1. " NUM_CE ,Number of source driver IC chip-enables."
        textline "         "
        bitfld.long 0x00 20. " SDSHR ,Value for source-driver shift direction output port" "0,1"
        textline "         "
        bitfld.long 0x00 21. " SDCLK_HOLD ,Setting this bit to 1 holds the SDCLK low during LINE_BEGIN" "0,1"
width 10.
group.long 0x240++0x3
    line.long 0x00 "TCE_GDCFG,EPDC Timing Control Engine Gate-Driver Config Register"
        bitfld.long 0x00 0. " GDSP_MODE ,Selects method for driving GDSP pulse." "0,1"
        textline "         "
        bitfld.long 0x00 1. " GDOE_MODE ,Selects method for driving GDOE signal." "0,1"
        textline "         "
        bitfld.long 0x00 4. " GDRL ,Value for gate-driver right/left shift output port" "0,1"
        textline "         "
        hexmask.long.word 0x00 16.--32. 1. " PERIOD_VSCAN ,when vscan state is splited, this reg defines the counter period"
width 11.
group.long 0x260++0x3
    line.long 0x00 "TCE_HSCAN1,EPDC Timing Control Engine Horizontal Timing Register 1"
        hexmask.long.word 0x00 0.--12. 1. " LINE_SYNC ,Number of PIXCLK cycles for line sync duration."
        textline "          "
        hexmask.long.word 0x00 16.--28. 1. " LINE_SYNC_WIDTH ,Number of PIXCLK cycles for the SDLE active time."
width 11.
group.long 0x280++0x3
    line.long 0x00 "TCE_HSCAN2,EPDC Timing Control Engine Horizontal Timing Register 2"
        hexmask.long.word 0x00 0.--12. 1. " LINE_BEGIN ,Number of PIXCLK cycles for line begin duration."
        textline "          "
        hexmask.long.word 0x00 16.--28. 1. " LINE_END ,Number of PIXCLK cycles for line end duration."
width 10.
group.long 0x2a0++0x3
    line.long 0x00 "TCE_VSCAN,EPDC Timing Control Engine Vertical Timing Register"
        hexmask.long.byte 0x00 0.--8. 1. " FRAME_SYNC ,Number of lines for frame sync duration."
        textline "         "
        hexmask.long.byte 0x00 8.--16. 1. " FRAME_BEGIN ,Number of lines for frame begin duration."
        textline "         "
        hexmask.long.byte 0x00 16.--24. 1. " FRAME_END ,Number of lines for frame end duration."
width 7.
group.long 0x2c0++0x3
    line.long 0x00 "TCE_OE,EPDC Timing Control Engine OE timing control Register"
        hexmask.long.byte 0x00 0.--8. 1. " SDOEZ_DLY ,Number of PIXCLK cycles from SDLE falling edge to SDOEZ rising (Must be greater than 0)"
        textline "      "
        hexmask.long.byte 0x00 8.--16. 1. " SDOEZ_WIDTH ,Number of PIXCLK cycles from SDOEZ high to SDOEZ falling (Must be greater than 0)"
        textline "      "
        hexmask.long.byte 0x00 16.--24. 1. " SDOED_DLY ,Number of PIXCLK cycles from SDOEZ low to SDOED rising (Must be greater than 0)"
        textline "      "
        hexmask.long.byte 0x00 24.--32. 1. " SDOED_WIDTH ,Number of PIXCLK cycles from SDOED high to SDOED falling (Must be greater than 0)"
width 13.
group.long 0x2e0++0x3
    line.long 0x00 "TCE_POLARITY,EPDC Timing Control Engine Driver Polarity Register"
        bitfld.long 0x00 0. " SDCE_POL ,0 = Active Low, 1 = Active High." "0,1"
        textline "            "
        bitfld.long 0x00 1. " SDLE_POL ,0 = Active Low, 1 = Active High." "0,1"
        textline "            "
        bitfld.long 0x00 2. " SDOE_POL ,0 = Active Low, 1 = Active High." "0,1"
        textline "            "
        bitfld.long 0x00 3. " GDOE_POL ,0 = Active Low, 1 = Active High." "0,1"
        textline "            "
        bitfld.long 0x00 4. " GDSP_POL ,0 = Active Low, 1 = Active High." "0,1"
width 12.
group.long 0x300++0x3
    line.long 0x00 "TCE_TIMING1,EPDC Timing Control Engine Timing Register 1"
        hexmask.long.byte 0x00 0.--2. 1. " SDCLK_SHIFT ,This register can be used to implement additional timing setup/hold adjustment of source driver signals by adjusting the SDCLK up to 4 cycles"
        textline "           "
        bitfld.long 0x00 3. " SDCLK_INVERT ,Invert phase of SDCLK" "0,1"
        textline "           "
        hexmask.long.byte 0x00 4.--6. 1. " SDLE_SHIFT ,This register can be used to implement additional timing setup/hold adjustment of source driver signals by adjusting the SDCLK up to 3 PIXCLK cycles"
width 12.
group.long 0x310++0x3
    line.long 0x00 "TCE_TIMING2,EPDC Timing Control Engine Timing Register 2"
        hexmask.long.word 0x00 0.--16. 1. " GDSP_OFFSET ,This register allows the user to shift the GDSP pulse by N PIXCLKs where N=1 to 65535."
        textline "           "
        hexmask.long.word 0x00 16.--32. 1. " GDCLK_HP ,This register controls the GDCLK high-pulse width."
width 12.
group.long 0x320++0x3
    line.long 0x00 "TCE_TIMING3,EPDC Timing Control Engine Timing Register 3"
        hexmask.long.word 0x00 0.--16. 1. " GDCLK_OFFSET ,This register allows the user to shift the GDCLK from the line time by N PIXCLK cycles."
        textline "           "
        hexmask.long.word 0x00 16.--32. 1. " GDOE_OFFSET ,When using GDOE_MODE=1, this register sets the delay from GDCLK to the GDOE in terms of N PIXCLK cycles"
width 13.
group.long 0x380++0x3
    line.long 0x00 "PIGEON_CTRL0,EPDC Pigeon Mode Control Register 0"
        hexmask.long.word 0x00 0.--12. 1. " FD_PERIOD ,period of line counter during FD phase"
        textline "            "
        hexmask.long.word 0x00 16.--28. 1. " LD_PERIOD ,period of pclk counter during LD phase"
width 13.
group.long 0x390++0x3
    line.long 0x00 "PIGEON_CTRL1,EPDC Pigeon Mode Control Register 1"
        hexmask.long.word 0x00 0.--12. 1. " FRAME_CNT_PERIOD ,period of frame counter"
        textline "            "
        hexmask.long.word 0x00 16.--28. 1. " FRAME_CNT_CYCLES ,max cycles of frame counter"
width 10.
group.long 0x3c0++0x3
    line.long 0x00 "IRQ_MASK1,EPDC IRQ Mask Register for LUT 0~31"
        hexmask.long.long 0x00 0.--32. 1. " LUTN_CMPLT_IRQ_EN ,LUT0~31 Complete Interrupt Enable"
width 10.
group.long 0x3d0++0x3
    line.long 0x00 "IRQ_MASK2,EPDC IRQ Mask Register for LUT 32~63"
        hexmask.long.long 0x00 0.--32. 1. " LUTN_CMPLT_IRQ_EN ,LUT32~64 Complete Interrupt Enable"
width 5.
group.long 0x3e0++0x3
    line.long 0x00 "IRQ1,EPDC Interrupt Register for LUT 0~31"
        hexmask.long.long 0x00 0.--32. 1. " LUTN_CMPLT_IRQ ,LUT 0~31 Complete Interrupt"
width 5.
group.long 0x3f0++0x3
    line.long 0x00 "IRQ2,EPDC Interrupt Registerr for LUT 32~63"
        hexmask.long.long 0x00 0.--32. 1. " LUTN_CMPLT_IRQ ,LUT 32~64 Complete Interrupt"
width 9.
group.long 0x400++0x3
    line.long 0x00 "IRQ_MASK,EPDC IRQ Mask Register"
        bitfld.long 0x00 16. " WB_CMPLT_IRQ_EN ,Enable WB complete interrupt" "0,1"
        textline "        "
        bitfld.long 0x00 17. " COL_IRQ_EN ,Enable collision detection interrupts for all LUTs" "0,1"
        textline "        "
        bitfld.long 0x00 18. " TCE_UNDERRUN_IRQ_EN ,Enable pixel FIFO under-run condition detection." "0,1"
        textline "        "
        bitfld.long 0x00 19. " FRAME_END_IRQ_EN ,If this bit is set, EPDC will assert the current frame end interrupt." "0,1"
        textline "        "
        bitfld.long 0x00 20. " BUS_ERROR_IRQ_EN ,Enable AXI BUS ERROR interrupt detection." "0,1"
        textline "        "
        bitfld.long 0x00 21. " TCE_IDLE_IRQ_EN ,Enable TCE Idle interrupt detection." "0,1"
        textline "        "
        bitfld.long 0x00 22. " UPD_DONE_IRQ_EN ,Enable UPD complete interrupt" "0,1"
        textline "        "
        bitfld.long 0x00 23. " PWR_IRQ_EN ,Enable power interrupt" "0,1"
width 4.
group.long 0x420++0x3
    line.long 0x00 "IRQ,EPDC Interrupt Register"
        bitfld.long 0x00 16. " WB_CMPLT_IRQ ,Working buffer process complete Interrupt" "0,1"
        textline "   "
        bitfld.long 0x00 17. " LUT_COL_IRQ ,Collision detection interrupt." "0,1"
        textline "   "
        bitfld.long 0x00 18. " TCE_UNDERRUN_IRQ ,Interrupt to indicate that a pixel FIFO under-run has occured." "0,1"
        textline "   "
        bitfld.long 0x00 19. " FRAME_END_IRQ ,Interrupt to indicate EPDC has completed the current frame and is in the vertical blanking period." "0,1"
        textline "   "
        bitfld.long 0x00 20. " BUS_ERROR_IRQ ,Interrupt to indicate AXI BUS error occurs." "0,1"
        textline "   "
        bitfld.long 0x00 21. " TCE_IDLE_IRQ ,Interrupt to indicate that the TCE has completed TFT frame scans and is in an idle state." "0,1"
        textline "   "
        bitfld.long 0x00 22. " UPD_DONE_IRQ ,Working buffer process complete Interrupt" "0,1"
        textline "   "
        bitfld.long 0x00 23. " PWR_IRQ ,Power Interrupt" "0,1"
width 13.
group.long 0x440++0x3
    line.long 0x00 "STATUS_LUTS1,EPDC Status Register - LUTs"
        hexmask.long.long 0x00 0.--32. 1. " LUTN_STS ,LUT 0~31 Status : 1=ACTIVE, 0=IDLE"
width 13.
group.long 0x450++0x3
    line.long 0x00 "STATUS_LUTS2,EPDC Status Register - LUTs"
        hexmask.long.long 0x00 0.--32. 1. " LUTN_STS ,LUT 32~63 Status : 1=ACTIVE, 0=IDLE"
width 15.
group.long 0x460++0x3
    line.long 0x00 "STATUS_NEXTLUT,EPDC Status Register - Next Available LUT"
        hexmask.long.byte 0x00 0.--6. 1. " NEXT_LUT ,Next available LUT value"
        textline "              "
        bitfld.long 0x00 8. " NEXT_LUT_VALID ,This bitfield can be used to check against a LUTs full condition" "0,1"
width 12.
group.long 0x480++0x3
    line.long 0x00 "STATUS_COL1,EPDC LUT Collision Status"
        hexmask.long.long 0x00 0.--32. 1. " LUTN_COL_STS ,LUTn Collision Status"
width 12.
group.long 0x490++0x3
    line.long 0x00 "STATUS_COL2,EPDC LUT Collision Status"
        hexmask.long.long 0x00 0.--32. 1. " LUTN_COL_STS ,LUTn Collision Status"
width 7.
group.long 0x4a0++0x3
    line.long 0x00 "STATUS,EPDC General Status Register"
        bitfld.long 0x00 0. " WB_BUSY ,Working buffer process is busy cannot accept new update requests." "0,1"
        textline "      "
        bitfld.long 0x00 1. " LUTS_BUSY ,Provides a summary status of LUTs." "0,1"
        textline "      "
        bitfld.long 0x00 2. " LUTS_UNDERRUN ,Provides a summary status of LUT fill." "0,1"
        textline "      "
        bitfld.long 0x00 3. " UPD_VOID ,shows the update buffer is void (don't need any real pixel update)" "0,1"
        textline "      "
        hexmask.long.byte 0x00 8.--13. 1. " HISTOGRAM_NP ,Indicates which histogram matched the processed bitmap(NP)."
        textline "      "
        hexmask.long.byte 0x00 16.--21. 1. " HISTOGRAM_CP ,Indicates which histogram matched the existing bitmap(CP)."
width 13.
group.long 0x4c0++0x3
    line.long 0x00 "UPD_COL_CORD,EPDC Collision Region Co-ordinate"
        hexmask.long.word 0x00 0.--13. 1. " XCORD ,X co-ordinate for collision region of the latest completed update"
        textline "            "
        hexmask.long.word 0x00 16.--29. 1. " YCORD ,Y co-ordinate for collision region of the latest completed update"
width 13.
group.long 0x4e0++0x3
    line.long 0x00 "UPD_COL_SIZE,EPDC Collision Region Size"
        hexmask.long.word 0x00 0.--13. 1. " WIDTH ,Width (in pixels)"
        textline "            "
        hexmask.long.word 0x00 16.--29. 1. " HEIGHT ,Height (in pixels)"
width 12.
group.long 0x600++0x3
    line.long 0x00 "HIST1_PARAM,1-level Histogram Parameter Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE0 ,value for 1-level histogram"
width 12.
group.long 0x610++0x3
    line.long 0x00 "HIST2_PARAM,2-level Histogram Parameter Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE0 ,Black value for 2-level histogram"
        textline "           "
        hexmask.long.byte 0x00 8.--13. 1. " VALUE1 ,White value for 2-level histogram"
width 12.
group.long 0x620++0x3
    line.long 0x00 "HIST4_PARAM,4-level Histogram Parameter Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE0 ,GRAY0 (Black) value for 4-level histogram"
        textline "           "
        hexmask.long.byte 0x00 8.--13. 1. " VALUE1 ,GRAY1 value for 4-level histogram"
        textline "           "
        hexmask.long.byte 0x00 16.--21. 1. " VALUE2 ,GRAY2 value for 4-level histogram"
        textline "           "
        hexmask.long.byte 0x00 24.--29. 1. " VALUE3 ,GRAY3 (White) value for 4-level histogram"
width 13.
group.long 0x630++0x3
    line.long 0x00 "HIST8_PARAM0,8-level Histogram Parameter 0 Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE0 ,GRAY0 (Black) value for 8-level histogram"
        textline "            "
        hexmask.long.byte 0x00 8.--13. 1. " VALUE1 ,GRAY1 value for 8-level histogram"
        textline "            "
        hexmask.long.byte 0x00 16.--21. 1. " VALUE2 ,GRAY2 value for 8-level histogram"
        textline "            "
        hexmask.long.byte 0x00 24.--29. 1. " VALUE3 ,GRAY3 value for 8-level histogram"
width 13.
group.long 0x640++0x3
    line.long 0x00 "HIST8_PARAM1,8-level Histogram Parameter 1 Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE4 ,GRAY4 value for 8-level histogram"
        textline "            "
        hexmask.long.byte 0x00 8.--13. 1. " VALUE5 ,GRAY5 value for 8-level histogram"
        textline "            "
        hexmask.long.byte 0x00 16.--21. 1. " VALUE6 ,GRAY6 value for 8-level histogram"
        textline "            "
        hexmask.long.byte 0x00 24.--29. 1. " VALUE7 ,GRAY7 (White) value for 8-level histogram"
width 14.
group.long 0x650++0x3
    line.long 0x00 "HIST16_PARAM0,16-level Histogram Parameter 0 Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE0 ,GRAY0 (Black) value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 8.--13. 1. " VALUE1 ,GRAY1 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 16.--21. 1. " VALUE2 ,GRAY2 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 24.--29. 1. " VALUE3 ,GRAY3 value for 16-level histogram"
width 14.
group.long 0x660++0x3
    line.long 0x00 "HIST16_PARAM1,16-level Histogram Parameter Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE4 ,GRAY4 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 8.--13. 1. " VALUE5 ,GRAY5 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 16.--21. 1. " VALUE6 ,GRAY6 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 24.--29. 1. " VALUE7 ,GRAY7 value for 16-level histogram"
width 14.
group.long 0x670++0x3
    line.long 0x00 "HIST16_PARAM2,16-level Histogram Parameter Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE8 ,GRAY8 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 8.--13. 1. " VALUE9 ,GRAY9 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 16.--21. 1. " VALUE10 ,GRAY10 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 24.--29. 1. " VALUE11 ,GRAY11 value for 16-level histogram"
width 14.
group.long 0x680++0x3
    line.long 0x00 "HIST16_PARAM3,16-level Histogram Parameter Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE12 ,GRAY12 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 8.--13. 1. " VALUE13 ,GRAY13 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 16.--21. 1. " VALUE14 ,GRAY14 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 24.--29. 1. " VALUE15 ,GRAY15 (White) value for 16-level histogram"
width 5.
group.long 0x700++0x3
    line.long 0x00 "GPIO,EPDC General Purpose I/O Debug register"
        hexmask.long.byte 0x00 0.--2. 1. " BDR ,Controls ipp_epdc_bdr[1:0] output"
        textline "    "
        hexmask.long.byte 0x00 2.--6. 1. " PWRCTRL ,Controls ipp_epdc_pwrctrl[3:0] output"
        textline "    "
        bitfld.long 0x00 6. " PWRCOM ,Controls ipp_epdc_pwrcom output" "0,1"
        textline "    "
        bitfld.long 0x00 7. " PWRWAKE ,Controls ipp_epdc_pwrwake output" "0,1"
        textline "    "
        bitfld.long 0x00 8. " PWRSTAT ,reflect ipp_epdc_pwrstat input" "0,1"
width 8.
group.long 0x7f0++0x3
    line.long 0x00 "VERSION,EPDC Version Register"
        hexmask.long.word 0x00 0.--16. 1. " STEP ,Fixed read-only value reflecting the stepping of the RTL version."
        textline "       "
        hexmask.long.byte 0x00 16.--24. 1. " MINOR ,Fixed read-only value reflecting the MINOR field of the RTL version."
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " MAJOR ,Fixed read-only value reflecting the MAJOR field of the RTL version."
width 11.
group.long 0x800++0x3
    line.long 0x00 "PIGEON_0_0,Panel Interface Signal Generator Register 0_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "          "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "          "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "          "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "          "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "          "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 11.
group.long 0x810++0x3
    line.long 0x00 "PIGEON_0_1,Panel Interface Signal Generator Register 0_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "          "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 11.
group.long 0x820++0x3
    line.long 0x00 "PIGEON_0_2,Panel Interface Signal Generator Register 0_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "          "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"
width 11.
group.long 0x840++0x3
    line.long 0x00 "PIGEON_1_0,Panel Interface Signal Generator Register 1_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "          "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "          "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "          "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "          "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "          "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 11.
group.long 0x850++0x3
    line.long 0x00 "PIGEON_1_1,Panel Interface Signal Generator Register 1_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "          "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 11.
group.long 0x860++0x3
    line.long 0x00 "PIGEON_1_2,Panel Interface Signal Generator Register 1_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "          "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"
width 11.
group.long 0x880++0x3
    line.long 0x00 "PIGEON_2_0,Panel Interface Signal Generator Register 2_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "          "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "          "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "          "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "          "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "          "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 11.
group.long 0x890++0x3
    line.long 0x00 "PIGEON_2_1,Panel Interface Signal Generator Register 2_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "          "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 11.
group.long 0x8a0++0x3
    line.long 0x00 "PIGEON_2_2,Panel Interface Signal Generator Register 2_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "          "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"
width 11.
group.long 0x8c0++0x3
    line.long 0x00 "PIGEON_3_0,Panel Interface Signal Generator Register 3_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "          "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "          "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "          "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "          "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "          "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 11.
group.long 0x8d0++0x3
    line.long 0x00 "PIGEON_3_1,Panel Interface Signal Generator Register 3_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "          "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 11.
group.long 0x8e0++0x3
    line.long 0x00 "PIGEON_3_2,Panel Interface Signal Generator Register 3_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "          "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"
width 11.
group.long 0x900++0x3
    line.long 0x00 "PIGEON_4_0,Panel Interface Signal Generator Register 4_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "          "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "          "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "          "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "          "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "          "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 11.
group.long 0x910++0x3
    line.long 0x00 "PIGEON_4_1,Panel Interface Signal Generator Register 4_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "          "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 11.
group.long 0x920++0x3
    line.long 0x00 "PIGEON_4_2,Panel Interface Signal Generator Register 4_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "          "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"
width 11.
group.long 0x940++0x3
    line.long 0x00 "PIGEON_5_0,Panel Interface Signal Generator Register 5_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "          "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "          "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "          "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "          "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "          "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 11.
group.long 0x950++0x3
    line.long 0x00 "PIGEON_5_1,Panel Interface Signal Generator Register 5_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "          "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 11.
group.long 0x960++0x3
    line.long 0x00 "PIGEON_5_2,Panel Interface Signal Generator Register 5_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "          "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"
width 11.
group.long 0x980++0x3
    line.long 0x00 "PIGEON_6_0,Panel Interface Signal Generator Register 6_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "          "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "          "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "          "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "          "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "          "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 11.
group.long 0x990++0x3
    line.long 0x00 "PIGEON_6_1,Panel Interface Signal Generator Register 6_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "          "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 11.
group.long 0x9a0++0x3
    line.long 0x00 "PIGEON_6_2,Panel Interface Signal Generator Register 6_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "          "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"
width 11.
group.long 0x9c0++0x3
    line.long 0x00 "PIGEON_7_0,Panel Interface Signal Generator Register 7_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "          "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "          "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "          "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "          "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "          "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 11.
group.long 0x9d0++0x3
    line.long 0x00 "PIGEON_7_1,Panel Interface Signal Generator Register 7_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "          "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 11.
group.long 0x9e0++0x3
    line.long 0x00 "PIGEON_7_2,Panel Interface Signal Generator Register 7_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "          "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"
width 11.
group.long 0xa00++0x3
    line.long 0x00 "PIGEON_8_0,Panel Interface Signal Generator Register 8_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "          "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "          "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "          "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "          "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "          "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 11.
group.long 0xa10++0x3
    line.long 0x00 "PIGEON_8_1,Panel Interface Signal Generator Register 8_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "          "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 11.
group.long 0xa20++0x3
    line.long 0x00 "PIGEON_8_2,Panel Interface Signal Generator Register 8_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "          "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"
width 11.
group.long 0xa40++0x3
    line.long 0x00 "PIGEON_9_0,Panel Interface Signal Generator Register 9_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "          "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "          "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "          "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "          "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "          "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 11.
group.long 0xa50++0x3
    line.long 0x00 "PIGEON_9_1,Panel Interface Signal Generator Register 9_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "          "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 11.
group.long 0xa60++0x3
    line.long 0x00 "PIGEON_9_2,Panel Interface Signal Generator Register 9_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "          "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"
width 12.
group.long 0xa80++0x3
    line.long 0x00 "PIGEON_10_0,Panel Interface Signal Generator Register 10_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "           "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "           "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "           "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "           "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "           "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 12.
group.long 0xa90++0x3
    line.long 0x00 "PIGEON_10_1,Panel Interface Signal Generator Register 10_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "           "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 12.
group.long 0xaa0++0x3
    line.long 0x00 "PIGEON_10_2,Panel Interface Signal Generator Register 10_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "           "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"
width 12.
group.long 0xac0++0x3
    line.long 0x00 "PIGEON_11_0,Panel Interface Signal Generator Register 11_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "           "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "           "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "           "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "           "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "           "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 12.
group.long 0xad0++0x3
    line.long 0x00 "PIGEON_11_1,Panel Interface Signal Generator Register 11_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "           "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 12.
group.long 0xae0++0x3
    line.long 0x00 "PIGEON_11_2,Panel Interface Signal Generator Register 11_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "           "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"
width 12.
group.long 0xb00++0x3
    line.long 0x00 "PIGEON_12_0,Panel Interface Signal Generator Register 12_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "           "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "           "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "           "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "           "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "           "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 12.
group.long 0xb10++0x3
    line.long 0x00 "PIGEON_12_1,Panel Interface Signal Generator Register 12_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "           "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 12.
group.long 0xb20++0x3
    line.long 0x00 "PIGEON_12_2,Panel Interface Signal Generator Register 12_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "           "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"
width 12.
group.long 0xb40++0x3
    line.long 0x00 "PIGEON_13_0,Panel Interface Signal Generator Register 13_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "           "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "           "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "           "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "           "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "           "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 12.
group.long 0xb50++0x3
    line.long 0x00 "PIGEON_13_1,Panel Interface Signal Generator Register 13_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "           "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 12.
group.long 0xb60++0x3
    line.long 0x00 "PIGEON_13_2,Panel Interface Signal Generator Register 13_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "           "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"
width 12.
group.long 0xb80++0x3
    line.long 0x00 "PIGEON_14_0,Panel Interface Signal Generator Register 14_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "           "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "           "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "           "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "           "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "           "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 12.
group.long 0xb90++0x3
    line.long 0x00 "PIGEON_14_1,Panel Interface Signal Generator Register 14_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "           "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 12.
group.long 0xba0++0x3
    line.long 0x00 "PIGEON_14_2,Panel Interface Signal Generator Register 14_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "           "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"
width 12.
group.long 0xbc0++0x3
    line.long 0x00 "PIGEON_15_0,Panel Interface Signal Generator Register 15_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "           "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "           "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "           "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "           "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "           "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 12.
group.long 0xbd0++0x3
    line.long 0x00 "PIGEON_15_1,Panel Interface Signal Generator Register 15_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "           "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 12.
group.long 0xbe0++0x3
    line.long 0x00 "PIGEON_15_2,Panel Interface Signal Generator Register 15_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "           "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"
width 12.
group.long 0xc10++0x3
    line.long 0x00 "WB_ADDR_TCE,EPDC Working Buffer Address for TCE"
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,Address for EPDC working buffer (only for TCE)."


tree.end



;--------------------------------------------------------------------------------
; EPIT
;--------------------------------------------------------------------------------
tree.open "EPIT"
    tree "EPIT1"
        base ad:0x020d0000

width 3.
group.long 0x0++0x3
    line.long 0x00 "CR,Control register"
        bitfld.long 0x00 0. " EN ,This bit enables the EPIT." "0,1"
        textline "  "
        bitfld.long 0x00 1. " ENMOD ,EPIT enable mode." "0,1"
        textline "  "
        bitfld.long 0x00 2. " OCIEN ,Output compare interrupt enable." "0,1"
        textline "  "
        bitfld.long 0x00 3. " RLD ,Counter reload control." "0,1"
        textline "  "
        hexmask.long.word 0x00 4.--16. 1. " PRESCALAR ,Counter clock prescaler value."
        textline "  "
        bitfld.long 0x00 16. " SWR ,Software reset." "0,1"
        textline "  "
        bitfld.long 0x00 17. " IOVW ,EPIT counter overwrite enable." "0,1"
        textline "  "
        bitfld.long 0x00 18. " DBGEN ,This bit is used to keep the EPIT functional in debug mode." "0,1"
        textline "  "
        bitfld.long 0x00 19. " WAITEN ,This read/write control bit enables the operation of the EPIT during wait mode." "0,1"
        textline "  "
        bitfld.long 0x00 21. " STOPEN ,EPIT stop mode enable." "0,1"
        textline "  "
        hexmask.long.byte 0x00 22.--24. 1. " OM ,EPIT output mode.This bit field determines the mode of EPIT output on the output pin."
        textline "  "
        hexmask.long.byte 0x00 24.--26. 1. " CLKSRC ,Select clock source These bits determine which clock input is to be selected for running the counter."
width 3.
group.long 0x4++0x3
    line.long 0x00 "SR,Status register"
        bitfld.long 0x00 0. " OCIF ,Output compare interrupt flag." "0,1"
width 3.
group.long 0x8++0x3
    line.long 0x00 "LR,Load register"
        hexmask.long.long 0x00 0.--32. 1. " LOAD ,Load value."
width 5.
group.long 0xc++0x3
    line.long 0x00 "CMPR,Compare register"
        hexmask.long.long 0x00 0.--32. 1. " COMPARE ,Compare Value."
width 4.
rgroup.long 0x10++0x3
    line.long 0x00 "CNR,Counter register"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Counter value."


    tree.end
    tree "EPIT2"
        base ad:0x020d4000

width 3.
group.long 0x0++0x3
    line.long 0x00 "CR,Control register"
        bitfld.long 0x00 0. " EN ,This bit enables the EPIT." "0,1"
        textline "  "
        bitfld.long 0x00 1. " ENMOD ,EPIT enable mode." "0,1"
        textline "  "
        bitfld.long 0x00 2. " OCIEN ,Output compare interrupt enable." "0,1"
        textline "  "
        bitfld.long 0x00 3. " RLD ,Counter reload control." "0,1"
        textline "  "
        hexmask.long.word 0x00 4.--16. 1. " PRESCALAR ,Counter clock prescaler value."
        textline "  "
        bitfld.long 0x00 16. " SWR ,Software reset." "0,1"
        textline "  "
        bitfld.long 0x00 17. " IOVW ,EPIT counter overwrite enable." "0,1"
        textline "  "
        bitfld.long 0x00 18. " DBGEN ,This bit is used to keep the EPIT functional in debug mode." "0,1"
        textline "  "
        bitfld.long 0x00 19. " WAITEN ,This read/write control bit enables the operation of the EPIT during wait mode." "0,1"
        textline "  "
        bitfld.long 0x00 21. " STOPEN ,EPIT stop mode enable." "0,1"
        textline "  "
        hexmask.long.byte 0x00 22.--24. 1. " OM ,EPIT output mode.This bit field determines the mode of EPIT output on the output pin."
        textline "  "
        hexmask.long.byte 0x00 24.--26. 1. " CLKSRC ,Select clock source These bits determine which clock input is to be selected for running the counter."
width 3.
group.long 0x4++0x3
    line.long 0x00 "SR,Status register"
        bitfld.long 0x00 0. " OCIF ,Output compare interrupt flag." "0,1"
width 3.
group.long 0x8++0x3
    line.long 0x00 "LR,Load register"
        hexmask.long.long 0x00 0.--32. 1. " LOAD ,Load value."
width 5.
group.long 0xc++0x3
    line.long 0x00 "CMPR,Compare register"
        hexmask.long.long 0x00 0.--32. 1. " COMPARE ,Compare Value."
width 4.
rgroup.long 0x10++0x3
    line.long 0x00 "CNR,Counter register"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Counter value."


    tree.end

tree.end



;--------------------------------------------------------------------------------
; FEC
;--------------------------------------------------------------------------------
tree "FEC"
    base ad:0x02188000

width 4.
group.long 0x4++0x3
    line.long 0x00 "EIR,Ethernet interrupt event register"
        bitfld.long 0x00 19. " UN ,Transmit FIFO underrun." "0,1"
        textline "   "
        bitfld.long 0x00 20. " RL ,Collision retry limit." "0,1"
        textline "   "
        bitfld.long 0x00 21. " LC ,Late collision." "0,1"
        textline "   "
        bitfld.long 0x00 22. " EBERR ,Ethernet bus error." "0,1"
        textline "   "
        bitfld.long 0x00 23. " MII ,MII interrupt." "0,1"
        textline "   "
        bitfld.long 0x00 24. " RXB ,Receive buffer interrupt." "0,1"
        textline "   "
        bitfld.long 0x00 25. " RXF ,Receive frame interrupt." "0,1"
        textline "   "
        bitfld.long 0x00 26. " TXB ,Transmit buffer interrupt." "0,1"
        textline "   "
        bitfld.long 0x00 27. " TXF ,Transmit frame interrupt." "0,1"
        textline "   "
        bitfld.long 0x00 28. " GRA ,Graceful stop complete." "0,1"
        textline "   "
        bitfld.long 0x00 29. " BABT ,Babbling transmit error." "0,1"
        textline "   "
        bitfld.long 0x00 30. " BABR ,Babbling receive error." "0,1"
        textline "   "
        bitfld.long 0x00 31. " HBERR ,Heartbeat error." "0,1"
width 5.
group.long 0x8++0x3
    line.long 0x00 "EIMR,Ethernet interrupt mask register"
        bitfld.long 0x00 19. " UN ,Interrupt mask." "0,1"
        textline "    "
        bitfld.long 0x00 20. " RL ,Interrupt mask." "0,1"
        textline "    "
        bitfld.long 0x00 21. " LC ,Interrupt mask." "0,1"
        textline "    "
        bitfld.long 0x00 22. " EBERR ,Interrupt mask." "0,1"
        textline "    "
        bitfld.long 0x00 23. " MII ,Interrupt mask." "0,1"
        textline "    "
        bitfld.long 0x00 24. " RXB ,Interrupt mask." "0,1"
        textline "    "
        bitfld.long 0x00 25. " RXF ,Interrupt mask." "0,1"
        textline "    "
        bitfld.long 0x00 26. " TXB ,Interrupt mask." "0,1"
        textline "    "
        bitfld.long 0x00 27. " TXF ,Interrupt mask." "0,1"
        textline "    "
        bitfld.long 0x00 28. " GRA ,Interrupt mask." "0,1"
        textline "    "
        bitfld.long 0x00 29. " BABT ,Interrupt mask." "0,1"
        textline "    "
        bitfld.long 0x00 30. " BABR ,Interrupt mask." "0,1"
        textline "    "
        bitfld.long 0x00 31. " HBERR ,Interrupt mask." "0,1"
width 5.
group.long 0x10++0x3
    line.long 0x00 "RDAR,Receive descriptor active register"
        bitfld.long 0x00 24. " R_DES_ACTIVE ,Set to one when this register is written, regardless of the value written." "0,1"
width 5.
group.long 0x14++0x3
    line.long 0x00 "TDAR,Transmit descriptor active register"
        bitfld.long 0x00 24. " X_DES_ACTIVE ,Set to one when this register is written, regardless of the value written." "0,1"
width 4.
group.long 0x24++0x3
    line.long 0x00 "ECR,Ethernet control register"
        bitfld.long 0x00 0. " RESET ,When this bit is set, the equivalent of a hardware reset is performed but it is local to the FEC, ETHER_EN is cleared and all other FEC registers take their reset values." "0,1"
        textline "   "
        bitfld.long 0x00 1. " ETHER_EN ,When this bit is set, the FEC is enabled, and reception and transmission are possible." "0,1"
width 5.
group.long 0x40++0x3
    line.long 0x00 "MMFR,MII management frame register"
        hexmask.long.word 0x00 0.--16. 1. " DATA ,Management frame data."
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " TA ,Turn around."
        textline "    "
        hexmask.long.byte 0x00 18.--23. 1. " RA ,Register address."
        textline "    "
        hexmask.long.byte 0x00 23.--28. 1. " PA ,PHY address."
        textline "    "
        hexmask.long.byte 0x00 28.--30. 1. " OP ,Operation code."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " ST ,Start of frame delimiter."
width 5.
group.long 0x44++0x3
    line.long 0x00 "MSCR,MII speed control register"
        hexmask.long.byte 0x00 1.--7. 1. " MII_SPEED ,MII_SPEED controls the frequency of the MII management interface clock (FEC_MDC) relative to the system clock."
        textline "    "
        bitfld.long 0x00 7. " DIS_PREAMBLE ,Asserting this bit causes preamble (0xFFFF_FFFF) not to be prepended to the MII management frame." "0,1"
width 5.
group.long 0x64++0x3
    line.long 0x00 "MIBC,MIB control register"
        bitfld.long 0x00 30. " MB_IDLE ,A read-only status bit." "0,1"
        textline "    "
        bitfld.long 0x00 31. " MIB_DISABLE ,A read/write control bit." "0,1"
width 4.
group.long 0x84++0x3
    line.long 0x00 "RCR,Receive control register"
        bitfld.long 0x00 0. " LOOP ,Internal loopback.When LOOP is set to 1, transmitted frames are looped back internal to the device and the transmit output signals are not asserted." "0,1"
        textline "   "
        bitfld.long 0x00 1. " DRT ,Disable receive on transmit." "0,1"
        textline "   "
        bitfld.long 0x00 2. " MII_MODE ,Media independent interface mode." "0,1"
        textline "   "
        bitfld.long 0x00 3. " PROM ,Promiscuous mode." "0,1"
        textline "   "
        bitfld.long 0x00 4. " BC_REJ ,Broadcast frame reject." "0,1"
        textline "   "
        bitfld.long 0x00 5. " FCE ,Flow control enable." "0,1"
        textline "   "
        hexmask.long.word 0x00 16.--27. 1. " MAX_FL ,Maximum frame length."
width 4.
group.long 0xc4++0x3
    line.long 0x00 "TCR,Transmit control register"
        bitfld.long 0x00 0. " GTS ,Graceful transmit stop." "0,1"
        textline "   "
        bitfld.long 0x00 1. " HBC ,Heartbeat control." "0,1"
        textline "   "
        bitfld.long 0x00 2. " FDEN ,Full duplex enable." "0,1"
        textline "   "
        bitfld.long 0x00 3. " TFC_PAUSE ,Transmit frame control pause." "0,1"
        textline "   "
        bitfld.long 0x00 4. " RFC_PAUSE ,Receive frame control pause." "0,1"
width 5.
group.long 0xe4++0x3
    line.long 0x00 "PALR,Physical address low register"
        hexmask.long.long 0x00 0.--32. 1. " PADDR1 ,Bytes 0 (bits 31:24), 1 (bits 23:16), 2 (bits 15:8) and 3 (bits 7:0) of the 6-byte individual address to be used for exact match, and the source address field in pause frames."
width 5.
group.long 0xe8++0x3
    line.long 0x00 "PAUR,Physical address upper register"
        hexmask.long.word 0x00 0.--16. 1. " TYPE ,Type field in pause frames."
        textline "    "
        hexmask.long.word 0x00 16.--32. 1. " PADDR2 ,Bytes 4 (bits 31:24) and 5 (bits 23:16) of the 6-byte individual address to be used for exact match, and the source address field in pause frames."
width 5.
group.long 0xec++0x3
    line.long 0x00 "OPDR,Opcode and pause duration register"
        hexmask.long.word 0x00 0.--16. 1. " PAUSE_DUR ,Pause duration field used in pause frames."
        textline "    "
        hexmask.long.word 0x00 16.--32. 1. " OPCODE ,Opcode field used in pause frames."
width 5.
group.long 0x118++0x3
    line.long 0x00 "IAUR,Descriptor individual address upper register"
        hexmask.long.long 0x00 0.--32. 1. " IADDR1 ,The upper 32 bits of the 64-bit hash table used in the address recognition process for receive frames with a unicast address."
width 5.
group.long 0x11c++0x3
    line.long 0x00 "IALR,Descriptor individual address lower register"
        hexmask.long.long 0x00 0.--32. 1. " IADDR2 ,The lower 32 bits of the 64-bit hash table used in the address recognition process for receive frames with a unicast address."
width 5.
group.long 0x120++0x3
    line.long 0x00 "GAUR,Descriptor group address upper register"
        hexmask.long.long 0x00 0.--32. 1. " GADDR1 ,The GADDR1 register contains the upper 32 bits of the 64-bit hash table used in the address recognition process for receive frames with a multicast address."
width 5.
group.long 0x124++0x3
    line.long 0x00 "GALR,Descriptor group address lower register"
        hexmask.long.long 0x00 0.--32. 1. " GADDR2 ,The GADDR2 register contains the lower 32 bits of the 64-bit hash table used in the address recognition process for receive frames with a multicast address."
width 5.
group.long 0x144++0x3
    line.long 0x00 "TFWR,Transmit FIFO watermark register"
        hexmask.long.byte 0x00 0.--2. 1. " X_WMRK ,Number of bytes written to transmit FIFO before transmission of a frame begins"
width 5.
rgroup.long 0x14c++0x3
    line.long 0x00 "FRBR,FIFO receive bound register"
        hexmask.long.byte 0x00 2.--10. 1. " R_BOUND ,Read-only."
width 5.
group.long 0x150++0x3
    line.long 0x00 "FRSR,FIFO receive FIFO start registers"
        hexmask.long.byte 0x00 2.--10. 1. " R_FSTART ,Address of first receive FIFO location."
width 6.
group.long 0x180++0x3
    line.long 0x00 "ERDSR,Receive buffer descriptor ring start register"
        hexmask.long.long 0x00 2.--32. 1. " R_DES_START ,Pointer to start of receive buffer descriptor queue."
width 6.
group.long 0x184++0x3
    line.long 0x00 "ETDSR,Transmit buffer descriptor ring start register"
        hexmask.long.long 0x00 2.--32. 1. " X_DES_START ,Pointer to start of transmit buffer descriptor queue."
width 6.
group.long 0x188++0x3
    line.long 0x00 "EMRBR,Maximum receive buffer size register"
        hexmask.long.byte 0x00 4.--11. 1. " R_BUF_SIZE ,Receive buffer size."


tree.end



;--------------------------------------------------------------------------------
; GPC
;--------------------------------------------------------------------------------
tree "GPC"
    base ad:0x020dc000

width 5.
group.long 0x0++0x3
    line.long 0x00 "CNTR,GPC Interface control register"
        bitfld.long 0x00 0. " GPU_VPU_PDN_REQ ,GPU Power Down request." "0,1"
        textline "    "
        bitfld.long 0x00 1. " GPU_VPU_PUP_REQ ,GPU Power Up request." "0,1"
        textline "    "
        bitfld.long 0x00 4. " DISPLAY_PDN_REQ ,Display Power Down request." "0,1"
        textline "    "
        bitfld.long 0x00 5. " DISPLAY_PUP_REQ ,Display Power Up request." "0,1"
        textline "    "
        bitfld.long 0x00 16. " DVFS0CR ,DVFS0 (ARM) Change request (bit is read-only)" "0,1"
        textline "    "
        bitfld.long 0x00 21. " GPCIRQM ,GPC interrupt/event masking" "0,1"
        textline "    "
        bitfld.long 0x00 22. " L2_PGE ,L2 Cache Power Gate Enable" "0,1"
width 4.
group.long 0x4++0x3
    line.long 0x00 "PGR,GPC Power Gating Register"
        hexmask.long.byte 0x00 29.--31. 1. " DRCIC ,Debug ref cir in mux control"
width 5.
group.long 0x8++0x3
    line.long 0x00 "IMR1,IRQ masking register 1"
        hexmask.long.long 0x00 0.--32. 1. " IMR1 ,IRQ[63:32] masking bits: 1-irq masked, 0-irq is not masked"
width 5.
group.long 0xc++0x3
    line.long 0x00 "IMR2,IRQ masking register 2"
        hexmask.long.long 0x00 0.--32. 1. " IMR2 ,IRQ[95:64] masking bits: 1-irq masked, 0-irq is not masked"
width 5.
group.long 0x10++0x3
    line.long 0x00 "IMR3,IRQ masking register 3"
        hexmask.long.long 0x00 0.--32. 1. " IMR3 ,IRQ[127:96] masking bits: 1-irq masked, 0-irq is not masked"
width 5.
group.long 0x14++0x3
    line.long 0x00 "IMR4,IRQ masking register 4"
        hexmask.long.long 0x00 0.--32. 1. " IMR4 ,IRQ[159:128] masking bits: 1-irq masked, 0-irq is not masked"
width 5.
rgroup.long 0x18++0x3
    line.long 0x00 "ISR1,IRQ status resister 1"
        hexmask.long.long 0x00 0.--32. 1. " ISR1 ,IRQ[63:32] status, read only"
width 5.
rgroup.long 0x1c++0x3
    line.long 0x00 "ISR2,IRQ status resister 2"
        hexmask.long.long 0x00 0.--32. 1. " ISR2 ,IRQ[95:64] status, read only"
width 5.
rgroup.long 0x20++0x3
    line.long 0x00 "ISR3,IRQ status resister 3"
        hexmask.long.long 0x00 0.--32. 1. " ISR3 ,IRQ[127:96] status, read only"
width 5.
rgroup.long 0x24++0x3
    line.long 0x00 "ISR4,IRQ status resister 4"
        hexmask.long.long 0x00 0.--32. 1. " ISR4 ,IRQ[159:128] status, read only"


tree.end



;--------------------------------------------------------------------------------
; GPIO
;--------------------------------------------------------------------------------
tree.open "GPIO"
    tree "GPIO1"
        base ad:0x0209c000

width 3.
group.long 0x0++0x3
    line.long 0x00 "DR,GPIO data register"
        hexmask.long.long 0x00 0.--32. 1. " DR ,Data bits."
width 5.
group.long 0x4++0x3
    line.long 0x00 "GDIR,GPIO direction register"
        hexmask.long.long 0x00 0.--32. 1. " GDIR ,GPIO direction bits."
width 4.
rgroup.long 0x8++0x3
    line.long 0x00 "PSR,GPIO pad status register"
        hexmask.long.long 0x00 0.--32. 1. " PSR ,GPIO pad status bits (status bits)."
width 5.
group.long 0xc++0x3
    line.long 0x00 "ICR1,GPIO interrupt configuration register1"
        hexmask.long.byte 0x00 0.--2. 1. " ICR0 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " ICR1 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ICR2 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " ICR3 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " ICR4 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICR5 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " ICR6 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " ICR7 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ICR8 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 18.--20. 1. " ICR9 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " ICR10 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 22.--24. 1. " ICR11 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 24.--26. 1. " ICR12 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 26.--28. 1. " ICR13 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 28.--30. 1. " ICR14 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " ICR15 ,Interrupt configuration 1 fields."
width 5.
group.long 0x10++0x3
    line.long 0x00 "ICR2,GPIO interrupt configuration register2"
        hexmask.long.byte 0x00 0.--2. 1. " ICR16 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " ICR17 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ICR18 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " ICR19 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " ICR20 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICR21 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " ICR22 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " ICR23 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ICR24 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 18.--20. 1. " ICR25 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " ICR26 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 22.--24. 1. " ICR27 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 24.--26. 1. " ICR28 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 26.--28. 1. " ICR29 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 28.--30. 1. " ICR30 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " ICR31 ,Interrupt configuration 2 fields."
width 4.
group.long 0x14++0x3
    line.long 0x00 "IMR,GPIO interrupt mask register"
        hexmask.long.long 0x00 0.--32. 1. " IMR ,Interrupt Mask bits."
width 4.
group.long 0x18++0x3
    line.long 0x00 "ISR,GPIO interrupt status register"
        hexmask.long.long 0x00 0.--32. 1. " ISR ,Interrupt status bits - Bit n of this register is asserted (active high) when the active condition (as determined by the corresponding ICR bit) is detected on the GPIO input and is waiting for service."
width 9.
group.long 0x1c++0x3
    line.long 0x00 "EDGE_SEL,GPIO edge select register"
        hexmask.long.long 0x00 0.--32. 1. " GPIO_EDGE_SEL ,Edge select."


    tree.end
    tree "GPIO2"
        base ad:0x020a0000

width 3.
group.long 0x0++0x3
    line.long 0x00 "DR,GPIO data register"
        hexmask.long.long 0x00 0.--32. 1. " DR ,Data bits."
width 5.
group.long 0x4++0x3
    line.long 0x00 "GDIR,GPIO direction register"
        hexmask.long.long 0x00 0.--32. 1. " GDIR ,GPIO direction bits."
width 4.
rgroup.long 0x8++0x3
    line.long 0x00 "PSR,GPIO pad status register"
        hexmask.long.long 0x00 0.--32. 1. " PSR ,GPIO pad status bits (status bits)."
width 5.
group.long 0xc++0x3
    line.long 0x00 "ICR1,GPIO interrupt configuration register1"
        hexmask.long.byte 0x00 0.--2. 1. " ICR0 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " ICR1 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ICR2 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " ICR3 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " ICR4 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICR5 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " ICR6 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " ICR7 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ICR8 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 18.--20. 1. " ICR9 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " ICR10 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 22.--24. 1. " ICR11 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 24.--26. 1. " ICR12 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 26.--28. 1. " ICR13 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 28.--30. 1. " ICR14 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " ICR15 ,Interrupt configuration 1 fields."
width 5.
group.long 0x10++0x3
    line.long 0x00 "ICR2,GPIO interrupt configuration register2"
        hexmask.long.byte 0x00 0.--2. 1. " ICR16 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " ICR17 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ICR18 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " ICR19 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " ICR20 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICR21 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " ICR22 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " ICR23 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ICR24 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 18.--20. 1. " ICR25 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " ICR26 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 22.--24. 1. " ICR27 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 24.--26. 1. " ICR28 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 26.--28. 1. " ICR29 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 28.--30. 1. " ICR30 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " ICR31 ,Interrupt configuration 2 fields."
width 4.
group.long 0x14++0x3
    line.long 0x00 "IMR,GPIO interrupt mask register"
        hexmask.long.long 0x00 0.--32. 1. " IMR ,Interrupt Mask bits."
width 4.
group.long 0x18++0x3
    line.long 0x00 "ISR,GPIO interrupt status register"
        hexmask.long.long 0x00 0.--32. 1. " ISR ,Interrupt status bits - Bit n of this register is asserted (active high) when the active condition (as determined by the corresponding ICR bit) is detected on the GPIO input and is waiting for service."
width 9.
group.long 0x1c++0x3
    line.long 0x00 "EDGE_SEL,GPIO edge select register"
        hexmask.long.long 0x00 0.--32. 1. " GPIO_EDGE_SEL ,Edge select."


    tree.end
    tree "GPIO3"
        base ad:0x020a4000

width 3.
group.long 0x0++0x3
    line.long 0x00 "DR,GPIO data register"
        hexmask.long.long 0x00 0.--32. 1. " DR ,Data bits."
width 5.
group.long 0x4++0x3
    line.long 0x00 "GDIR,GPIO direction register"
        hexmask.long.long 0x00 0.--32. 1. " GDIR ,GPIO direction bits."
width 4.
rgroup.long 0x8++0x3
    line.long 0x00 "PSR,GPIO pad status register"
        hexmask.long.long 0x00 0.--32. 1. " PSR ,GPIO pad status bits (status bits)."
width 5.
group.long 0xc++0x3
    line.long 0x00 "ICR1,GPIO interrupt configuration register1"
        hexmask.long.byte 0x00 0.--2. 1. " ICR0 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " ICR1 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ICR2 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " ICR3 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " ICR4 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICR5 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " ICR6 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " ICR7 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ICR8 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 18.--20. 1. " ICR9 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " ICR10 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 22.--24. 1. " ICR11 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 24.--26. 1. " ICR12 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 26.--28. 1. " ICR13 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 28.--30. 1. " ICR14 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " ICR15 ,Interrupt configuration 1 fields."
width 5.
group.long 0x10++0x3
    line.long 0x00 "ICR2,GPIO interrupt configuration register2"
        hexmask.long.byte 0x00 0.--2. 1. " ICR16 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " ICR17 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ICR18 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " ICR19 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " ICR20 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICR21 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " ICR22 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " ICR23 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ICR24 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 18.--20. 1. " ICR25 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " ICR26 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 22.--24. 1. " ICR27 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 24.--26. 1. " ICR28 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 26.--28. 1. " ICR29 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 28.--30. 1. " ICR30 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " ICR31 ,Interrupt configuration 2 fields."
width 4.
group.long 0x14++0x3
    line.long 0x00 "IMR,GPIO interrupt mask register"
        hexmask.long.long 0x00 0.--32. 1. " IMR ,Interrupt Mask bits."
width 4.
group.long 0x18++0x3
    line.long 0x00 "ISR,GPIO interrupt status register"
        hexmask.long.long 0x00 0.--32. 1. " ISR ,Interrupt status bits - Bit n of this register is asserted (active high) when the active condition (as determined by the corresponding ICR bit) is detected on the GPIO input and is waiting for service."
width 9.
group.long 0x1c++0x3
    line.long 0x00 "EDGE_SEL,GPIO edge select register"
        hexmask.long.long 0x00 0.--32. 1. " GPIO_EDGE_SEL ,Edge select."


    tree.end
    tree "GPIO4"
        base ad:0x020a8000

width 3.
group.long 0x0++0x3
    line.long 0x00 "DR,GPIO data register"
        hexmask.long.long 0x00 0.--32. 1. " DR ,Data bits."
width 5.
group.long 0x4++0x3
    line.long 0x00 "GDIR,GPIO direction register"
        hexmask.long.long 0x00 0.--32. 1. " GDIR ,GPIO direction bits."
width 4.
rgroup.long 0x8++0x3
    line.long 0x00 "PSR,GPIO pad status register"
        hexmask.long.long 0x00 0.--32. 1. " PSR ,GPIO pad status bits (status bits)."
width 5.
group.long 0xc++0x3
    line.long 0x00 "ICR1,GPIO interrupt configuration register1"
        hexmask.long.byte 0x00 0.--2. 1. " ICR0 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " ICR1 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ICR2 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " ICR3 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " ICR4 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICR5 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " ICR6 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " ICR7 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ICR8 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 18.--20. 1. " ICR9 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " ICR10 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 22.--24. 1. " ICR11 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 24.--26. 1. " ICR12 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 26.--28. 1. " ICR13 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 28.--30. 1. " ICR14 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " ICR15 ,Interrupt configuration 1 fields."
width 5.
group.long 0x10++0x3
    line.long 0x00 "ICR2,GPIO interrupt configuration register2"
        hexmask.long.byte 0x00 0.--2. 1. " ICR16 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " ICR17 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ICR18 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " ICR19 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " ICR20 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICR21 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " ICR22 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " ICR23 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ICR24 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 18.--20. 1. " ICR25 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " ICR26 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 22.--24. 1. " ICR27 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 24.--26. 1. " ICR28 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 26.--28. 1. " ICR29 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 28.--30. 1. " ICR30 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " ICR31 ,Interrupt configuration 2 fields."
width 4.
group.long 0x14++0x3
    line.long 0x00 "IMR,GPIO interrupt mask register"
        hexmask.long.long 0x00 0.--32. 1. " IMR ,Interrupt Mask bits."
width 4.
group.long 0x18++0x3
    line.long 0x00 "ISR,GPIO interrupt status register"
        hexmask.long.long 0x00 0.--32. 1. " ISR ,Interrupt status bits - Bit n of this register is asserted (active high) when the active condition (as determined by the corresponding ICR bit) is detected on the GPIO input and is waiting for service."
width 9.
group.long 0x1c++0x3
    line.long 0x00 "EDGE_SEL,GPIO edge select register"
        hexmask.long.long 0x00 0.--32. 1. " GPIO_EDGE_SEL ,Edge select."


    tree.end
    tree "GPIO5"
        base ad:0x020ac000

width 3.
group.long 0x0++0x3
    line.long 0x00 "DR,GPIO data register"
        hexmask.long.long 0x00 0.--32. 1. " DR ,Data bits."
width 5.
group.long 0x4++0x3
    line.long 0x00 "GDIR,GPIO direction register"
        hexmask.long.long 0x00 0.--32. 1. " GDIR ,GPIO direction bits."
width 4.
rgroup.long 0x8++0x3
    line.long 0x00 "PSR,GPIO pad status register"
        hexmask.long.long 0x00 0.--32. 1. " PSR ,GPIO pad status bits (status bits)."
width 5.
group.long 0xc++0x3
    line.long 0x00 "ICR1,GPIO interrupt configuration register1"
        hexmask.long.byte 0x00 0.--2. 1. " ICR0 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " ICR1 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ICR2 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " ICR3 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " ICR4 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICR5 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " ICR6 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " ICR7 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ICR8 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 18.--20. 1. " ICR9 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " ICR10 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 22.--24. 1. " ICR11 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 24.--26. 1. " ICR12 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 26.--28. 1. " ICR13 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 28.--30. 1. " ICR14 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " ICR15 ,Interrupt configuration 1 fields."
width 5.
group.long 0x10++0x3
    line.long 0x00 "ICR2,GPIO interrupt configuration register2"
        hexmask.long.byte 0x00 0.--2. 1. " ICR16 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " ICR17 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ICR18 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " ICR19 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " ICR20 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICR21 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " ICR22 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " ICR23 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ICR24 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 18.--20. 1. " ICR25 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " ICR26 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 22.--24. 1. " ICR27 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 24.--26. 1. " ICR28 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 26.--28. 1. " ICR29 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 28.--30. 1. " ICR30 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " ICR31 ,Interrupt configuration 2 fields."
width 4.
group.long 0x14++0x3
    line.long 0x00 "IMR,GPIO interrupt mask register"
        hexmask.long.long 0x00 0.--32. 1. " IMR ,Interrupt Mask bits."
width 4.
group.long 0x18++0x3
    line.long 0x00 "ISR,GPIO interrupt status register"
        hexmask.long.long 0x00 0.--32. 1. " ISR ,Interrupt status bits - Bit n of this register is asserted (active high) when the active condition (as determined by the corresponding ICR bit) is detected on the GPIO input and is waiting for service."
width 9.
group.long 0x1c++0x3
    line.long 0x00 "EDGE_SEL,GPIO edge select register"
        hexmask.long.long 0x00 0.--32. 1. " GPIO_EDGE_SEL ,Edge select."


    tree.end
    tree "GPIO6"
        base ad:0x020b0000

width 3.
group.long 0x0++0x3
    line.long 0x00 "DR,GPIO data register"
        hexmask.long.long 0x00 0.--32. 1. " DR ,Data bits."
width 5.
group.long 0x4++0x3
    line.long 0x00 "GDIR,GPIO direction register"
        hexmask.long.long 0x00 0.--32. 1. " GDIR ,GPIO direction bits."
width 4.
rgroup.long 0x8++0x3
    line.long 0x00 "PSR,GPIO pad status register"
        hexmask.long.long 0x00 0.--32. 1. " PSR ,GPIO pad status bits (status bits)."
width 5.
group.long 0xc++0x3
    line.long 0x00 "ICR1,GPIO interrupt configuration register1"
        hexmask.long.byte 0x00 0.--2. 1. " ICR0 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " ICR1 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ICR2 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " ICR3 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " ICR4 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICR5 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " ICR6 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " ICR7 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ICR8 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 18.--20. 1. " ICR9 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " ICR10 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 22.--24. 1. " ICR11 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 24.--26. 1. " ICR12 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 26.--28. 1. " ICR13 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 28.--30. 1. " ICR14 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " ICR15 ,Interrupt configuration 1 fields."
width 5.
group.long 0x10++0x3
    line.long 0x00 "ICR2,GPIO interrupt configuration register2"
        hexmask.long.byte 0x00 0.--2. 1. " ICR16 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " ICR17 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ICR18 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " ICR19 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " ICR20 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICR21 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " ICR22 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " ICR23 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ICR24 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 18.--20. 1. " ICR25 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " ICR26 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 22.--24. 1. " ICR27 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 24.--26. 1. " ICR28 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 26.--28. 1. " ICR29 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 28.--30. 1. " ICR30 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " ICR31 ,Interrupt configuration 2 fields."
width 4.
group.long 0x14++0x3
    line.long 0x00 "IMR,GPIO interrupt mask register"
        hexmask.long.long 0x00 0.--32. 1. " IMR ,Interrupt Mask bits."
width 4.
group.long 0x18++0x3
    line.long 0x00 "ISR,GPIO interrupt status register"
        hexmask.long.long 0x00 0.--32. 1. " ISR ,Interrupt status bits - Bit n of this register is asserted (active high) when the active condition (as determined by the corresponding ICR bit) is detected on the GPIO input and is waiting for service."
width 9.
group.long 0x1c++0x3
    line.long 0x00 "EDGE_SEL,GPIO edge select register"
        hexmask.long.long 0x00 0.--32. 1. " GPIO_EDGE_SEL ,Edge select."


    tree.end
    tree "GPIO7"
        base ad:0x020b4000

width 3.
group.long 0x0++0x3
    line.long 0x00 "DR,GPIO data register"
        hexmask.long.long 0x00 0.--32. 1. " DR ,Data bits."
width 5.
group.long 0x4++0x3
    line.long 0x00 "GDIR,GPIO direction register"
        hexmask.long.long 0x00 0.--32. 1. " GDIR ,GPIO direction bits."
width 4.
rgroup.long 0x8++0x3
    line.long 0x00 "PSR,GPIO pad status register"
        hexmask.long.long 0x00 0.--32. 1. " PSR ,GPIO pad status bits (status bits)."
width 5.
group.long 0xc++0x3
    line.long 0x00 "ICR1,GPIO interrupt configuration register1"
        hexmask.long.byte 0x00 0.--2. 1. " ICR0 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " ICR1 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ICR2 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " ICR3 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " ICR4 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICR5 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " ICR6 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " ICR7 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ICR8 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 18.--20. 1. " ICR9 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " ICR10 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 22.--24. 1. " ICR11 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 24.--26. 1. " ICR12 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 26.--28. 1. " ICR13 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 28.--30. 1. " ICR14 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " ICR15 ,Interrupt configuration 1 fields."
width 5.
group.long 0x10++0x3
    line.long 0x00 "ICR2,GPIO interrupt configuration register2"
        hexmask.long.byte 0x00 0.--2. 1. " ICR16 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " ICR17 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ICR18 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " ICR19 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " ICR20 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICR21 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " ICR22 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " ICR23 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ICR24 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 18.--20. 1. " ICR25 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " ICR26 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 22.--24. 1. " ICR27 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 24.--26. 1. " ICR28 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 26.--28. 1. " ICR29 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 28.--30. 1. " ICR30 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " ICR31 ,Interrupt configuration 2 fields."
width 4.
group.long 0x14++0x3
    line.long 0x00 "IMR,GPIO interrupt mask register"
        hexmask.long.long 0x00 0.--32. 1. " IMR ,Interrupt Mask bits."
width 4.
group.long 0x18++0x3
    line.long 0x00 "ISR,GPIO interrupt status register"
        hexmask.long.long 0x00 0.--32. 1. " ISR ,Interrupt status bits - Bit n of this register is asserted (active high) when the active condition (as determined by the corresponding ICR bit) is detected on the GPIO input and is waiting for service."
width 9.
group.long 0x1c++0x3
    line.long 0x00 "EDGE_SEL,GPIO edge select register"
        hexmask.long.long 0x00 0.--32. 1. " GPIO_EDGE_SEL ,Edge select."


    tree.end

tree.end



;--------------------------------------------------------------------------------
; GPT
;--------------------------------------------------------------------------------
tree "GPT"
    base ad:0x02098000

width 3.
group.long 0x0++0x3
    line.long 0x00 "CR,GPT Control Register"
        bitfld.long 0x00 0. " EN ,GPT Enable." "0,1"
        textline "  "
        bitfld.long 0x00 1. " ENMOD ,GPT Enable mode." "0,1"
        textline "  "
        bitfld.long 0x00 2. " DBGEN ,GPT debug mode enable." "0,1"
        textline "  "
        bitfld.long 0x00 3. " WAITEN ,GPT Wait Mode enable." "0,1"
        textline "  "
        bitfld.long 0x00 4. " DOZEEN ,GPT Doze Mode Enable." "0,1"
        textline "  "
        bitfld.long 0x00 5. " STOPEN ,GPT Stop Mode enable." "0,1"
        textline "  "
        hexmask.long.byte 0x00 6.--9. 1. " CLKSRC ,Clock Source select."
        textline "  "
        bitfld.long 0x00 9. " FRR ,Free-Run or Restart mode." "0,1"
        textline "  "
        bitfld.long 0x00 10. " _24MEN ,Enable 24MHz clock input from crystal." "0,1"
        textline "  "
        bitfld.long 0x00 15. " SWR ,Software reset." "0,1"
        textline "  "
        hexmask.long.byte 0x00 16.--18. 1. " IM1 ,See IM2"
        textline "  "
        hexmask.long.byte 0x00 18.--20. 1. " IM2 ,IM2 (bits 19-18, Input Capture Channel 2 operating mode) IM1 (bits 17-16, Input Capture Channel 1 operating mode) The IM n bit field determines the transition on the input pin (for Input capture channel n ), which will trigger a capture event."
        textline "  "
        hexmask.long.byte 0x00 20.--23. 1. " OM1 ,See OM3"
        textline "  "
        hexmask.long.byte 0x00 23.--26. 1. " OM2 ,See OM3"
        textline "  "
        hexmask.long.byte 0x00 26.--29. 1. " OM3 ,OM3 (bits 28-26) controls the Output Compare Channel 3 operating mode."
        textline "  "
        bitfld.long 0x00 29. " FO1 ,See F03" "0,1"
        textline "  "
        bitfld.long 0x00 30. " FO2 ,See F03" "0,1"
        textline "  "
        bitfld.long 0x00 31. " FO3 ,FO3 Force Output Compare Channel 3 FO2 Force Output Compare Channel 2 FO1 Force Output Compare Channel 1 The FO n bit causes the pin action programmed for the timer Output Compare n pin (according to the OM n bits in this register)." "0,1"
width 3.
group.long 0x4++0x3
    line.long 0x00 "PR,GPT Prescaler Register"
        hexmask.long.word 0x00 0.--12. 1. " PRESCALER ,Prescaler bits."
        textline "  "
        hexmask.long.byte 0x00 12.--16. 1. " PRESCALER24M ,Prescaler bits."
width 3.
group.long 0x8++0x3
    line.long 0x00 "SR,GPT Status Register"
        bitfld.long 0x00 0. " OF1 ,See OF3" "0,1"
        textline "  "
        bitfld.long 0x00 1. " OF2 ,See OF3" "0,1"
        textline "  "
        bitfld.long 0x00 2. " OF3 ,OF3 Output Compare 3 Flag OF2 Output Compare 2 Flag OF1 Output Compare 1 Flag The OF n bit indicates that a compare event has occurred on Output Compare channel n ." "0,1"
        textline "  "
        bitfld.long 0x00 3. " IF1 ,See IF2" "0,1"
        textline "  "
        bitfld.long 0x00 4. " IF2 ,IF2 Input capture 2 Flag IF1 Input capture 1 Flag The IF n bit indicates that a capture event has occurred on Input Capture channel n ." "0,1"
        textline "  "
        bitfld.long 0x00 5. " ROV ,Rollover Flag." "0,1"
width 3.
group.long 0xc++0x3
    line.long 0x00 "IR,GPT Interrupt Register"
        bitfld.long 0x00 0. " OF1IE ,See OF3IE" "0,1"
        textline "  "
        bitfld.long 0x00 1. " OF2IE ,See OF3IE" "0,1"
        textline "  "
        bitfld.long 0x00 2. " OF3IE ,OF3IE Output Compare 3 Interrupt Enable OF2IE Output Compare 2 Interrupt Enable OF1IE Output Compare 1 Interrupt Enable The OF n IE bit controls the Output Compare Channel n interrupt." "0,1"
        textline "  "
        bitfld.long 0x00 3. " IF1IE ,See IF2IE" "0,1"
        textline "  "
        bitfld.long 0x00 4. " IF2IE ,IF2IE Input capture 2 Interrupt Enable IF1IE Input capture 1 Interrupt Enable The IF n IE bit controls the IF n IE Input Capture n Interrupt Enable." "0,1"
        textline "  "
        bitfld.long 0x00 5. " ROVIE ,Rollover Interrupt Enable." "0,1"
width 5.
group.long 0x10++0x3
    line.long 0x00 "OCR1,GPT Output Compare Register 1"
        hexmask.long.long 0x00 0.--32. 1. " COMP ,Compare Value."
width 5.
group.long 0x14++0x3
    line.long 0x00 "OCR2,GPT Output Compare Register 2"
        hexmask.long.long 0x00 0.--32. 1. " COMP ,Compare Value."
width 5.
group.long 0x18++0x3
    line.long 0x00 "OCR3,GPT Output Compare Register 3"
        hexmask.long.long 0x00 0.--32. 1. " COMP ,Compare Value."
width 5.
rgroup.long 0x1c++0x3
    line.long 0x00 "ICR1,GPT Input Capture Register 1"
        hexmask.long.long 0x00 0.--32. 1. " CAPT ,Capture Value."
width 5.
rgroup.long 0x20++0x3
    line.long 0x00 "ICR2,GPT Input Capture Register 2"
        hexmask.long.long 0x00 0.--32. 1. " CAPT ,Capture Value."
width 4.
rgroup.long 0x24++0x3
    line.long 0x00 "CNT,GPT Counter Register"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Counter Value."


tree.end



;--------------------------------------------------------------------------------
; GPU2D
;--------------------------------------------------------------------------------
tree "GPU2D"
    base ad:0x00134000

width 17.
group.long 0x0++0x3
    line.long 0x00 "AQHICLOCKCONTROL,Clock Control Register"
        hexmask.long.byte 0x00 4.--8. 1. " MULTI_PIPE_USE_SINGLE_AXI ,Force all the transactions to go to one AXI."
        textline "                "
        hexmask.long.byte 0x00 8.--12. 1. " MULTI_PIPE_REG_SELECT ,Determines which HI/MC to use while reading registers."
        textline "                "
        bitfld.long 0x00 12. " ISOLATE_GPU ,Isolate GPU bit" "0,1"
        textline "                "
        bitfld.long 0x00 13. " IDLE_VG ,VG pipe is idle." "0,1"
        textline "                "
        bitfld.long 0x00 14. " IDLE2_D ,2D pipe is idle." "0,1"
        textline "                "
        bitfld.long 0x00 15. " IDLE3_D ,3D pipe is idle." "0,1"
        textline "                "
        bitfld.long 0x00 19. " SOFT_RESET ,Soft resets the IP." "0,1"
        textline "                "
        bitfld.long 0x00 20. " DISABLE_DEBUG_REGISTERS ,Disable debug registers." "0,1"
        textline "                "
        bitfld.long 0x00 21. " DISABLE_RAM_CLOCK_GATING ,Disables clock gating for rams." "0,1"
        textline "                "
        bitfld.long 0x00 22. " FSCALE_CMD_LOAD ,FSCALE Command Load bit" "0,1"
        textline "                "
        hexmask.long.byte 0x00 23.--30. 1. " FSCALE_VAL ,FSCALE Val"
        textline "                "
        bitfld.long 0x00 30. " CLK2D_DIS ,Disable 2D clock." "0,1"
        textline "                "
        bitfld.long 0x00 31. " CLK3D_DIS ,Disable 3D clock." "0,1"
width 9.
rgroup.long 0x4++0x3
    line.long 0x00 "AQHIIDLE,Idle Status Register"
        bitfld.long 0x00 0. " AXI_LP ,AXI is in low power mode." "0,1"
        textline "        "
        bitfld.long 0x00 20. " IDLE_TS ,TS is idle." "0,1"
        textline "        "
        bitfld.long 0x00 21. " IDLE_FP ,FP is idle." "0,1"
        textline "        "
        bitfld.long 0x00 22. " IDLE_IM ,IM is idle." "0,1"
        textline "        "
        bitfld.long 0x00 23. " IDLE_VG ,VG is idle." "0,1"
        textline "        "
        bitfld.long 0x00 24. " IDLE_TX ,TX is idle." "0,1"
        textline "        "
        bitfld.long 0x00 25. " IDLE_RA ,RA is idle." "0,1"
        textline "        "
        bitfld.long 0x00 26. " IDLE_SE ,SE is idle." "0,1"
        textline "        "
        bitfld.long 0x00 27. " IDLE_PA ,PA is idle." "0,1"
        textline "        "
        bitfld.long 0x00 28. " IDLE_SH ,SH is idle." "0,1"
        textline "        "
        bitfld.long 0x00 29. " IDLE_PE ,PE is idle." "0,1"
        textline "        "
        bitfld.long 0x00 30. " IDLE_DE ,DE is idle." "0,1"
        textline "        "
        bitfld.long 0x00 31. " IDLE_FE ,FE is idle." "0,1"
width 12.
group.long 0x8++0x3
    line.long 0x00 "AQAXICONFIG,AXI Configuration Register"
        hexmask.long.byte 0x00 16.--20. 1. " ARCACHE ,AR Cache"
        textline "           "
        hexmask.long.byte 0x00 20.--24. 1. " AWCACHE ,AW Cache"
        textline "           "
        hexmask.long.byte 0x00 24.--28. 1. " ARID ,AR ID"
        textline "           "
        hexmask.long.byte 0x00 28.--32. 1. " AWID ,AW ID"
width 12.
group.long 0xc++0x3
    line.long 0x00 "AQAXISTATUS,AXI Status Register"
        hexmask.long.byte 0x00 0.--4. 1. " WR_ERR_ID ,WR_ERR_ID bit"
        textline "           "
        hexmask.long.byte 0x00 4.--8. 1. " RD_ERR_ID ,RD_ERR_ID bit"
        textline "           "
        bitfld.long 0x00 8. " DET_WR_ERR ,DET_WR_ERR bit" "0,1"
        textline "           "
        bitfld.long 0x00 9. " DET_RD_ERR ,DET_RD_ERR bit" "0,1"
width 18.
rgroup.long 0x10++0x3
    line.long 0x00 "AQINTRACKNOWLEDGE,Interrupt Acknowledge Register"
        hexmask.long.long 0x00 0.--32. 1. " INTR_VEC ,Interrupt VEC"
width 11.
group.long 0x14++0x3
    line.long 0x00 "AQINTRENBL,Interrupt Enable Register"
        hexmask.long.long 0x00 0.--32. 1. " INTR_ENBL_VEC ,Interrupt enable VEC"
width 8.
rgroup.long 0x18++0x3
    line.long 0x00 "AQIDENT,Identification Register"
        hexmask.long.byte 0x00 0.--8. 1. " CUSTOMER ,Customer value."
        textline "       "
        hexmask.long.byte 0x00 8.--12. 1. " TECHNOLOGY ,Technology value."
        textline "       "
        hexmask.long.byte 0x00 12.--16. 1. " REVISION ,Revision value."
        textline "       "
        hexmask.long.byte 0x00 16.--24. 1. " PRODUCT ,Product value."
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " FAMILY ,Family value."
width 9.
rgroup.long 0x1c++0x3
    line.long 0x00 "FEATURES,Features Register"
        bitfld.long 0x00 0. " FE20_BIT_INDEX ,Supports 20 bit index." "0,1"
        textline "        "
        bitfld.long 0x00 1. " RS_YUV_TARGET ,Supports resolving into YUV target." "0,1"
        textline "        "
        bitfld.long 0x00 2. " BYTE_WRITE_3D ,3D PE has byte write capability." "0,1"
        textline "        "
        bitfld.long 0x00 3. " FE20 ,FE 2.0 is present." "0,1"
        textline "        "
        bitfld.long 0x00 4. " VGTS ,VG tessellator is present." "0,1"
        textline "        "
        bitfld.long 0x00 5. " PIPE_VG ,VG pipe is present." "0,1"
        textline "        "
        bitfld.long 0x00 6. " MEM32_BIT_SUPPORT ,32 bit memory address support." "0,1"
        textline "        "
        bitfld.long 0x00 7. " YUY2_RENDER_TARGET ,YUY2 support in PE and YUY2 to RGB conversion in resolve." "0,1"
        textline "        "
        bitfld.long 0x00 8. " HALF_TX_CACHE ,TX cache is half." "0,1"
        textline "        "
        bitfld.long 0x00 9. " HALF_PE_CACHE ,PE cache is half." "0,1"
        textline "        "
        bitfld.long 0x00 10. " YUY2_AVERAGING ,YUY2 averaging support in resolve." "0,1"
        textline "        "
        bitfld.long 0x00 11. " NO_SCALER ,IP does not have 2D scaler." "0,1"
        textline "        "
        bitfld.long 0x00 12. " BYTE_WRITE_2D ,Supports byte write in 2D." "0,1"
        textline "        "
        bitfld.long 0x00 13. " BUFFER_INTERLEAVING ,IP supports interleaving depth and color buffers." "0,1"
        textline "        "
        bitfld.long 0x00 14. " NO422_TEXTURE ,IP does not have 422 texture input format." "0,1"
        textline "        "
        bitfld.long 0x00 15. " NO_EZ ,IP does not have early-Z." "0,1"
        textline "        "
        bitfld.long 0x00 16. " MIN_AREA ,IP is configured to have minimum area." "0,1"
        textline "        "
        bitfld.long 0x00 17. " MODULE_CG ,Second level clock gating is available." "0,1"
        textline "        "
        bitfld.long 0x00 18. " YUV420_TILER ,YUV 4:2:0 tiler is available." "0,1"
        textline "        "
        bitfld.long 0x00 19. " HIGH_DYNAMIC_RANGE ,Shows if the IP has HDR support." "0,1"
        textline "        "
        bitfld.long 0x00 20. " FAST_SCALER ,Shows if the IP has HD scaler." "0,1"
        textline "        "
        bitfld.long 0x00 21. " ETC1_TEXTURE_COMPRESSION ,ETC1 texture compression." "0,1"
        textline "        "
        bitfld.long 0x00 22. " PIPE_2D ,Shows if there is 2D engine." "0,1"
        textline "        "
        bitfld.long 0x00 23. " DC ,Shows if there is a display controller in the IP." "0,1"
        textline "        "
        bitfld.long 0x00 24. " MSAA ,MSAA support." "0,1"
        textline "        "
        bitfld.long 0x00 25. " YUV420_FILTER ,YUV 4:2:0 support in filter blit." "0,1"
        textline "        "
        bitfld.long 0x00 26. " ZCOMPRESSION ,Depth and color compression." "0,1"
        textline "        "
        bitfld.long 0x00 27. " DEBUG_MODE ,Debug registers." "0,1"
        textline "        "
        bitfld.long 0x00 28. " DXT_TEXTURE_COMPRESSION ,DXT texture compression." "0,1"
        textline "        "
        bitfld.long 0x00 29. " PIPE_3D ,3D pipe." "0,1"
        textline "        "
        bitfld.long 0x00 30. " SPECIAL_ANTI_ALIASING ,Full-screen anti-aliasing." "0,1"
        textline "        "
        bitfld.long 0x00 31. " FAST_CLEAR ,Fast clear." "0,1"
width 7.
rgroup.long 0x20++0x3
    line.long 0x00 "CHIPID,Chip Identification Register"
        hexmask.long.long 0x00 0.--32. 1. " ID ,Id."
width 8.
rgroup.long 0x24++0x3
    line.long 0x00 "CHIPREV,Chip Revision Register"
        hexmask.long.long 0x00 0.--32. 1. " REV ,Revision."
width 9.
rgroup.long 0x28++0x3
    line.long 0x00 "CHIPDATE,Chip Release Date Register"
        hexmask.long.long 0x00 0.--32. 1. " DATE ,Date."
width 9.
rgroup.long 0x2c++0x3
    line.long 0x00 "CHIPTIME,Chip Release Time Register"
        hexmask.long.long 0x00 0.--32. 1. " TIME ,Time."
width 13.
rgroup.long 0x30++0x3
    line.long 0x00 "CHIPCUSTOMER,Chip Customer Register"
        hexmask.long.word 0x00 0.--16. 1. " GROUP ,Group."
        textline "            "
        hexmask.long.word 0x00 16.--32. 1. " COMPANY ,Company."
width 15.
rgroup.long 0x34++0x3
    line.long 0x00 "MINORFEATURES0,Minor Features Register 0"
        bitfld.long 0x00 0. " FLIP_Y ,Y flipping capability is added to resolve." "0,1"
        textline "              "
        bitfld.long 0x00 1. " DUAL_RETURN_BUS ,Dual Return Bus from HI to clients." "0,1"
        textline "              "
        bitfld.long 0x00 2. " ENDIANNESS_CONFIG ,Configurable endianness support." "0,1"
        textline "              "
        bitfld.long 0x00 3. " TEXTURE8_K ,Supports 8Kx8K textures." "0,1"
        textline "              "
        bitfld.long 0x00 4. " CORRECT_TEXTURE_CONVERTER ,Driver hack is not needed." "0,1"
        textline "              "
        bitfld.long 0x00 5. " SPECIAL_MSAA_LOD ,Special LOD calculation when MSAA is on." "0,1"
        textline "              "
        bitfld.long 0x00 6. " FAST_CLEAR_FLUSH ,Proper flush is done in fast clear cache." "0,1"
        textline "              "
        bitfld.long 0x00 7. " _2DPE20 ,2D PE 2.0 is present." "0,1"
        textline "              "
        bitfld.long 0x00 8. " CORRECT_AUTO_DISABLE ,Auto disable in FC is correct." "0,1"
        textline "              "
        bitfld.long 0x00 9. " RENDER_8K ,Supports 8K render target." "0,1"
        textline "              "
        bitfld.long 0x00 10. " TILE_STATUS_2BITS ,2 bits are used instead of 4 bits for tile status." "0,1"
        textline "              "
        bitfld.long 0x00 11. " SEPARATE_TILE_STATUS_WHEN_INTERLEAVED ,Use 2 separate tile status buffers in interleaved mode." "0,1"
        textline "              "
        bitfld.long 0x00 12. " SUPER_TILED_32X32 ,32x32 super tile is available." "0,1"
        textline "              "
        bitfld.long 0x00 13. " VG_20 ,Major updates to VG pipe (TS buffer tiling." "0,1"
        textline "              "
        bitfld.long 0x00 14. " TS_EXTENDED_COMMANDS ,New commands added to the tessellator." "0,1"
        textline "              "
        bitfld.long 0x00 15. " COMPRESSION_FIFO_FIXED ,If this bit is not set, the FIFO counter should be set to 50." "0,1"
        textline "              "
        bitfld.long 0x00 16. " EXTRA_SHADER_INSTRUCTIONS0 ,Floor, ceil, and sign instructions are available." "0,1"
        textline "              "
        bitfld.long 0x00 17. " VG_FILTER ,VG filter is available." "0,1"
        textline "              "
        bitfld.long 0x00 18. " VG_21 ,Minor updates to VG pipe (Event generation from VG, TS, PE)." "0,1"
        textline "              "
        bitfld.long 0x00 19. " SHADER_GETS_W ,W is sent to SH from RA." "0,1"
        textline "              "
        bitfld.long 0x00 20. " EXTRA_SHADER_INSTRUCTIONS1 ,Sqrt, sin, cos instructions are available." "0,1"
        textline "              "
        bitfld.long 0x00 21. " DEFAULT_REG0 ,Unavailable registers will return 0." "0,1"
        textline "              "
        bitfld.long 0x00 22. " MC_20 ,New style MC with separate paths for color and depth." "0,1"
        textline "              "
        bitfld.long 0x00 23. " SHADER_MSAA_SIDEBAND ,Put the MSAA data into sideband fifo." "0,1"
        textline "              "
        bitfld.long 0x00 24. " BUG_FIXES0 ,Bug fix bit 0" "0,1"
        textline "              "
        bitfld.long 0x00 25. " VAA ,VAA is available or not." "0,1"
        textline "              "
        bitfld.long 0x00 26. " BYPASS_IN_MSAA ,Shader supports bypass mode when MSAA is enabled." "0,1"
        textline "              "
        bitfld.long 0x00 27. " HIERARCHICAL_Z ,Hierarchiccal Z is supported." "0,1"
        textline "              "
        bitfld.long 0x00 28. " NEW_TEXTURE ,New texture unit is available." "0,1"
        textline "              "
        bitfld.long 0x00 29. " A8_TARGET_SUPPORT ,2D engine supports A8 target." "0,1"
        textline "              "
        bitfld.long 0x00 30. " CORRECT_STENCIL ,Correct stencil behavior in depth only." "0,1"
        textline "              "
        bitfld.long 0x00 31. " ENHANCE_VR ,Enhance VR and add a mode to walk 16 pixels in 16-bit mode in Vertical pass to improve $ hit rate when rotating 90/270." "0,1"
width 13.
group.long 0x38++0x3
    line.long 0x00 "CACHECONTROL,Cache Control Register"
        hexmask.long.long 0x00 0.--32. 1. " NOT_USED ,Reserved"
width 17.
wgroup.long 0x3c++0x3
    line.long 0x00 "RESETMEMCOUNTERS,Reset Mem Counters Register"
        hexmask.long.long 0x00 0.--32. 1. " RESET ,Reset"
width 11.
rgroup.long 0x40++0x3
    line.long 0x00 "TOTALREADS,Read Count Register"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 12.
rgroup.long 0x44++0x3
    line.long 0x00 "TOTALWRITES,Write Count Register"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 10.
rgroup.long 0x48++0x3
    line.long 0x00 "CHIPSPECS,Chip Specification Register"
        hexmask.long.byte 0x00 0.--4. 1. " VERTEX_OUTPUT_BUFFER_SIZE ,Log2 of vertex output buffer size."
        textline "         "
        hexmask.long.byte 0x00 4.--7. 1. " NUM_PIXEL_PIPES ,Number of pixel pipes."
        textline "         "
        hexmask.long.byte 0x00 7.--12. 1. " NUM_SHADER_CORES ,Number of shader cores."
        textline "         "
        hexmask.long.byte 0x00 15.--20. 1. " VERTEX_CACHE_SIZE ,Number of entries in the vertex shader cache."
        textline "         "
        hexmask.long.byte 0x00 20.--24. 1. " THREAD_COUNT ,Log2 of thread count."
        textline "         "
        hexmask.long.byte 0x00 24.--28. 1. " TEMP_REGISTERS ,Log2 of temporary registers."
        textline "         "
        hexmask.long.byte 0x00 28.--32. 1. " STREAMS ,Number of vertex streams."
width 17.
rgroup.long 0x4c++0x3
    line.long 0x00 "TOTALWRITEBURSTS,Write Data Count Register"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 15.
rgroup.long 0x50++0x3
    line.long 0x00 "TOTALWRITEREQS,Write REQ Count Register"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 16.
rgroup.long 0x54++0x3
    line.long 0x00 "TOTALWRITELASTS,Total WLAST Count Register"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 16.
rgroup.long 0x58++0x3
    line.long 0x00 "TOTALREADBURSTS,Total Read Data Count Register"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 14.
rgroup.long 0x5c++0x3
    line.long 0x00 "TOTALREADREQS,Total Read REQ Count Register"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 15.
rgroup.long 0x60++0x3
    line.long 0x00 "TOTALREADLASTS,Total RLAST Count Register"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 7.
group.long 0x64++0x3
    line.long 0x00 "GPOUT0,General Purpose Register 0"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 7.
group.long 0x68++0x3
    line.long 0x00 "GPOUT1,General Purpose Register 1"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 7.
group.long 0x6c++0x3
    line.long 0x00 "GPOUT2,General Purpose Register 2"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 11.
group.long 0x70++0x3
    line.long 0x00 "AXICONTROL,AXI Control Register"
        hexmask.long.long 0x00 0.--32. 1. " WR_FULL_BURST_MODE ,WR_FULL_BURST_MODE"
width 15.
rgroup.long 0x74++0x3
    line.long 0x00 "MINORFEATURES1,Minor Features Register 1"
        bitfld.long 0x00 26. " TEXTURE_STRIDE ,Texture has stride and memory addressing." "0,1"
        textline "              "
        bitfld.long 0x00 27. " BUG_FIXES2 ,Bug fixes bit 2" "0,1"
        textline "              "
        bitfld.long 0x00 28. " BUG_FIXES1 ,Bug fixes bit 1" "0,1"
        textline "              "
        bitfld.long 0x00 29. " VG_DOUBLE_BUFFER ,Double buffering support for VG (second TS-->VG semaphore is present)." "0,1"
        textline "              "
        bitfld.long 0x00 30. " V2_COMPRESSION ,V2 compression." "0,1"
        textline "              "
        bitfld.long 0x00 31. " RSUV_SWIZZLE ,Resolve UV swizzle." "0,1"
width 12.
group.long 0x78++0x3
    line.long 0x00 "TOTALCYCLES,Total Cycle Counter Register"
        hexmask.long.long 0x00 0.--32. 1. " CYCLES ,Total cycles"
width 15.
group.long 0x7c++0x3
    line.long 0x00 "TOTALIDLECYLES,Total Idle Cycle Register"
        hexmask.long.long 0x00 0.--32. 1. " CYCLES ,Total cycles"
width 11.
group.long 0x80++0x3
    line.long 0x00 "CHIPSPECS2,Chip Specification Register"
        hexmask.long.long 0x00 0.--32. 1. " CYCLES ,Total cycles"
width 20.
group.long 0x84++0x3
    line.long 0x00 "MODULEPOWERCONTROLS,Power Control Register"
        hexmask.long.word 0x00 0.--16. 1. " TURN_OFF_COUNTER ,Counter value for clock gating the module if the module is idle for this amount of clock cycles."
        textline "                   "
        hexmask.long.byte 0x00 24.--28. 1. " TURN_ON_COUNTER ,Number of clock cycles to wait after turning on the clock."
        textline "                   "
        bitfld.long 0x00 29. " DISABLE_STARVE_MODULE_CLOCK_GATING ,Disables module level clock gating for starve/idle condition." "0,1"
        textline "                   "
        bitfld.long 0x00 30. " DISABLE_STALL_MODULE_CLOCK_GATING ,Disables module level clock gating for stall condition." "0,1"
        textline "                   "
        bitfld.long 0x00 31. " ENABLE_MODULE_CLOCK_GATING ,Enables module level clock gating." "0,1"
width 25.
group.long 0x88++0x3
    line.long 0x00 "MODULEPOWERMODULECONTROL,Power Level Register"
        bitfld.long 0x00 20. " DISABLE_MODULE_CLOCK_GATING_TS ,Disables module level clock gating for TS." "0,1"
        textline "                        "
        bitfld.long 0x00 21. " DISABLE_MODULE_CLOCK_GATING_FP ,Disables module level clock gating for FP." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " DISABLE_MODULE_CLOCK_GATING_IM ,Disables module level clock gating for IM." "0,1"
        textline "                        "
        bitfld.long 0x00 23. " DISABLE_MODULE_CLOCK_GATING_VG ,Disables module level clock gating for VG." "0,1"
        textline "                        "
        bitfld.long 0x00 24. " DISABLE_MODULE_CLOCK_GATING_TX ,Disables module level clock gating for TX." "0,1"
        textline "                        "
        bitfld.long 0x00 25. " DISABLE_MODULE_CLOCK_GATING_RA ,Disables module level clock gating for RA." "0,1"
        textline "                        "
        bitfld.long 0x00 26. " DISABLE_MODULE_CLOCK_GATING_SE ,Disables module level clock gating for SE." "0,1"
        textline "                        "
        bitfld.long 0x00 27. " DISABLE_MODULE_CLOCK_GATING_PA ,Disables module level clock gating for PA." "0,1"
        textline "                        "
        bitfld.long 0x00 28. " DISABLE_MODULE_CLOCK_GATING_SH ,Disables module level clock gating for SH." "0,1"
        textline "                        "
        bitfld.long 0x00 29. " DISABLE_MODULE_CLOCK_GATING_PE ,Disables module level clock gating for PE." "0,1"
        textline "                        "
        bitfld.long 0x00 30. " DISABLE_MODULE_CLOCK_GATING_DE ,Disables module level clock gating for DE." "0,1"
        textline "                        "
        bitfld.long 0x00 31. " DISABLE_MODULE_CLOCK_GATING_FE ,Disables module level clock gating for FE." "0,1"
width 24.
rgroup.long 0x8c++0x3
    line.long 0x00 "MODULEPOWERMODULESTATUS,Power Status Register"
        bitfld.long 0x00 20. " MODULE_CLOCK_GATED_TS ,Module level clock gating is ON for TS." "0,1"
        textline "                       "
        bitfld.long 0x00 21. " MODULE_CLOCK_GATED_FP ,Module level clock gating is ON for FP." "0,1"
        textline "                       "
        bitfld.long 0x00 22. " MODULE_CLOCK_GATED_IM ,Module level clock gating is ON for IM." "0,1"
        textline "                       "
        bitfld.long 0x00 23. " MODULE_CLOCK_GATED_VG ,Module level clock gating is ON for VG." "0,1"
        textline "                       "
        bitfld.long 0x00 24. " MODULE_CLOCK_GATED_TX ,Module level clock gating is ON for TX." "0,1"
        textline "                       "
        bitfld.long 0x00 25. " MODULE_CLOCK_GATED_RA ,Module level clock gating is ON for RA." "0,1"
        textline "                       "
        bitfld.long 0x00 26. " MODULE_CLOCK_GATED_SE ,Module level clock gating is ON for SE." "0,1"
        textline "                       "
        bitfld.long 0x00 27. " MODULE_CLOCK_GATED_PA ,Module level clock gating is ON for PA." "0,1"
        textline "                       "
        bitfld.long 0x00 28. " MODULE_CLOCK_GATED_SH ,Module level clock gating is ON for SH." "0,1"
        textline "                       "
        bitfld.long 0x00 29. " MODULE_CLOCK_GATED_PE ,Module level clock gating is ON for PE." "0,1"
        textline "                       "
        bitfld.long 0x00 30. " MODULE_CLOCK_GATED_DE ,Module level clock gating is ON for DE." "0,1"
        textline "                       "
        bitfld.long 0x00 31. " MODULE_CLOCK_GATED_FE ,Module level clock gating is ON for FE." "0,1"


tree.end



;--------------------------------------------------------------------------------
; I2C
;--------------------------------------------------------------------------------
tree.open "I2C"
    tree "I2C1"
        base ad:0x021a0000

width 5.
group.word 0x0++0x1
    line.word 0x00 "IADR,I2C Address Register"
        hexmask.word.byte 0x00 1.--8. 1. " ADR ,Slave address."
width 5.
group.word 0x4++0x1
    line.word 0x00 "IFDR,I2C Frequency Divider Register"
        hexmask.word.byte 0x00 0.--6. 1. " IC ,I2C clock rate."
width 5.
group.word 0x8++0x1
    line.word 0x00 "I2CR,I2C Control Register"
        bitfld.word 0x00 2. " RSTA ,Repeat start." "0,1"
        textline "    "
        bitfld.word 0x00 3. " TXAK ,Transmit acknowledge enable." "0,1"
        textline "    "
        bitfld.word 0x00 4. " MTX ,Transmit/receive mode select bit." "0,1"
        textline "    "
        bitfld.word 0x00 5. " MSTA ,Master/slave mode select bit." "0,1"
        textline "    "
        bitfld.word 0x00 6. " IIEN ,I2C interrupt enable." "0,1"
        textline "    "
        bitfld.word 0x00 7. " IEN ,I2C enable." "0,1"
width 5.
group.word 0xc++0x1
    line.word 0x00 "I2SR,I2C Status Register"
        bitfld.word 0x00 0. " RXAK ,Received acknowledge." "0,1"
        textline "    "
        bitfld.word 0x00 1. " IIF ,I2C interrupt." "0,1"
        textline "    "
        bitfld.word 0x00 2. " SRW ,Slave read/write." "0,1"
        textline "    "
        bitfld.word 0x00 4. " IAL ,Arbitration lost." "0,1"
        textline "    "
        bitfld.word 0x00 5. " IBB ,I2C bus busy bit." "0,1"
        textline "    "
        bitfld.word 0x00 6. " IAAS ,I2C addressed as a slave bit." "0,1"
        textline "    "
        bitfld.word 0x00 7. " ICF ,Data transferring bit." "0,1"
width 5.
group.word 0x10++0x1
    line.word 0x00 "I2DR,I2C Data I/O Register"
        hexmask.word.byte 0x00 0.--8. 1. " DATA ,Data Byte."


    tree.end
    tree "I2C2"
        base ad:0x021a4000

width 5.
group.word 0x0++0x1
    line.word 0x00 "IADR,I2C Address Register"
        hexmask.word.byte 0x00 1.--8. 1. " ADR ,Slave address."
width 5.
group.word 0x4++0x1
    line.word 0x00 "IFDR,I2C Frequency Divider Register"
        hexmask.word.byte 0x00 0.--6. 1. " IC ,I2C clock rate."
width 5.
group.word 0x8++0x1
    line.word 0x00 "I2CR,I2C Control Register"
        bitfld.word 0x00 2. " RSTA ,Repeat start." "0,1"
        textline "    "
        bitfld.word 0x00 3. " TXAK ,Transmit acknowledge enable." "0,1"
        textline "    "
        bitfld.word 0x00 4. " MTX ,Transmit/receive mode select bit." "0,1"
        textline "    "
        bitfld.word 0x00 5. " MSTA ,Master/slave mode select bit." "0,1"
        textline "    "
        bitfld.word 0x00 6. " IIEN ,I2C interrupt enable." "0,1"
        textline "    "
        bitfld.word 0x00 7. " IEN ,I2C enable." "0,1"
width 5.
group.word 0xc++0x1
    line.word 0x00 "I2SR,I2C Status Register"
        bitfld.word 0x00 0. " RXAK ,Received acknowledge." "0,1"
        textline "    "
        bitfld.word 0x00 1. " IIF ,I2C interrupt." "0,1"
        textline "    "
        bitfld.word 0x00 2. " SRW ,Slave read/write." "0,1"
        textline "    "
        bitfld.word 0x00 4. " IAL ,Arbitration lost." "0,1"
        textline "    "
        bitfld.word 0x00 5. " IBB ,I2C bus busy bit." "0,1"
        textline "    "
        bitfld.word 0x00 6. " IAAS ,I2C addressed as a slave bit." "0,1"
        textline "    "
        bitfld.word 0x00 7. " ICF ,Data transferring bit." "0,1"
width 5.
group.word 0x10++0x1
    line.word 0x00 "I2DR,I2C Data I/O Register"
        hexmask.word.byte 0x00 0.--8. 1. " DATA ,Data Byte."


    tree.end
    tree "I2C3"
        base ad:0x021a8000

width 5.
group.word 0x0++0x1
    line.word 0x00 "IADR,I2C Address Register"
        hexmask.word.byte 0x00 1.--8. 1. " ADR ,Slave address."
width 5.
group.word 0x4++0x1
    line.word 0x00 "IFDR,I2C Frequency Divider Register"
        hexmask.word.byte 0x00 0.--6. 1. " IC ,I2C clock rate."
width 5.
group.word 0x8++0x1
    line.word 0x00 "I2CR,I2C Control Register"
        bitfld.word 0x00 2. " RSTA ,Repeat start." "0,1"
        textline "    "
        bitfld.word 0x00 3. " TXAK ,Transmit acknowledge enable." "0,1"
        textline "    "
        bitfld.word 0x00 4. " MTX ,Transmit/receive mode select bit." "0,1"
        textline "    "
        bitfld.word 0x00 5. " MSTA ,Master/slave mode select bit." "0,1"
        textline "    "
        bitfld.word 0x00 6. " IIEN ,I2C interrupt enable." "0,1"
        textline "    "
        bitfld.word 0x00 7. " IEN ,I2C enable." "0,1"
width 5.
group.word 0xc++0x1
    line.word 0x00 "I2SR,I2C Status Register"
        bitfld.word 0x00 0. " RXAK ,Received acknowledge." "0,1"
        textline "    "
        bitfld.word 0x00 1. " IIF ,I2C interrupt." "0,1"
        textline "    "
        bitfld.word 0x00 2. " SRW ,Slave read/write." "0,1"
        textline "    "
        bitfld.word 0x00 4. " IAL ,Arbitration lost." "0,1"
        textline "    "
        bitfld.word 0x00 5. " IBB ,I2C bus busy bit." "0,1"
        textline "    "
        bitfld.word 0x00 6. " IAAS ,I2C addressed as a slave bit." "0,1"
        textline "    "
        bitfld.word 0x00 7. " ICF ,Data transferring bit." "0,1"
width 5.
group.word 0x10++0x1
    line.word 0x00 "I2DR,I2C Data I/O Register"
        hexmask.word.byte 0x00 0.--8. 1. " DATA ,Data Byte."


    tree.end
    tree "I2C4"
        base ad:0x021f8000

width 5.
group.word 0x0++0x1
    line.word 0x00 "IADR,I2C Address Register"
        hexmask.word.byte 0x00 1.--8. 1. " ADR ,Slave address."
width 5.
group.word 0x4++0x1
    line.word 0x00 "IFDR,I2C Frequency Divider Register"
        hexmask.word.byte 0x00 0.--6. 1. " IC ,I2C clock rate."
width 5.
group.word 0x8++0x1
    line.word 0x00 "I2CR,I2C Control Register"
        bitfld.word 0x00 2. " RSTA ,Repeat start." "0,1"
        textline "    "
        bitfld.word 0x00 3. " TXAK ,Transmit acknowledge enable." "0,1"
        textline "    "
        bitfld.word 0x00 4. " MTX ,Transmit/receive mode select bit." "0,1"
        textline "    "
        bitfld.word 0x00 5. " MSTA ,Master/slave mode select bit." "0,1"
        textline "    "
        bitfld.word 0x00 6. " IIEN ,I2C interrupt enable." "0,1"
        textline "    "
        bitfld.word 0x00 7. " IEN ,I2C enable." "0,1"
width 5.
group.word 0xc++0x1
    line.word 0x00 "I2SR,I2C Status Register"
        bitfld.word 0x00 0. " RXAK ,Received acknowledge." "0,1"
        textline "    "
        bitfld.word 0x00 1. " IIF ,I2C interrupt." "0,1"
        textline "    "
        bitfld.word 0x00 2. " SRW ,Slave read/write." "0,1"
        textline "    "
        bitfld.word 0x00 4. " IAL ,Arbitration lost." "0,1"
        textline "    "
        bitfld.word 0x00 5. " IBB ,I2C bus busy bit." "0,1"
        textline "    "
        bitfld.word 0x00 6. " IAAS ,I2C addressed as a slave bit." "0,1"
        textline "    "
        bitfld.word 0x00 7. " ICF ,Data transferring bit." "0,1"
width 5.
group.word 0x10++0x1
    line.word 0x00 "I2DR,I2C Data I/O Register"
        hexmask.word.byte 0x00 0.--8. 1. " DATA ,Data Byte."


    tree.end

tree.end



;--------------------------------------------------------------------------------
; IOMUXC
;--------------------------------------------------------------------------------
tree "IOMUXC"
    base ad:0x020e0000

width 5.
group.long 0x0++0x3
    line.long 0x00 "GPR0,GPR0"
        bitfld.long 0x00 0. " DMAREQ_MUX_SEL0 ,Selects between two possible sources for SDMA_EVENT[2]:" "0,1"
        textline "    "
        bitfld.long 0x00 1. " DMAREQ_MUX_SEL1 ,Selects between two possible sources for SDMA_EVENT[3]:" "0,1"
        textline "    "
        bitfld.long 0x00 2. " DMAREQ_MUX_SEL2 ,Selects between two possible sources for SDMA_EVENT[4]:" "0,1"
        textline "    "
        bitfld.long 0x00 3. " DMAREQ_MUX_SEL3 ,Selects between two possible sources for SDMA_EVENT[5]:" "0,1"
        textline "    "
        bitfld.long 0x00 4. " DMAREQ_MUX_SEL4 ,Selects between two possible sources for SDMA_EVENT[10]:" "0,1"
        textline "    "
        bitfld.long 0x00 5. " DMAREQ_MUX_SEL5 ,Selects between two possible sources for SDMA_EVENT[9]:" "0,1"
        textline "    "
        bitfld.long 0x00 6. " DMAREQ_MUX_SEL6 ,Selects between two possible sources for SDMA_EVENT[23]:" "0,1"
        textline "    "
        bitfld.long 0x00 7. " DMAREQ_MUX_SEL7 ,Selects between two possible sources for SDMA_EVENT[14]:" "0,1"
width 5.
group.long 0x4++0x3
    line.long 0x00 "GPR1,GPR1"
        bitfld.long 0x00 0. " ACT_CS0 ,See description for ADDRS3[10]" "0,1"
        textline "    "
        hexmask.long.byte 0x00 1.--3. 1. " ADDRS0 ,See description for ADDRS3[10]"
        textline "    "
        bitfld.long 0x00 3. " ACT_CS1 ,See description for ADDRS3[10]" "0,1"
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ADDRS1 ,See description for ADDRS3[10]"
        textline "    "
        bitfld.long 0x00 6. " ACT_CS2 ,See description for ADDRS3[10]" "0,1"
        textline "    "
        hexmask.long.byte 0x00 7.--9. 1. " ADDRS2 ,See description for ADDRS3[10]"
        textline "    "
        bitfld.long 0x00 9. " ACT_CS3 ,See description for ADDRS3[10]" "0,1"
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ADDRS3 ,Active Chip Select and Address Space."
        textline "    "
        bitfld.long 0x00 12. " GINT ,Global interrupt ""0"" bit (connected to ARM IRQ#0 and GPC)" "0,1"
        textline "    "
        bitfld.long 0x00 14. " ENET_CLK_SEL ,choose enet reference clk mode" "0,1"
        textline "    "
        bitfld.long 0x00 15. " USB_EXP_MODE ,USB Exposure mode" "0,1"
        textline "    "
        bitfld.long 0x00 16. " ADD_DS ,set to 0 will make output driver ~10% stronger at highest strength (DSE=111) for use in case if IO buffer operation at WCS and 200 MHz is marginal" "0,1"
        textline "    "
        hexmask.long.byte 0x00 17.--19. 1. " ENET_CLK_SEL_FROM_ANALOG_LOOPBACK ,When ENET_CLK_SEL(GPR1[14]) is program to 0(means get enet txclk from internal anatop), use these 2 bits to select from 4 options of loopback path."
        textline "    "
        bitfld.long 0x00 22. " EXC_MON ,Exclusive monitor response select of illegal command (of lal gaskets, except MMDC)" "0,1"
width 5.
group.long 0x8++0x3
    line.long 0x00 "GPR2,GPR2"
        bitfld.long 0x00 0. " EPDC_MEM_EN_POWERSAVING ,enable power saving features on epdc memory" "0,1"
        textline "    "
        bitfld.long 0x00 1. " EPDC_MEM_SHUTDOWN ,set to bring memory to shutdown state (most power saving state, Shut Down periphery and core, no memory retention)" "0,1"
        textline "    "
        bitfld.long 0x00 2. " EPDC_MEM_DEEPSLEEP ,control how memory enter Deep Sleep mode (shutdown periphery power, but maintain memory contents, outputs of memory are pulled low)" "0,1"
        textline "    "
        bitfld.long 0x00 3. " EPDC_MEM_LIGHTSLEEP ,set to bring memory to light sleep state (Low leakage mode, maintain memory contents, no change to memory output)" "0,1"
        textline "    "
        bitfld.long 0x00 4. " SPDC_MEM_EN_POWERSAVING ,enable power saving features on SPDC memory" "0,1"
        textline "    "
        bitfld.long 0x00 5. " SPDC_MEM_SHUTDOWN ,set to bring memory to shutdown state (most power saving state, Shut Down periphery and core, no memory retention)" "0,1"
        textline "    "
        bitfld.long 0x00 6. " SPDC_MEM_DEEPSLEEP ,control how memory enter Deep Sleep mode (shutdown periphery power, but maintain memory contents, outputs of memory are pulled low)" "0,1"
        textline "    "
        bitfld.long 0x00 7. " SPDC_MEM_LIGHTSLEEP ,set to bring memory to light sleep state (Low leakage mode, maintain memory contents, no change to memory output)" "0,1"
        textline "    "
        bitfld.long 0x00 8. " PXP_MEM_EN_POWERSAVING ,enable power saving features on PXP memory" "0,1"
        textline "    "
        bitfld.long 0x00 9. " PXP_MEM_SHUTDOWN ,set to bring memory to shutdown state (most power saving state, Shut Down periphery and core, no memory retention)" "0,1"
        textline "    "
        bitfld.long 0x00 10. " PXP_MEM_DEEPSLEEP ,control how memory enter Deep Sleep mode (shutdown periphery power, but maintain memory contents, outputs of memory are pulled low)" "0,1"
        textline "    "
        bitfld.long 0x00 11. " PXP_MEM_LIGHTSLEEP ,set to bring memory to light sleep state (Low leakage mode, maintain memory contents, no change to memory output)" "0,1"
        textline "    "
        bitfld.long 0x00 12. " LCDIF_MEM_EN_POWERSAVING ,enable power saving features on LCDIF memory" "0,1"
        textline "    "
        bitfld.long 0x00 13. " LCDIF_MEM_SHUTDOWN ,set to bring memory to shutdown state (most power saving state, Shut Down periphery and core, no memory retention)" "0,1"
        textline "    "
        bitfld.long 0x00 14. " LCDIF_MEM_DEEPSLEEP ,control how memory enter Deep Sleep mode (shutdown periphery power, but maintain memory contents, outputs of memory are pulled low)" "0,1"
        textline "    "
        bitfld.long 0x00 15. " LCDIF_MEM_LIGHTSLEEP ,set to bring memory to light sleep state (Low leakage mode, maintain memory contents, no change to memory output)" "0,1"
        textline "    "
        bitfld.long 0x00 16. " DCP_MEM_EN_POWERSAVING ,enable power saving features on DCP memory" "0,1"
        textline "    "
        bitfld.long 0x00 17. " DCP_MEM_SHUTDOWN ,set to bring memory to shutdown state (most power saving state, Shut Down periphery and core, no memory retention)" "0,1"
        textline "    "
        bitfld.long 0x00 18. " DCP_MEM_DEEPSLEEP ,control how memory enter Deep Sleep mode (shutdown periphery power, but maintain memory contents, outputs of memory are pulled low)" "0,1"
        textline "    "
        bitfld.long 0x00 19. " DCP_MEM_LIGHTSLEEP ,set to bring memory to light sleep state (Low leakage mode, maintain memory contents, no change to memory output)" "0,1"
        textline "    "
        bitfld.long 0x00 20. " L2_MEM_EN_POWERSAVING ,enable power saving features on L2 memory" "0,1"
        textline "    "
        bitfld.long 0x00 21. " L2_MEM_SHUTDOWN ,set to bring memory to shutdown state (most power saving state, Shut Down periphery and core, no memory retention)" "0,1"
        textline "    "
        bitfld.long 0x00 22. " L2_MEM_DEEPSLEEP ,control how memory enter Deep Sleep mode (shutdown periphery power, but maintain memory contents, outputs of memory are pulled low)" "0,1"
        textline "    "
        bitfld.long 0x00 23. " L2_MEM_LIGHTSLEEP ,set to bring memory to light sleep state (Low leakage mode, maintain memory contents, no change to memory output)" "0,1"
width 5.
group.long 0xc++0x3
    line.long 0x00 "GPR3,GPR3"
        hexmask.long.byte 0x00 0.--4. 1. " OCRAM_L2_CTL ,OCRAM_L2_CTL[3] write address pipeline control bit."
        textline "    "
        hexmask.long.byte 0x00 4.--8. 1. " OCRAM_L2_STATUS ,This field shows the OCRAM_L2 pipeline settings status, controlled by OCRAM_L2_CTL[3:0] bits respectively."
        textline "    "
        bitfld.long 0x00 11. " TZASC1_BOOT_LOCK ,TZASC-1 secure boot lock" "0,1"
        textline "    "
        bitfld.long 0x00 13. " CORE_DBG_ACK_EN ,Mask control of Core debug acknowledge to global debug acknowledge" "0,1"
        textline "    "
        hexmask.long.byte 0x00 17.--21. 1. " OCRAM_STATUS ,This field shows the OCRAM pipeline settings status, controlled by OCRAM_CTL[24:21] bits respectively."
        textline "    "
        hexmask.long.byte 0x00 21.--25. 1. " OCRAM_CTL ,OCRAM_CTL[24] write address pipeline control bit."
        textline "    "
        bitfld.long 0x00 25. " USDHCX_RD_CACHE_CTL ,Control uSDHCx [1-4] blocks cacheable attribute of AXI read transactions" "0,1"
        textline "    "
        bitfld.long 0x00 26. " USDHCX_WR_CACHE_CTL ,Control uSDHCx [1-4] blocks cacheable attribute of AXI write transactions" "0,1"
width 5.
group.long 0x10++0x3
    line.long 0x00 "GPR4,GPR4"
        hexmask.long.byte 0x00 8.--16. 1. " SOC_VERSION ,This is status (read only) field."
        textline "    "
        bitfld.long 0x00 16. " RNGB_STOP_ACK ,RNGB stop acknowledge." "0,1"
        textline "    "
        bitfld.long 0x00 19. " SDMA_STOP_ACK ,SDMA stop acknowledge." "0,1"
width 5.
group.long 0x14++0x3
    line.long 0x00 "GPR5,GPR5"
        bitfld.long 0x00 0. " ARM_WFI ,ARM WFI event out indicating on WFI state of the cores (these are status, read only bits)" "0,1"
        textline "    "
        bitfld.long 0x00 4. " ARM_WFE ,ARM WFE event out indication on WFE state of the cores (these are status, read only bits)" "0,1"
        textline "    "
        bitfld.long 0x00 8. " L2_CLK_STOP ,L2 cache clock stop indication (this is a status, read only bit]" "0,1"
width 5.
group.long 0x18++0x3
    line.long 0x00 "GPR6,GPR6"
width 5.
group.long 0x1c++0x3
    line.long 0x00 "GPR7,GPR7"
width 5.
group.long 0x20++0x3
    line.long 0x00 "GPR8,GPR8"
width 5.
group.long 0x24++0x3
    line.long 0x00 "GPR9,GPR9"
        bitfld.long 0x00 0. " TZASC1_BYP ,TZASC-1 BYPASS MUX control" "0,1"
width 6.
group.long 0x28++0x3
    line.long 0x00 "GPR10,GPR10"
        bitfld.long 0x00 0. " DBG_EN ,ARM non secure (non-invasive) debug enable" "0,1"
        textline "     "
        bitfld.long 0x00 1. " DBG_CLK_EN ,ARM Debug clock enable" "0,1"
        textline "     "
        bitfld.long 0x00 2. " SEC_ERR_RESP ,Security error response enable for all security gaskets (on both AHB and AXI busses)" "0,1"
        textline "     "
        bitfld.long 0x00 3. " OCRAM_L2_TZ_EN ,OCRAM_L2 TrustZone (TZ) enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 4.--10. 1. " OCRAM_L2_TZ_ADDR ,OCRAM_L2 TrustZone (TZ) start address."
        textline "     "
        bitfld.long 0x00 10. " OCRAM_TZ_EN ,OCRAM TrustZone (TZ) enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 11.--16. 1. " OCRAM_TZ_ADDR ,OCRAM TrustZone (TZ) start address."
        textline "     "
        bitfld.long 0x00 16. " LOCK_DBG_EN ,Lock DBG_EN field for changes." "0,1"
        textline "     "
        bitfld.long 0x00 17. " LOCK_DBG_CLK_EN ,Lock DBG_CLK_EN field for changes." "0,1"
        textline "     "
        bitfld.long 0x00 18. " LOCK_SEC_ERR_RESP ,Lock SEC_ERR_RESP field for changes." "0,1"
        textline "     "
        bitfld.long 0x00 19. " LOCK_OCRAM_L2_TZ_EN ,Lock OCRAM_L2_TZ_EN field for changes." "0,1"
        textline "     "
        hexmask.long.byte 0x00 20.--26. 1. " LOCK_OCRAM_L2_TZ_ADDR ,Lock OCRAM_L2_TZ_ADDR field for changes."
        textline "     "
        bitfld.long 0x00 26. " LOCK_OCRAM_TZ_EN ,Lock OCRAM_TZ_EN field for changes." "0,1"
        textline "     "
        hexmask.long.byte 0x00 27.--32. 1. " LOCK_OCRAM_TZ_ADDR ,Lock OCRAM_TZ_ADDR field for changes."
width 6.
group.long 0x2c++0x3
    line.long 0x00 "GPR11,GPR11"
        bitfld.long 0x00 1. " OCRAM_L2_EN ,set to use L2 cache as ocram" "0,1"
        textline "     "
        bitfld.long 0x00 17. " LOCK_OCRAM_L2_EN ,lock ocram_l2 enable bit" "0,1"
width 6.
group.long 0x30++0x3
    line.long 0x00 "GPR12,GPR12"
        hexmask.long.byte 0x00 0.--4. 1. " GPU_AWQOS0 ,QOS control for write channel of gpu port m_g_0"
        textline "     "
        hexmask.long.byte 0x00 4.--8. 1. " GPU_ARQOS0 ,QOS control for read channel of gpu port m_g_0"
        textline "     "
        hexmask.long.byte 0x00 8.--12. 1. " GPU_AWQOS1 ,QOS control for write channel of gpu port m_g_1"
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " GPU_ARQOS1 ,QOS control for read channel of gpu port m_g_1"
        textline "     "
        hexmask.long.byte 0x00 16.--20. 1. " GPU_AWQOS2 ,QOS control for write channel of gpu port m_g_2"
        textline "     "
        hexmask.long.byte 0x00 20.--24. 1. " GPU_ARQOS2 ,QOS control for read channel of gpu port m_g_2"
        textline "     "
        bitfld.long 0x00 24. " ARMP_APB_CLK_EN ,ARM platform APB clock enable" "0,1"
        textline "     "
        bitfld.long 0x00 25. " ARMP_ATB_CLK_EN ,ARM platform ATB clock enable" "0,1"
        textline "     "
        bitfld.long 0x00 26. " ARMP_AHB_CLK_EN ,ARM platform AHB clock enable" "0,1"
        textline "     "
        bitfld.long 0x00 27. " ARMP_IPG_CLK_EN ,ARM platform IPG clock enable" "0,1"
        textline "     "
        bitfld.long 0x00 31. " DCP_KEY_SEL ,select 128bit dcp key from 256bit's key from snvs/ocotp" "0,1"
width 6.
group.long 0x34++0x3
    line.long 0x00 "GPR13,GPR13"
        bitfld.long 0x00 8. " PXP_RD_CACHE_VAL ,PXP block cacheable attribute value of AXI read transactions The value of PXP_RD_CACHE_VAL is affecting the transactions only if PXP_RD_CACHE_SEL is set." "0,1"
        textline "     "
        bitfld.long 0x00 9. " PXP_WR_CACHE_VAL ,PXP block cacheable attribute value of AXI write transactions The value of PXP_WR_CACHE_VAL is affecting the transactions only if PXP_WR_CACHE_SEL is set." "0,1"
        textline "     "
        bitfld.long 0x00 10. " PXP_RD_CACHE_SEL ,This bit selects the cacheable attribute of PXP AXI read transcations)" "0,1"
        textline "     "
        bitfld.long 0x00 11. " PXP_WR_CACHE_SEL ,This bit selects the cacheable attribute of PXP AXI write transcations" "0,1"
        textline "     "
        bitfld.long 0x00 12. " EPDC_RD_CACHE_VAL ,EPDC block cacheable attribute value of AXI read transactions The value of EPDC_RD_CACHE_VAL is affecting the transactions only if EPDC_RD_CACHE_SEL is set." "0,1"
        textline "     "
        bitfld.long 0x00 13. " EPDC_WR_CACHE_VAL ,EPDC block cacheable attribute value of AXI write transactions The value of EPDC_WR_CACHE_VAL is affecting the transactions only if EPDC_WR_CACHE_SEL is set." "0,1"
        textline "     "
        bitfld.long 0x00 14. " EPDC_RD_CACHE_SEL ,This bit selects the cacheable attribute of EPDC AXI read transcations)" "0,1"
        textline "     "
        bitfld.long 0x00 15. " EPDC_WR_CACHE_SEL ,This bit selects the cacheable attribute of EPDC AXI write transcations" "0,1"
        textline "     "
        bitfld.long 0x00 16. " LCDIF_RD_CACHE_VAL ,LCDIF block cacheable attribute value of AXI read transactions The value of LCDIF_RD_CACHE_VAL is affecting the transactions only if LCDIF_RD_CACHE_SEL is set." "0,1"
        textline "     "
        bitfld.long 0x00 18. " LCDIF_RD_CACHE_SEL ,This bit selects the cacheable attribute of LCDIF AXI read transcations)" "0,1"
        textline "     "
        bitfld.long 0x00 30. " SDMA_STOP_REQ ,SDMA stop request" "0,1"
width 24.
group.long 0x4c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_AUD_MCLK,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: AUD_MCLK."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 23.
group.long 0x50++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_AUD_RXC,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: AUD_RXC."
        textline "                      "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 23.
group.long 0x54++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_AUD_RXD,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: AUD_RXD."
        textline "                      "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x58++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_AUD_RXFS,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: AUD_RXFS."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 23.
group.long 0x5c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_AUD_TXC,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: AUD_TXC."
        textline "                      "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 23.
group.long 0x60++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_AUD_TXD,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: AUD_TXD."
        textline "                      "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x64++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_AUD_TXFS,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: AUD_TXFS."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x68++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_ECSPI1_MISO,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: ECSPI1_MISO."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x6c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_ECSPI1_MOSI,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: ECSPI1_MOSI."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x70++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_ECSPI1_SCLK,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: ECSPI1_SCLK."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x74++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_ECSPI1_SS0,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: ECSPI1_SS0."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x78++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_ECSPI2_MISO,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: ECSPI2_MISO."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x7c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_ECSPI2_MOSI,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: ECSPI2_MOSI."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x80++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_ECSPI2_SCLK,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: ECSPI2_SCLK."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x84++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_ECSPI2_SS0,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: ECSPI2_SS0."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x88++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_BDR0,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: EPDC_BDR0."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x8c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_BDR1,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: EPDC_BDR1."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x90++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_DATA00,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EPDC_D0."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x94++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_DATA01,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EPDC_D1."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x98++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_DATA10,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: EPDC_D10."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x9c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_DATA11,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: EPDC_D11."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0xa0++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_DATA12,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: EPDC_D12."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0xa4++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_DATA13,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: EPDC_D13."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0xa8++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_DATA14,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: EPDC_D14."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0xac++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_DATA15,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: EPDC_D15."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0xb0++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_DATA02,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EPDC_D2."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0xb4++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_DATA03,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EPDC_D3."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0xb8++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_DATA04,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EPDC_D4."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0xbc++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_DATA05,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EPDC_D5."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0xc0++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_DATA06,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EPDC_D6."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0xc4++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_DATA07,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EPDC_D7."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0xc8++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_DATA08,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: EPDC_D8."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0xcc++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_DATA09,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: EPDC_D9."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0xd0++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_GDCLK,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: EPDC_GDCLK."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0xd4++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_GDOE,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: EPDC_GDOE."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0xd8++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_GDRL,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: EPDC_GDRL."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0xdc++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_GDSP,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: EPDC_GDSP."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0xe0++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_PWR_COM,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: EPDC_PWRCOM."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 30.
group.long 0xe4++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_PWR_CTRL0,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: EPDC_PWRCTRL0."
        textline "                             "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 30.
group.long 0xe8++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_PWR_CTRL1,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: EPDC_PWRCTRL1."
        textline "                             "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 30.
group.long 0xec++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_PWR_CTRL2,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: EPDC_PWRCTRL2."
        textline "                             "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 30.
group.long 0xf0++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_PWR_CTRL3,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: EPDC_PWRCTRL3."
        textline "                             "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0xf4++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_PWR_IRQ,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: EPDC_PWRINT."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 29.
group.long 0xf8++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_PWR_STAT,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: EPDC_PWRSTAT."
        textline "                            "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 29.
group.long 0xfc++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_PWR_WAKE,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: EPDC_PWRWAKEUP."
        textline "                            "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x100++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_SDCE0,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EPDC_SDCE0."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x104++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_SDCE1,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EPDC_SDCE1."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x108++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_SDCE2,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EPDC_SDCE2."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x10c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_SDCE3,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EPDC_SDCE3."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x110++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_SDCLK,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EPDC_SDCLK."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x114++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_SDLE,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EPDC_SDLE."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x118++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_SDOE,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EPDC_SDOE."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x11c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_SDSHR,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EPDC_SDSHR."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x120++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_VCOM0,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: EPDC_VCOM0."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x124++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EPDC_VCOM1,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: EPDC_VCOM1."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x128++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_FEC_CRS_DV,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: FEC_CRS_DV."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 23.
group.long 0x12c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_FEC_MDC,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: FEC_MDC."
        textline "                      "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x130++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_FEC_MDIO,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: FEC_MDIO."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x134++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_FEC_REF_CLK,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: FEC_REF_CLK."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x138++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_FEC_RX_ER,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: FEC_RX_ER."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0x13c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_FEC_RX_DATA0,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: FEC_RXD0."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0x140++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_FEC_RX_DATA1,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: FEC_RXD1."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x144++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_FEC_TX_CLK,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: FEC_TX_CLK."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x148++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_FEC_TX_EN,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: FEC_TX_EN."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0x14c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_FEC_TX_DATA0,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: FEC_TXD0."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0x150++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_FEC_TX_DATA1,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: FEC_TXD1."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x154++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_USB_H_DATA,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: HSIC_DAT."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0x158++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_USB_H_STROBE,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: HSIC_STROBE."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x15c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_I2C1_SCL,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: I2C1_SCL."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x160++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_I2C1_SDA,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: I2C1_SDA."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x164++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_I2C2_SCL,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: I2C2_SCL."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x168++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_I2C2_SDA,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: I2C2_SDA."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x16c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_KEY_COL0,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: KEY_COL0."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x170++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_KEY_COL1,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: KEY_COL1."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x174++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_KEY_COL2,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: KEY_COL2."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x178++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_KEY_COL3,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: KEY_COL3."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x17c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_KEY_COL4,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: KEY_COL4."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x180++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_KEY_COL5,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: KEY_COL5."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x184++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_KEY_COL6,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: KEY_COL6."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x188++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_KEY_COL7,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: KEY_COL7."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x18c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_KEY_ROW0,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: KEY_ROW0."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x190++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_KEY_ROW1,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: KEY_ROW1."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x194++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_KEY_ROW2,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: KEY_ROW2."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x198++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_KEY_ROW3,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: KEY_ROW3."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x19c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_KEY_ROW4,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: KEY_ROW4."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x1a0++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_KEY_ROW5,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: KEY_ROW5."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x1a4++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_KEY_ROW6,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: KEY_ROW6."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x1a8++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_KEY_ROW7,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: KEY_ROW7."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 23.
group.long 0x1ac++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_LCD_CLK,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: LCD_CLK."
        textline "                      "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x1b0++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_LCD_DATA00,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: LCD_DAT0."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x1b4++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_LCD_DATA01,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: LCD_DAT1."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x1b8++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_LCD_DATA10,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: LCD_DAT10."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x1bc++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_LCD_DATA11,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: LCD_DAT11."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x1c0++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_LCD_DATA12,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: LCD_DAT12."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x1c4++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_LCD_DATA13,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: LCD_DAT13."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x1c8++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_LCD_DATA14,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: LCD_DAT14."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x1cc++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_LCD_DATA15,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: LCD_DAT15."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x1d0++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_LCD_DATA16,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: LCD_DAT16."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x1d4++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_LCD_DATA17,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: LCD_DAT17."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x1d8++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_LCD_DATA18,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: LCD_DAT18."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x1dc++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_LCD_DATA19,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: LCD_DAT19."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x1e0++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_LCD_DATA02,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: LCD_DAT2."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x1e4++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_LCD_DATA20,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: LCD_DAT20."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x1e8++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_LCD_DATA21,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: LCD_DAT21."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x1ec++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_LCD_DATA22,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: LCD_DAT22."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x1f0++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_LCD_DATA23,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: LCD_DAT23."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x1f4++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_LCD_DATA03,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: LCD_DAT3."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x1f8++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_LCD_DATA04,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: LCD_DAT4."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x1fc++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_LCD_DATA05,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: LCD_DAT5."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x200++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_LCD_DATA06,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: LCD_DAT6."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x204++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_LCD_DATA07,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: LCD_DAT7."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x208++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_LCD_DATA08,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: LCD_DAT8."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x20c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_LCD_DATA09,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: LCD_DAT9."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x210++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_LCD_ENABLE,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: LCD_ENABLE."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x214++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_LCD_HSYNC,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: LCD_HSYNC."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x218++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_LCD_RESET,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: LCD_RESET."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x21c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_LCD_VSYNC,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: LCD_VSYNC."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 20.
group.long 0x220++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_PWM1,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: PWM1."
        textline "                   "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x224++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_REF_CLK_24M,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: REF_CLK_24M."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x228++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_REF_CLK_32K,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: REF_CLK_32K."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 23.
group.long 0x22c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD1_CLK,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: SD1_CLK."
        textline "                      "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 23.
group.long 0x230++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD1_CMD,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: SD1_CMD."
        textline "                      "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x234++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD1_DATA0,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: SD1_DAT0."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x238++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD1_DATA1,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: SD1_DAT1."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x23c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD1_DATA2,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: SD1_DAT2."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x240++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD1_DATA3,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: SD1_DAT3."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x244++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD1_DATA4,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: SD1_DAT4."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x248++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD1_DATA5,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: SD1_DAT5."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x24c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD1_DATA6,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: SD1_DAT6."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x250++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD1_DATA7,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: SD1_DAT7."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 23.
group.long 0x254++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD2_CLK,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: SD2_CLK."
        textline "                      "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 23.
group.long 0x258++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD2_CMD,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: SD2_CMD."
        textline "                      "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x25c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD2_DATA0,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: SD2_DAT0."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x260++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD2_DATA1,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: SD2_DAT1."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x264++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD2_DATA2,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: SD2_DAT2."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x268++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD2_DATA3,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: SD2_DAT3."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x26c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD2_DATA4,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: SD2_DAT4."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x270++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD2_DATA5,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: SD2_DAT5."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x274++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD2_DATA6,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: SD2_DAT6."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x278++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD2_DATA7,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: SD2_DAT7."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x27c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD2_RESET,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: SD2_RST."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 23.
group.long 0x280++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD3_CLK,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: SD3_CLK."
        textline "                      "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 23.
group.long 0x284++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD3_CMD,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: SD3_CMD."
        textline "                      "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x288++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD3_DATA0,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: SD3_DAT0."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x28c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD3_DATA1,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: SD3_DAT1."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x290++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD3_DATA2,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: SD3_DAT2."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x294++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD3_DATA3,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: SD3_DAT3."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x298++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_UART1_RXD,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: UART1_RXD."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x29c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_UART1_TXD,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: UART1_TXD."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 22.
group.long 0x2a0++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_WDOG_B,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: WDOG_B."
        textline "                     "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x2a4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_AUD_MCLK,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: AUD_MCLK."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: AUD_MCLK."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: AUD_MCLK." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: AUD_MCLK." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: AUD_MCLK."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: AUD_MCLK." "0,1"
        textline "                       "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: AUD_MCLK." "0,1"
width 23.
group.long 0x2a8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_AUD_RXC,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: AUD_RXC."
        textline "                      "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: AUD_RXC."
        textline "                      "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                      "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: AUD_RXC." "0,1"
        textline "                      "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: AUD_RXC." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: AUD_RXC."
        textline "                      "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: AUD_RXC." "0,1"
        textline "                      "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: AUD_RXC." "0,1"
width 23.
group.long 0x2ac++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_AUD_RXD,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: AUD_RXD."
        textline "                      "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: AUD_RXD."
        textline "                      "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                      "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: AUD_RXD." "0,1"
        textline "                      "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: AUD_RXD." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: AUD_RXD."
        textline "                      "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: AUD_RXD." "0,1"
        textline "                      "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: AUD_RXD." "0,1"
width 24.
group.long 0x2b0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_AUD_RXFS,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: AUD_RXFS."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: AUD_RXFS."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: AUD_RXFS." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: AUD_RXFS." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: AUD_RXFS."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: AUD_RXFS." "0,1"
        textline "                       "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: AUD_RXFS." "0,1"
width 23.
group.long 0x2b4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_AUD_TXC,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: AUD_TXC."
        textline "                      "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: AUD_TXC."
        textline "                      "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                      "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: AUD_TXC." "0,1"
        textline "                      "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: AUD_TXC." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: AUD_TXC."
        textline "                      "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: AUD_TXC." "0,1"
        textline "                      "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: AUD_TXC." "0,1"
width 23.
group.long 0x2b8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_AUD_TXD,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: AUD_TXD."
        textline "                      "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: AUD_TXD."
        textline "                      "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                      "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: AUD_TXD." "0,1"
        textline "                      "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: AUD_TXD." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: AUD_TXD."
        textline "                      "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: AUD_TXD." "0,1"
        textline "                      "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: AUD_TXD." "0,1"
width 24.
group.long 0x2bc++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_AUD_TXFS,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: AUD_TXFS."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: AUD_TXFS."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: AUD_TXFS." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: AUD_TXFS." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: AUD_TXFS."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: AUD_TXFS." "0,1"
        textline "                       "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: AUD_TXFS." "0,1"
width 27.
group.long 0x2c0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ADDR00,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_A0."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_A0." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_A0." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x2c4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ADDR01,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_A1."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_A1." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_A1." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x2c8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ADDR10,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_A10."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_A10." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_A10." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x2cc++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ADDR11,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_A11."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_A11." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_A11." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x2d0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ADDR12,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_A12."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_A12." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_A12." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x2d4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ADDR13,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_A13."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_A13." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_A13." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x2d8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ADDR14,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_A14."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_A14." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_A14." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x2dc++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ADDR15,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_A15."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_A15." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_A15." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x2e0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ADDR02,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_A2."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_A2." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_A2." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x2e4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ADDR03,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_A3."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_A3." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_A3." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x2e8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ADDR04,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_A4."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_A4." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_A4." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x2ec++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ADDR05,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_A5."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_A5." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_A5." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x2f0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ADDR06,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_A6."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_A6." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_A6." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x2f4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ADDR07,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_A7."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_A7." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_A7." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x2f8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ADDR08,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_A8."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_A8." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_A8." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x2fc++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ADDR09,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_A9."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_A9." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_A9." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 24.
group.long 0x300++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_CAS,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_CAS."
        textline "                       "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_CAS."
        textline "                       "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_CAS." "0,1"
        textline "                       "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_CAS." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 24.
group.long 0x304++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_CS0,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                       "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_CS0."
        textline "                       "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_CS0." "0,1"
        textline "                       "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_CS0." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 24.
group.long 0x308++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_CS1,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                       "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_CS1."
        textline "                       "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_CS1." "0,1"
        textline "                       "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_CS1." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 25.
group.long 0x30c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_DQM0,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_DQM0."
        textline "                        "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_DQM0."
        textline "                        "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_DQM0." "0,1"
        textline "                        "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_DQM0." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 25.
group.long 0x310++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_DQM1,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_DQM1."
        textline "                        "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_DQM1."
        textline "                        "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_DQM1." "0,1"
        textline "                        "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_DQM1." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 25.
group.long 0x314++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_DQM2,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_DQM2."
        textline "                        "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_DQM2."
        textline "                        "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_DQM2." "0,1"
        textline "                        "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_DQM2." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 25.
group.long 0x318++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_DQM3,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_DQM3."
        textline "                        "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_DQM3."
        textline "                        "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_DQM3." "0,1"
        textline "                        "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_DQM3." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 24.
group.long 0x31c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_RAS,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_RAS."
        textline "                       "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_RAS."
        textline "                       "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_RAS." "0,1"
        textline "                       "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_RAS." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 26.
group.long 0x320++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_RESET,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_RESET."
        textline "                         "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_RESET."
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DRAM_RESET." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DRAM_RESET." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DRAM_RESET."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_RESET." "0,1"
        textline "                         "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_RESET." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,Select one of next values for pad: DRAM_RESET."
width 26.
group.long 0x324++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_SDBA0,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                         "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_SDBA0."
        textline "                         "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_SDBA0." "0,1"
        textline "                         "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_SDBA0." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 26.
group.long 0x328++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_SDBA1,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                         "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_SDBA1."
        textline "                         "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_SDBA1." "0,1"
        textline "                         "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_SDBA1." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 26.
group.long 0x32c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_SDBA2,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                         "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_SDBA2."
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DRAM_SDBA2." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DRAM_SDBA2." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_SDBA2." "0,1"
        textline "                         "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_SDBA2." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x330++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_SDCKE0,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_SDCKE0."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DRAM_SDCKE0." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DRAM_SDCKE0." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DRAM_SDCKE0."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_SDCKE0." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_SDCKE0." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x334++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_SDCKE1,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_SDCKE1."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DRAM_SDCKE1." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DRAM_SDCKE1." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DRAM_SDCKE1."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_SDCKE1." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_SDCKE1." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 29.
group.long 0x338++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_SDCLK0_P,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_SDCLK_0."
        textline "                            "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_SDCLK_0."
        textline "                            "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                            "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                            "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                            "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_SDCLK_0." "0,1"
        textline "                            "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_SDCLK_0." "0,1"
        textline "                            "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 25.
group.long 0x33c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ODT0,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_SDODT0."
        textline "                        "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_SDODT0."
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DRAM_SDODT0." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DRAM_SDODT0." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DRAM_SDODT0."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_SDODT0." "0,1"
        textline "                        "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_SDODT0." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 25.
group.long 0x340++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ODT1,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_SDODT1."
        textline "                        "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_SDODT1."
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DRAM_SDODT1." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DRAM_SDODT1." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DRAM_SDODT1."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_SDODT1." "0,1"
        textline "                        "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_SDODT1." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 28.
group.long 0x344++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_SDQS0_P,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_SDQS0."
        textline "                           "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DRAM_SDQS0." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DRAM_SDQS0." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DRAM_SDQS0."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRHYS Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                           "
        bitfld.long 0x00 17. " DDR_INPUT ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 28.
group.long 0x348++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_SDQS1_P,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_SDQS1."
        textline "                           "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DRAM_SDQS1." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DRAM_SDQS1." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DRAM_SDQS1."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRHYS Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                           "
        bitfld.long 0x00 17. " DDR_INPUT ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 28.
group.long 0x34c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_SDQS2_P,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_SDQS2."
        textline "                           "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DRAM_SDQS2." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DRAM_SDQS2." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DRAM_SDQS2."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRHYS Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                           "
        bitfld.long 0x00 17. " DDR_INPUT ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 28.
group.long 0x350++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_SDQS3_P,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_SDQS3."
        textline "                           "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DRAM_SDQS3." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DRAM_SDQS3." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DRAM_SDQS3."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRHYS Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                           "
        bitfld.long 0x00 17. " DDR_INPUT ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 25.
group.long 0x354++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_SDWE,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                        "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_SDWE."
        textline "                        "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_SDWE." "0,1"
        textline "                        "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_SDWE." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x358++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_ECSPI1_MISO,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: ECSPI1_MISO."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: ECSPI1_MISO."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: ECSPI1_MISO." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: ECSPI1_MISO." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: ECSPI1_MISO."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: ECSPI1_MISO." "0,1"
        textline "                          "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: ECSPI1_MISO." "0,1"
width 27.
group.long 0x35c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_ECSPI1_MOSI,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: ECSPI1_MOSI."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: ECSPI1_MOSI."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: ECSPI1_MOSI." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: ECSPI1_MOSI." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: ECSPI1_MOSI."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: ECSPI1_MOSI." "0,1"
        textline "                          "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: ECSPI1_MOSI." "0,1"
width 27.
group.long 0x360++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_ECSPI1_SCLK,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: ECSPI1_SCLK."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: ECSPI1_SCLK."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: ECSPI1_SCLK." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: ECSPI1_SCLK." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: ECSPI1_SCLK."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: ECSPI1_SCLK." "0,1"
        textline "                          "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: ECSPI1_SCLK." "0,1"
width 26.
group.long 0x364++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_ECSPI1_SS0,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: ECSPI1_SS0."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: ECSPI1_SS0."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: ECSPI1_SS0." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: ECSPI1_SS0." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: ECSPI1_SS0."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: ECSPI1_SS0." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: ECSPI1_SS0." "0,1"
width 27.
group.long 0x368++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_ECSPI2_MISO,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: ECSPI2_MISO."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: ECSPI2_MISO."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: ECSPI2_MISO." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: ECSPI2_MISO." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: ECSPI2_MISO."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: ECSPI2_MISO." "0,1"
        textline "                          "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: ECSPI2_MISO." "0,1"
width 27.
group.long 0x36c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_ECSPI2_MOSI,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: ECSPI2_MOSI."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: ECSPI2_MOSI."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: ECSPI2_MOSI." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: ECSPI2_MOSI." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: ECSPI2_MOSI."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: ECSPI2_MOSI." "0,1"
        textline "                          "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: ECSPI2_MOSI." "0,1"
width 27.
group.long 0x370++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_ECSPI2_SCLK,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: ECSPI2_SCLK."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: ECSPI2_SCLK."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: ECSPI2_SCLK." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: ECSPI2_SCLK." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: ECSPI2_SCLK."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: ECSPI2_SCLK." "0,1"
        textline "                          "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: ECSPI2_SCLK." "0,1"
width 26.
group.long 0x374++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_ECSPI2_SS0,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: ECSPI2_SS0."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: ECSPI2_SS0."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: ECSPI2_SS0." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: ECSPI2_SS0." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: ECSPI2_SS0."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: ECSPI2_SS0." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: ECSPI2_SS0." "0,1"
width 25.
group.long 0x378++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_BDR0,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_BDR0."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_BDR0."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_BDR0." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_BDR0." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_BDR0."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_BDR0." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_BDR0." "0,1"
width 25.
group.long 0x37c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_BDR1,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_BDR1."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_BDR1."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_BDR1." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_BDR1." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_BDR1."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_BDR1." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_BDR1." "0,1"
width 27.
group.long 0x380++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_DATA00,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_D0."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_D0."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_D0." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_D0." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_D0."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_D0." "0,1"
        textline "                          "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_D0." "0,1"
width 27.
group.long 0x384++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_DATA01,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_D1."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_D1."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_D1." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_D1." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_D1."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_D1." "0,1"
        textline "                          "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_D1." "0,1"
width 27.
group.long 0x388++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_DATA10,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_D10."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_D10."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_D10." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_D10." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_D10."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_D10." "0,1"
        textline "                          "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_D10." "0,1"
width 27.
group.long 0x38c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_DATA11,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_D11."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_D11."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_D11." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_D11." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_D11."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_D11." "0,1"
        textline "                          "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_D11." "0,1"
width 27.
group.long 0x390++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_DATA12,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_D12."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_D12."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_D12." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_D12." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_D12."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_D12." "0,1"
        textline "                          "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_D12." "0,1"
width 27.
group.long 0x394++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_DATA13,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_D13."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_D13."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_D13." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_D13." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_D13."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_D13." "0,1"
        textline "                          "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_D13." "0,1"
width 27.
group.long 0x398++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_DATA14,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_D14."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_D14."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_D14." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_D14." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_D14."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_D14." "0,1"
        textline "                          "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_D14." "0,1"
width 27.
group.long 0x39c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_DATA15,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_D15."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_D15."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_D15." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_D15." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_D15."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_D15." "0,1"
        textline "                          "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_D15." "0,1"
width 27.
group.long 0x3a0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_DATA02,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_D2."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_D2."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_D2." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_D2." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_D2."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_D2." "0,1"
        textline "                          "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_D2." "0,1"
width 27.
group.long 0x3a4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_DATA03,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_D3."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_D3."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_D3." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_D3." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_D3."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_D3." "0,1"
        textline "                          "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_D3." "0,1"
width 27.
group.long 0x3a8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_DATA04,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_D4."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_D4."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_D4." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_D4." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_D4."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_D4." "0,1"
        textline "                          "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_D4." "0,1"
width 27.
group.long 0x3ac++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_DATA05,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_D5."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_D5."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_D5." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_D5." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_D5."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_D5." "0,1"
        textline "                          "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_D5." "0,1"
width 27.
group.long 0x3b0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_DATA06,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_D6."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_D6."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_D6." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_D6." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_D6."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_D6." "0,1"
        textline "                          "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_D6." "0,1"
width 27.
group.long 0x3b4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_DATA07,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_D7."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_D7."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_D7." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_D7." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_D7."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_D7." "0,1"
        textline "                          "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_D7." "0,1"
width 27.
group.long 0x3b8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_DATA08,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_D8."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_D8."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_D8." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_D8." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_D8."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_D8." "0,1"
        textline "                          "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_D8." "0,1"
width 27.
group.long 0x3bc++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_DATA09,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_D9."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_D9."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_D9." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_D9." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_D9."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_D9." "0,1"
        textline "                          "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_D9." "0,1"
width 26.
group.long 0x3c0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_GDCLK,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_GDCLK."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_GDCLK."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_GDCLK." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_GDCLK." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_GDCLK."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_GDCLK." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_GDCLK." "0,1"
width 25.
group.long 0x3c4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_GDOE,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_GDOE."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_GDOE."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_GDOE." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_GDOE." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_GDOE."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_GDOE." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_GDOE." "0,1"
width 25.
group.long 0x3c8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_GDRL,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_GDRL."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_GDRL."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_GDRL." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_GDRL." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_GDRL."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_GDRL." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_GDRL." "0,1"
width 25.
group.long 0x3cc++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_GDSP,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_GDSP."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_GDSP."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_GDSP." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_GDSP." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_GDSP."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_GDSP." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_GDSP." "0,1"
width 28.
group.long 0x3d0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_PWR_COM,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_PWRCOM."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_PWRCOM."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_PWRCOM." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_PWRCOM." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_PWRCOM."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_PWRCOM." "0,1"
        textline "                           "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_PWRCOM." "0,1"
width 30.
group.long 0x3d4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_PWR_CTRL0,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                             "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_PWRCTRL0."
        textline "                             "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_PWRCTRL0."
        textline "                             "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                             "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_PWRCTRL0." "0,1"
        textline "                             "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_PWRCTRL0." "0,1"
        textline "                             "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_PWRCTRL0."
        textline "                             "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_PWRCTRL0." "0,1"
        textline "                             "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_PWRCTRL0." "0,1"
width 30.
group.long 0x3d8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_PWR_CTRL1,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                             "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_PWRCTRL1."
        textline "                             "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_PWRCTRL1."
        textline "                             "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                             "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_PWRCTRL1." "0,1"
        textline "                             "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_PWRCTRL1." "0,1"
        textline "                             "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_PWRCTRL1."
        textline "                             "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_PWRCTRL1." "0,1"
        textline "                             "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_PWRCTRL1." "0,1"
width 30.
group.long 0x3dc++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_PWR_CTRL2,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                             "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_PWRCTRL2."
        textline "                             "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_PWRCTRL2."
        textline "                             "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                             "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_PWRCTRL2." "0,1"
        textline "                             "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_PWRCTRL2." "0,1"
        textline "                             "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_PWRCTRL2."
        textline "                             "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_PWRCTRL2." "0,1"
        textline "                             "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_PWRCTRL2." "0,1"
width 30.
group.long 0x3e0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_PWR_CTRL3,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                             "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_PWRCTRL3."
        textline "                             "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_PWRCTRL3."
        textline "                             "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                             "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_PWRCTRL3." "0,1"
        textline "                             "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_PWRCTRL3." "0,1"
        textline "                             "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_PWRCTRL3."
        textline "                             "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_PWRCTRL3." "0,1"
        textline "                             "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_PWRCTRL3." "0,1"
width 28.
group.long 0x3e4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_PWR_IRQ,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_PWRINT."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_PWRINT."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_PWRINT." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_PWRINT." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_PWRINT."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_PWRINT." "0,1"
        textline "                           "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_PWRINT." "0,1"
width 29.
group.long 0x3e8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_PWR_STAT,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                            "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_PWRSTAT."
        textline "                            "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_PWRSTAT."
        textline "                            "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                            "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_PWRSTAT." "0,1"
        textline "                            "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_PWRSTAT." "0,1"
        textline "                            "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_PWRSTAT."
        textline "                            "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_PWRSTAT." "0,1"
        textline "                            "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_PWRSTAT." "0,1"
width 29.
group.long 0x3ec++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_PWR_WAKE,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                            "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_PWRWAKEUP."
        textline "                            "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_PWRWAKEUP."
        textline "                            "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                            "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_PWRWAKEUP." "0,1"
        textline "                            "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_PWRWAKEUP." "0,1"
        textline "                            "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_PWRWAKEUP."
        textline "                            "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_PWRWAKEUP." "0,1"
        textline "                            "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_PWRWAKEUP." "0,1"
width 26.
group.long 0x3f0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_SDCE0,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_SDCE0."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_SDCE0."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_SDCE0." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_SDCE0." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_SDCE0."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_SDCE0." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_SDCE0." "0,1"
width 26.
group.long 0x3f4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_SDCE1,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_SDCE1."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_SDCE1."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_SDCE1." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_SDCE1." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_SDCE1."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_SDCE1." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_SDCE1." "0,1"
width 26.
group.long 0x3f8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_SDCE2,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_SDCE2."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_SDCE2."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_SDCE2." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_SDCE2." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_SDCE2."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_SDCE2." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_SDCE2." "0,1"
width 26.
group.long 0x3fc++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_SDCE3,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_SDCE3."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_SDCE3."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_SDCE3." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_SDCE3." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_SDCE3."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_SDCE3." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_SDCE3." "0,1"
width 26.
group.long 0x400++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_SDCLK,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_SDCLK."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_SDCLK."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_SDCLK." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_SDCLK." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_SDCLK."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_SDCLK." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_SDCLK." "0,1"
width 25.
group.long 0x404++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_SDLE,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_SDLE."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_SDLE."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_SDLE." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_SDLE." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_SDLE."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_SDLE." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_SDLE." "0,1"
width 25.
group.long 0x408++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_SDOE,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_SDOE."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_SDOE."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_SDOE." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_SDOE." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_SDOE."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_SDOE." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_SDOE." "0,1"
width 26.
group.long 0x40c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_SDSHR,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_SDSHR."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_SDSHR."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_SDSHR." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_SDSHR." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_SDSHR."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_SDSHR." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_SDSHR." "0,1"
width 26.
group.long 0x410++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_VCOM0,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_VCOM0."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_VCOM0."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_VCOM0." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_VCOM0." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_VCOM0."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_VCOM0." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_VCOM0." "0,1"
width 26.
group.long 0x414++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EPDC_VCOM1,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EPDC_VCOM1."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EPDC_VCOM1."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EPDC_VCOM1." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EPDC_VCOM1." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EPDC_VCOM1."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EPDC_VCOM1." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: EPDC_VCOM1." "0,1"
width 26.
group.long 0x418++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_FEC_CRS_DV,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: FEC_CRS_DV."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: FEC_CRS_DV."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: FEC_CRS_DV." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: FEC_CRS_DV." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: FEC_CRS_DV."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: FEC_CRS_DV." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: FEC_CRS_DV." "0,1"
width 23.
group.long 0x41c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_FEC_MDC,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: FEC_MDC."
        textline "                      "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: FEC_MDC."
        textline "                      "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                      "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: FEC_MDC." "0,1"
        textline "                      "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: FEC_MDC." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: FEC_MDC."
        textline "                      "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: FEC_MDC." "0,1"
        textline "                      "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: FEC_MDC." "0,1"
width 24.
group.long 0x420++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_FEC_MDIO,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: FEC_MDIO."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: FEC_MDIO."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: FEC_MDIO." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: FEC_MDIO." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: FEC_MDIO."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: FEC_MDIO." "0,1"
        textline "                       "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: FEC_MDIO." "0,1"
width 27.
group.long 0x424++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_FEC_REF_CLK,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: FEC_REF_CLK."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: FEC_REF_CLK."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: FEC_REF_CLK." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: FEC_REF_CLK." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: FEC_REF_CLK."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: FEC_REF_CLK." "0,1"
        textline "                          "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: FEC_REF_CLK." "0,1"
width 25.
group.long 0x428++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_FEC_RX_ER,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: FEC_RX_ER."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: FEC_RX_ER."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: FEC_RX_ER." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: FEC_RX_ER." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: FEC_RX_ER."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: FEC_RX_ER." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: FEC_RX_ER." "0,1"
width 28.
group.long 0x42c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_FEC_RX_DATA0,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: FEC_RXD0."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: FEC_RXD0."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: FEC_RXD0." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: FEC_RXD0." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: FEC_RXD0."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: FEC_RXD0." "0,1"
        textline "                           "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: FEC_RXD0." "0,1"
width 28.
group.long 0x430++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_FEC_RX_DATA1,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: FEC_RXD1."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: FEC_RXD1."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: FEC_RXD1." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: FEC_RXD1." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: FEC_RXD1."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: FEC_RXD1." "0,1"
        textline "                           "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: FEC_RXD1." "0,1"
width 26.
group.long 0x434++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_FEC_TX_CLK,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: FEC_TX_CLK."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: FEC_TX_CLK."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: FEC_TX_CLK." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: FEC_TX_CLK." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: FEC_TX_CLK."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: FEC_TX_CLK." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: FEC_TX_CLK." "0,1"
width 25.
group.long 0x438++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_FEC_TX_EN,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: FEC_TX_EN."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: FEC_TX_EN."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: FEC_TX_EN." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: FEC_TX_EN." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: FEC_TX_EN."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: FEC_TX_EN." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: FEC_TX_EN." "0,1"
width 28.
group.long 0x43c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_FEC_TX_DATA0,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: FEC_TXD0."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: FEC_TXD0."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: FEC_TXD0." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: FEC_TXD0." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: FEC_TXD0."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: FEC_TXD0." "0,1"
        textline "                           "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: FEC_TXD0." "0,1"
width 28.
group.long 0x440++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_FEC_TX_DATA1,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: FEC_TXD1."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: FEC_TXD1."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: FEC_TXD1." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: FEC_TXD1." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: FEC_TXD1."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: FEC_TXD1." "0,1"
        textline "                           "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: FEC_TXD1." "0,1"
width 26.
group.long 0x444++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_USB_H_DATA,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: HSIC_DAT."
        textline "                         "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: HSIC_DAT." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: HSIC_DAT." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: HSIC_DAT."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: HSIC_DAT." "0,1"
        textline "                         "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: HSIC_DAT." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL_USB ,Select one of next values for pad: HSIC_DAT."
width 28.
group.long 0x448++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_USB_H_STROBE,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: HSIC_STROBE."
        textline "                           "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: HSIC_STROBE." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: HSIC_STROBE." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: HSIC_STROBE."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: HSIC_STROBE." "0,1"
        textline "                           "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: HSIC_STROBE." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL_USB ,Select one of next values for pad: HSIC_STROBE."
width 24.
group.long 0x44c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_I2C1_SCL,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: I2C1_SCL."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: I2C1_SCL."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: I2C1_SCL." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: I2C1_SCL." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: I2C1_SCL."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: I2C1_SCL." "0,1"
        textline "                       "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: I2C1_SCL." "0,1"
width 24.
group.long 0x450++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_I2C1_SDA,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: I2C1_SDA."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: I2C1_SDA."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: I2C1_SDA." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: I2C1_SDA." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: I2C1_SDA."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: I2C1_SDA." "0,1"
        textline "                       "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: I2C1_SDA." "0,1"
width 24.
group.long 0x454++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_I2C2_SCL,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: I2C2_SCL."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: I2C2_SCL."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: I2C2_SCL." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: I2C2_SCL." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: I2C2_SCL."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: I2C2_SCL." "0,1"
        textline "                       "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: I2C2_SCL." "0,1"
width 24.
group.long 0x458++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_I2C2_SDA,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: I2C2_SDA."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: I2C2_SDA."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: I2C2_SDA." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: I2C2_SDA." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: I2C2_SDA."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: I2C2_SDA." "0,1"
        textline "                       "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: I2C2_SDA." "0,1"
width 24.
group.long 0x45c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_JTAG_MOD,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: JTAG_MOD." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Read Only Field The value of this field is fixed and cannot be changed." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: JTAG_MOD."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: JTAG_MOD." "0,1"
        textline "                       "
        bitfld.long 0x00 22. " LVE ,Read Only Field The value of this field is fixed and cannot be changed." "0,1"
width 24.
group.long 0x460++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_JTAG_TCK,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: JTAG_TCK." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Read Only Field The value of this field is fixed and cannot be changed." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: JTAG_TCK."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: JTAG_TCK." "0,1"
        textline "                       "
        bitfld.long 0x00 22. " LVE ,Read Only Field The value of this field is fixed and cannot be changed." "0,1"
width 24.
group.long 0x464++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_JTAG_TDI,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: JTAG_TDI." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Read Only Field The value of this field is fixed and cannot be changed." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: JTAG_TDI."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: JTAG_TDI." "0,1"
        textline "                       "
        bitfld.long 0x00 22. " LVE ,Read Only Field The value of this field is fixed and cannot be changed." "0,1"
width 24.
group.long 0x468++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_JTAG_TDO,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: JTAG_TDO." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Read Only Field The value of this field is fixed and cannot be changed." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Read Only Field The value of this field is fixed and cannot be changed." "0,1"
        textline "                       "
        bitfld.long 0x00 22. " LVE ,Read Only Field The value of this field is fixed and cannot be changed." "0,1"
width 24.
group.long 0x46c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_JTAG_TMS,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: JTAG_TMS." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Read Only Field The value of this field is fixed and cannot be changed." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: JTAG_TMS."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: JTAG_TMS." "0,1"
        textline "                       "
        bitfld.long 0x00 22. " LVE ,Read Only Field The value of this field is fixed and cannot be changed." "0,1"
width 26.
group.long 0x470++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_JTAG_TRSTB,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: JTAG_TRSTB." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Read Only Field The value of this field is fixed and cannot be changed." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: JTAG_TRSTB."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: JTAG_TRSTB." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Read Only Field The value of this field is fixed and cannot be changed." "0,1"
width 24.
group.long 0x474++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_KEY_COL0,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: KEY_COL0."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: KEY_COL0."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: KEY_COL0." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: KEY_COL0." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: KEY_COL0."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: KEY_COL0." "0,1"
        textline "                       "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: KEY_COL0." "0,1"
width 24.
group.long 0x478++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_KEY_COL1,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: KEY_COL1."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: KEY_COL1."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: KEY_COL1." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: KEY_COL1." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: KEY_COL1."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: KEY_COL1." "0,1"
        textline "                       "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: KEY_COL1." "0,1"
width 24.
group.long 0x47c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_KEY_COL2,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: KEY_COL2."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: KEY_COL2."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: KEY_COL2." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: KEY_COL2." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: KEY_COL2."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: KEY_COL2." "0,1"
        textline "                       "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: KEY_COL2." "0,1"
width 24.
group.long 0x480++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_KEY_COL3,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: KEY_COL3."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: KEY_COL3."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: KEY_COL3." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: KEY_COL3." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: KEY_COL3."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: KEY_COL3." "0,1"
        textline "                       "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: KEY_COL3." "0,1"
width 24.
group.long 0x484++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_KEY_COL4,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: KEY_COL4."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: KEY_COL4."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: KEY_COL4." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: KEY_COL4." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: KEY_COL4."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: KEY_COL4." "0,1"
        textline "                       "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: KEY_COL4." "0,1"
width 24.
group.long 0x488++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_KEY_COL5,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: KEY_COL5."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: KEY_COL5."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: KEY_COL5." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: KEY_COL5." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: KEY_COL5."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: KEY_COL5." "0,1"
        textline "                       "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: KEY_COL5." "0,1"
width 24.
group.long 0x48c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_KEY_COL6,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: KEY_COL6."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: KEY_COL6."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: KEY_COL6." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: KEY_COL6." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: KEY_COL6."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: KEY_COL6." "0,1"
        textline "                       "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: KEY_COL6." "0,1"
width 24.
group.long 0x490++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_KEY_COL7,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: KEY_COL7."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: KEY_COL7."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: KEY_COL7." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: KEY_COL7." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: KEY_COL7."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: KEY_COL7." "0,1"
        textline "                       "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: KEY_COL7." "0,1"
width 24.
group.long 0x494++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_KEY_ROW0,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: KEY_ROW0."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: KEY_ROW0."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: KEY_ROW0." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: KEY_ROW0." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: KEY_ROW0."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: KEY_ROW0." "0,1"
        textline "                       "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: KEY_ROW0." "0,1"
width 24.
group.long 0x498++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_KEY_ROW1,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: KEY_ROW1."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: KEY_ROW1."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: KEY_ROW1." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: KEY_ROW1." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: KEY_ROW1."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: KEY_ROW1." "0,1"
        textline "                       "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: KEY_ROW1." "0,1"
width 24.
group.long 0x49c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_KEY_ROW2,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: KEY_ROW2."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: KEY_ROW2."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: KEY_ROW2." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: KEY_ROW2." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: KEY_ROW2."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: KEY_ROW2." "0,1"
        textline "                       "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: KEY_ROW2." "0,1"
width 24.
group.long 0x4a0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_KEY_ROW3,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: KEY_ROW3."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: KEY_ROW3."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: KEY_ROW3." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: KEY_ROW3." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: KEY_ROW3."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: KEY_ROW3." "0,1"
        textline "                       "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: KEY_ROW3." "0,1"
width 24.
group.long 0x4a4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_KEY_ROW4,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: KEY_ROW4."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: KEY_ROW4."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: KEY_ROW4." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: KEY_ROW4." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: KEY_ROW4."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: KEY_ROW4." "0,1"
        textline "                       "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: KEY_ROW4." "0,1"
width 24.
group.long 0x4a8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_KEY_ROW5,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: KEY_ROW5."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: KEY_ROW5."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: KEY_ROW5." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: KEY_ROW5." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: KEY_ROW5."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: KEY_ROW5." "0,1"
        textline "                       "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: KEY_ROW5." "0,1"
width 24.
group.long 0x4ac++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_KEY_ROW6,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: KEY_ROW6."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: KEY_ROW6."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: KEY_ROW6." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: KEY_ROW6." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: KEY_ROW6."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: KEY_ROW6." "0,1"
        textline "                       "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: KEY_ROW6." "0,1"
width 24.
group.long 0x4b0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_KEY_ROW7,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: KEY_ROW7."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: KEY_ROW7."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: KEY_ROW7." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: KEY_ROW7." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: KEY_ROW7."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: KEY_ROW7." "0,1"
        textline "                       "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: KEY_ROW7." "0,1"
width 23.
group.long 0x4b4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_LCD_CLK,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: LCD_CLK."
        textline "                      "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: LCD_CLK."
        textline "                      "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                      "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: LCD_CLK." "0,1"
        textline "                      "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: LCD_CLK." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: LCD_CLK."
        textline "                      "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: LCD_CLK." "0,1"
        textline "                      "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: LCD_CLK." "0,1"
width 26.
group.long 0x4b8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_LCD_DATA00,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: LCD_DAT0."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: LCD_DAT0."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: LCD_DAT0." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: LCD_DAT0." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: LCD_DAT0."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: LCD_DAT0." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: LCD_DAT0." "0,1"
width 26.
group.long 0x4bc++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_LCD_DATA01,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: LCD_DAT1."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: LCD_DAT1."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: LCD_DAT1." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: LCD_DAT1." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: LCD_DAT1."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: LCD_DAT1." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: LCD_DAT1." "0,1"
width 26.
group.long 0x4c0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_LCD_DATA10,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: LCD_DAT10."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: LCD_DAT10."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: LCD_DAT10." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: LCD_DAT10." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: LCD_DAT10."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: LCD_DAT10." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: LCD_DAT10." "0,1"
width 26.
group.long 0x4c4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_LCD_DATA11,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: LCD_DAT11."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: LCD_DAT11."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: LCD_DAT11." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: LCD_DAT11." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: LCD_DAT11."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: LCD_DAT11." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: LCD_DAT11." "0,1"
width 26.
group.long 0x4c8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_LCD_DATA12,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: LCD_DAT12."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: LCD_DAT12."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: LCD_DAT12." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: LCD_DAT12." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: LCD_DAT12."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: LCD_DAT12." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: LCD_DAT12." "0,1"
width 26.
group.long 0x4cc++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_LCD_DATA13,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: LCD_DAT13."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: LCD_DAT13."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: LCD_DAT13." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: LCD_DAT13." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: LCD_DAT13."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: LCD_DAT13." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: LCD_DAT13." "0,1"
width 26.
group.long 0x4d0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_LCD_DATA14,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: LCD_DAT14."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: LCD_DAT14."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: LCD_DAT14." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: LCD_DAT14." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: LCD_DAT14."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: LCD_DAT14." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: LCD_DAT14." "0,1"
width 26.
group.long 0x4d4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_LCD_DATA15,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: LCD_DAT15."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: LCD_DAT15."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: LCD_DAT15." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: LCD_DAT15." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: LCD_DAT15."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: LCD_DAT15." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: LCD_DAT15." "0,1"
width 26.
group.long 0x4d8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_LCD_DATA16,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: LCD_DAT16."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: LCD_DAT16."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: LCD_DAT16." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: LCD_DAT16." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: LCD_DAT16."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: LCD_DAT16." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: LCD_DAT16." "0,1"
width 26.
group.long 0x4dc++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_LCD_DATA17,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: LCD_DAT17."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: LCD_DAT17."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: LCD_DAT17." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: LCD_DAT17." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: LCD_DAT17."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: LCD_DAT17." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: LCD_DAT17." "0,1"
width 26.
group.long 0x4e0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_LCD_DATA18,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: LCD_DAT18."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: LCD_DAT18."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: LCD_DAT18." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: LCD_DAT18." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: LCD_DAT18."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: LCD_DAT18." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: LCD_DAT18." "0,1"
width 26.
group.long 0x4e4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_LCD_DATA19,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: LCD_DAT19."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: LCD_DAT19."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: LCD_DAT19." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: LCD_DAT19." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: LCD_DAT19."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: LCD_DAT19." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: LCD_DAT19." "0,1"
width 26.
group.long 0x4e8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_LCD_DATA02,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: LCD_DAT2."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: LCD_DAT2."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: LCD_DAT2." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: LCD_DAT2." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: LCD_DAT2."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: LCD_DAT2." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: LCD_DAT2." "0,1"
width 26.
group.long 0x4ec++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_LCD_DATA20,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: LCD_DAT20."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: LCD_DAT20."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: LCD_DAT20." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: LCD_DAT20." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: LCD_DAT20."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: LCD_DAT20." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: LCD_DAT20." "0,1"
width 26.
group.long 0x4f0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_LCD_DATA21,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: LCD_DAT21."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: LCD_DAT21."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: LCD_DAT21." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: LCD_DAT21." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: LCD_DAT21."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: LCD_DAT21." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: LCD_DAT21." "0,1"
width 26.
group.long 0x4f4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_LCD_DATA22,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: LCD_DAT22."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: LCD_DAT22."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: LCD_DAT22." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: LCD_DAT22." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: LCD_DAT22."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: LCD_DAT22." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: LCD_DAT22." "0,1"
width 26.
group.long 0x4f8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_LCD_DATA23,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: LCD_DAT23."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: LCD_DAT23."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: LCD_DAT23." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: LCD_DAT23." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: LCD_DAT23."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: LCD_DAT23." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: LCD_DAT23." "0,1"
width 26.
group.long 0x4fc++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_LCD_DATA03,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: LCD_DAT3."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: LCD_DAT3."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: LCD_DAT3." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: LCD_DAT3." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: LCD_DAT3."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: LCD_DAT3." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: LCD_DAT3." "0,1"
width 26.
group.long 0x500++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_LCD_DATA04,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: LCD_DAT4."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: LCD_DAT4."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: LCD_DAT4." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: LCD_DAT4." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: LCD_DAT4."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: LCD_DAT4." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: LCD_DAT4." "0,1"
width 26.
group.long 0x504++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_LCD_DATA05,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: LCD_DAT5."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: LCD_DAT5."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: LCD_DAT5." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: LCD_DAT5." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: LCD_DAT5."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: LCD_DAT5." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: LCD_DAT5." "0,1"
width 26.
group.long 0x508++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_LCD_DATA06,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: LCD_DAT6."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: LCD_DAT6."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: LCD_DAT6." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: LCD_DAT6." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: LCD_DAT6."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: LCD_DAT6." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: LCD_DAT6." "0,1"
width 26.
group.long 0x50c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_LCD_DATA07,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: LCD_DAT7."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: LCD_DAT7."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: LCD_DAT7." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: LCD_DAT7." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: LCD_DAT7."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: LCD_DAT7." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: LCD_DAT7." "0,1"
width 26.
group.long 0x510++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_LCD_DATA08,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: LCD_DAT8."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: LCD_DAT8."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: LCD_DAT8." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: LCD_DAT8." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: LCD_DAT8."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: LCD_DAT8." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: LCD_DAT8." "0,1"
width 26.
group.long 0x514++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_LCD_DATA09,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: LCD_DAT9."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: LCD_DAT9."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: LCD_DAT9." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: LCD_DAT9." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: LCD_DAT9."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: LCD_DAT9." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: LCD_DAT9." "0,1"
width 26.
group.long 0x518++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_LCD_ENABLE,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: LCD_ENABLE."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: LCD_ENABLE."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: LCD_ENABLE." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: LCD_ENABLE." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: LCD_ENABLE."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: LCD_ENABLE." "0,1"
        textline "                         "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: LCD_ENABLE." "0,1"
width 25.
group.long 0x51c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_LCD_HSYNC,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: LCD_HSYNC."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: LCD_HSYNC."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: LCD_HSYNC." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: LCD_HSYNC." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: LCD_HSYNC."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: LCD_HSYNC." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: LCD_HSYNC." "0,1"
width 25.
group.long 0x520++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_LCD_RESET,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: LCD_RESET."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: LCD_RESET."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: LCD_RESET." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: LCD_RESET." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: LCD_RESET."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: LCD_RESET." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: LCD_RESET." "0,1"
width 25.
group.long 0x524++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_LCD_VSYNC,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: LCD_VSYNC."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: LCD_VSYNC."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: LCD_VSYNC." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: LCD_VSYNC." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: LCD_VSYNC."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: LCD_VSYNC." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: LCD_VSYNC." "0,1"
width 20.
group.long 0x528++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_PWM1,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                   "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: PWM1."
        textline "                   "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: PWM1."
        textline "                   "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                   "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: PWM1." "0,1"
        textline "                   "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: PWM1." "0,1"
        textline "                   "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: PWM1."
        textline "                   "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: PWM1." "0,1"
        textline "                   "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: PWM1." "0,1"
width 27.
group.long 0x52c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_REF_CLK_24M,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: REF_CLK_24M."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: REF_CLK_24M."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: REF_CLK_24M." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: REF_CLK_24M." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: REF_CLK_24M."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: REF_CLK_24M." "0,1"
        textline "                          "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: REF_CLK_24M." "0,1"
width 27.
group.long 0x530++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_REF_CLK_32K,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: REF_CLK_32K."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: REF_CLK_32K."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: REF_CLK_32K." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: REF_CLK_32K." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: REF_CLK_32K."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: REF_CLK_32K." "0,1"
        textline "                          "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: REF_CLK_32K." "0,1"
width 23.
group.long 0x534++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD1_CLK,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD1_CLK."
        textline "                      "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD1_CLK."
        textline "                      "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                      "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD1_CLK." "0,1"
        textline "                      "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD1_CLK." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD1_CLK."
        textline "                      "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD1_CLK." "0,1"
        textline "                      "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: SD1_CLK." "0,1"
width 23.
group.long 0x538++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD1_CMD,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD1_CMD."
        textline "                      "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD1_CMD."
        textline "                      "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                      "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD1_CMD." "0,1"
        textline "                      "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD1_CMD." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD1_CMD."
        textline "                      "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD1_CMD." "0,1"
        textline "                      "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: SD1_CMD." "0,1"
width 25.
group.long 0x53c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD1_DATA0,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD1_DAT0."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD1_DAT0."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD1_DAT0." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD1_DAT0." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD1_DAT0."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD1_DAT0." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: SD1_DAT0." "0,1"
width 25.
group.long 0x540++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD1_DATA1,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD1_DAT1."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD1_DAT1."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD1_DAT1." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD1_DAT1." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD1_DAT1."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD1_DAT1." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: SD1_DAT1." "0,1"
width 25.
group.long 0x544++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD1_DATA2,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD1_DAT2."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD1_DAT2."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD1_DAT2." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD1_DAT2." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD1_DAT2."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD1_DAT2." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: SD1_DAT2." "0,1"
width 25.
group.long 0x548++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD1_DATA3,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD1_DAT3."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD1_DAT3."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD1_DAT3." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD1_DAT3." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD1_DAT3."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD1_DAT3." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: SD1_DAT3." "0,1"
width 25.
group.long 0x54c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD1_DATA4,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD1_DAT4."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD1_DAT4."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD1_DAT4." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD1_DAT4." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD1_DAT4."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD1_DAT4." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: SD1_DAT4." "0,1"
width 25.
group.long 0x550++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD1_DATA5,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD1_DAT5."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD1_DAT5."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD1_DAT5." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD1_DAT5." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD1_DAT5."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD1_DAT5." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: SD1_DAT5." "0,1"
width 25.
group.long 0x554++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD1_DATA6,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD1_DAT6."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD1_DAT6."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD1_DAT6." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD1_DAT6." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD1_DAT6."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD1_DAT6." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: SD1_DAT6." "0,1"
width 25.
group.long 0x558++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD1_DATA7,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD1_DAT7."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD1_DAT7."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD1_DAT7." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD1_DAT7." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD1_DAT7."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD1_DAT7." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: SD1_DAT7." "0,1"
width 23.
group.long 0x55c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD2_CLK,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD2_CLK."
        textline "                      "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD2_CLK."
        textline "                      "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                      "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD2_CLK." "0,1"
        textline "                      "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD2_CLK." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD2_CLK."
        textline "                      "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD2_CLK." "0,1"
        textline "                      "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: SD2_CLK." "0,1"
width 23.
group.long 0x560++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD2_CMD,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD2_CMD."
        textline "                      "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD2_CMD."
        textline "                      "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                      "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD2_CMD." "0,1"
        textline "                      "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD2_CMD." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD2_CMD."
        textline "                      "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD2_CMD." "0,1"
        textline "                      "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: SD2_CMD." "0,1"
width 25.
group.long 0x564++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD2_DATA0,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD2_DAT0."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD2_DAT0."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD2_DAT0." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD2_DAT0." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD2_DAT0."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD2_DAT0." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: SD2_DAT0." "0,1"
width 25.
group.long 0x568++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD2_DATA1,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD2_DAT1."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD2_DAT1."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD2_DAT1." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD2_DAT1." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD2_DAT1."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD2_DAT1." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: SD2_DAT1." "0,1"
width 25.
group.long 0x56c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD2_DATA2,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD2_DAT2."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD2_DAT2."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD2_DAT2." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD2_DAT2." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD2_DAT2."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD2_DAT2." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: SD2_DAT2." "0,1"
width 25.
group.long 0x570++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD2_DATA3,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD2_DAT3."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD2_DAT3."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD2_DAT3." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD2_DAT3." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD2_DAT3."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD2_DAT3." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: SD2_DAT3." "0,1"
width 25.
group.long 0x574++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD2_DATA4,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD2_DAT4."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD2_DAT4."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD2_DAT4." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD2_DAT4." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD2_DAT4."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD2_DAT4." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: SD2_DAT4." "0,1"
width 25.
group.long 0x578++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD2_DATA5,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD2_DAT5."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD2_DAT5."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD2_DAT5." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD2_DAT5." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD2_DAT5."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD2_DAT5." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: SD2_DAT5." "0,1"
width 25.
group.long 0x57c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD2_DATA6,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD2_DAT6."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD2_DAT6."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD2_DAT6." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD2_DAT6." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD2_DAT6."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD2_DAT6." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: SD2_DAT6." "0,1"
width 25.
group.long 0x580++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD2_DATA7,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD2_DAT7."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD2_DAT7."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD2_DAT7." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD2_DAT7." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD2_DAT7."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD2_DAT7." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: SD2_DAT7." "0,1"
width 25.
group.long 0x584++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD2_RESET,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD2_RST."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD2_RST."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD2_RST." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD2_RST." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD2_RST."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD2_RST." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: SD2_RST." "0,1"
width 23.
group.long 0x588++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD3_CLK,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD3_CLK."
        textline "                      "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD3_CLK."
        textline "                      "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                      "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD3_CLK." "0,1"
        textline "                      "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD3_CLK." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD3_CLK."
        textline "                      "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD3_CLK." "0,1"
        textline "                      "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: SD3_CLK." "0,1"
width 23.
group.long 0x58c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD3_CMD,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD3_CMD."
        textline "                      "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD3_CMD."
        textline "                      "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                      "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD3_CMD." "0,1"
        textline "                      "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD3_CMD." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD3_CMD."
        textline "                      "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD3_CMD." "0,1"
        textline "                      "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: SD3_CMD." "0,1"
width 25.
group.long 0x590++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD3_DATA0,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD3_DAT0."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD3_DAT0."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD3_DAT0." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD3_DAT0." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD3_DAT0."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD3_DAT0." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: SD3_DAT0." "0,1"
width 25.
group.long 0x594++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD3_DATA1,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD3_DAT1."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD3_DAT1."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD3_DAT1." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD3_DAT1." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD3_DAT1."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD3_DAT1." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: SD3_DAT1." "0,1"
width 25.
group.long 0x598++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD3_DATA2,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD3_DAT2."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD3_DAT2."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD3_DAT2." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD3_DAT2." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD3_DAT2."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD3_DAT2." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: SD3_DAT2." "0,1"
width 25.
group.long 0x59c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD3_DATA3,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD3_DAT3."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD3_DAT3."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD3_DAT3." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD3_DAT3." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD3_DAT3."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD3_DAT3." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: SD3_DAT3." "0,1"
width 25.
group.long 0x5a0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_UART1_RXD,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: UART1_RXD."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: UART1_RXD."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: UART1_RXD." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: UART1_RXD." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: UART1_RXD."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: UART1_RXD." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: UART1_RXD." "0,1"
width 25.
group.long 0x5a4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_UART1_TXD,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: UART1_TXD."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: UART1_TXD."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: UART1_TXD." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: UART1_TXD." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: UART1_TXD."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: UART1_TXD." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: UART1_TXD." "0,1"
width 22.
group.long 0x5a8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_WDOG_B,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: WDOG_B."
        textline "                     "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: WDOG_B."
        textline "                     "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                     "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: WDOG_B." "0,1"
        textline "                     "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: WDOG_B." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: WDOG_B."
        textline "                     "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: WDOG_B." "0,1"
        textline "                     "
        bitfld.long 0x00 22. " LVE ,Select one of next values for pad: WDOG_B." "0,1"
width 21.
group.long 0x5ac++0x3
    line.long 0x00 "SW_PAD_CTL_GRP_ADDDS,Pad Group Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for group: ."
width 27.
group.long 0x5b0++0x3
    line.long 0x00 "SW_PAD_CTL_GRP_DDRMODE_CTL,Pad Group Control Register"
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for group: ." "0,1"
width 22.
group.long 0x5b4++0x3
    line.long 0x00 "SW_PAD_CTL_GRP_DDRPKE,Pad Group Control Register"
        bitfld.long 0x00 12. " PKE ,Select one of next values for group: ." "0,1"
width 21.
group.long 0x5b8++0x3
    line.long 0x00 "SW_PAD_CTL_GRP_DDRPK,Pad Group Control Register"
        bitfld.long 0x00 13. " PUE ,Select one of next values for group: ." "0,1"
width 22.
group.long 0x5bc++0x3
    line.long 0x00 "SW_PAD_CTL_GRP_DDRHYS,Pad Group Control Register"
        bitfld.long 0x00 16. " HYS ,Select one of next values for group: ." "0,1"
width 23.
group.long 0x5c0++0x3
    line.long 0x00 "SW_PAD_CTL_GRP_DDRMODE,Pad Group Control Register"
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for group: ." "0,1"
width 20.
group.long 0x5c4++0x3
    line.long 0x00 "SW_PAD_CTL_GRP_B0DS,Pad Group Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for group: ."
width 21.
group.long 0x5c8++0x3
    line.long 0x00 "SW_PAD_CTL_GRP_CTLDS,Pad Group Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for group: ."
width 20.
group.long 0x5cc++0x3
    line.long 0x00 "SW_PAD_CTL_GRP_B1DS,Pad Group Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for group: ."
width 24.
group.long 0x5d0++0x3
    line.long 0x00 "SW_PAD_CTL_GRP_DDR_TYPE,Pad Group Control Register"
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,Select one of next values for group: ."
width 20.
group.long 0x5d4++0x3
    line.long 0x00 "SW_PAD_CTL_GRP_B2DS,Pad Group Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for group: ."
width 20.
group.long 0x5d8++0x3
    line.long 0x00 "SW_PAD_CTL_GRP_B3DS,Pad Group Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for group: ."
width 31.
group.long 0x5dc++0x3
    line.long 0x00 "ANALOG_USB_OTG_ID_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--3. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 30.
group.long 0x5e0++0x3
    line.long 0x00 "ANALOG_USB_H1_ID_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 31.
group.long 0x5e4++0x3
    line.long 0x00 "AUD4_INPUT_DA_AMX_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 31.
group.long 0x5e8++0x3
    line.long 0x00 "AUD4_INPUT_DB_AMX_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 34.
group.long 0x5ec++0x3
    line.long 0x00 "AUD4_INPUT_RXCLK_AMX_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 33.
group.long 0x5f0++0x3
    line.long 0x00 "AUD4_INPUT_RXFS_AMX_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 34.
group.long 0x5f4++0x3
    line.long 0x00 "AUD4_INPUT_TXCLK_AMX_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 33.
group.long 0x5f8++0x3
    line.long 0x00 "AUD4_INPUT_TXFS_AMX_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 31.
group.long 0x5fc++0x3
    line.long 0x00 "AUD5_INPUT_DA_AMX_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 31.
group.long 0x600++0x3
    line.long 0x00 "AUD5_INPUT_DB_AMX_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 34.
group.long 0x604++0x3
    line.long 0x00 "AUD5_INPUT_RXCLK_AMX_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 33.
group.long 0x608++0x3
    line.long 0x00 "AUD5_INPUT_RXFS_AMX_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 34.
group.long 0x60c++0x3
    line.long 0x00 "AUD5_INPUT_TXCLK_AMX_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 33.
group.long 0x610++0x3
    line.long 0x00 "AUD5_INPUT_TXFS_AMX_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 31.
group.long 0x614++0x3
    line.long 0x00 "AUD6_INPUT_DA_AMX_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 31.
group.long 0x618++0x3
    line.long 0x00 "AUD6_INPUT_DB_AMX_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 34.
group.long 0x61c++0x3
    line.long 0x00 "AUD6_INPUT_RXCLK_AMX_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 33.
group.long 0x620++0x3
    line.long 0x00 "AUD6_INPUT_RXFS_AMX_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 34.
group.long 0x624++0x3
    line.long 0x00 "AUD6_INPUT_TXCLK_AMX_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 33.
group.long 0x628++0x3
    line.long 0x00 "AUD6_INPUT_TXFS_AMX_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 28.
group.long 0x62c++0x3
    line.long 0x00 "CCM_PMIC_READY_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 28.
group.long 0x630++0x3
    line.long 0x00 "CSI_CSI_DATA00_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 28.
group.long 0x634++0x3
    line.long 0x00 "CSI_CSI_DATA01_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 28.
group.long 0x638++0x3
    line.long 0x00 "CSI_CSI_DATA02_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 28.
group.long 0x63c++0x3
    line.long 0x00 "CSI_CSI_DATA03_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 28.
group.long 0x640++0x3
    line.long 0x00 "CSI_CSI_DATA04_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 28.
group.long 0x644++0x3
    line.long 0x00 "CSI_CSI_DATA05_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 28.
group.long 0x648++0x3
    line.long 0x00 "CSI_CSI_DATA06_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 28.
group.long 0x64c++0x3
    line.long 0x00 "CSI_CSI_DATA07_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 28.
group.long 0x650++0x3
    line.long 0x00 "CSI_CSI_DATA08_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 28.
group.long 0x654++0x3
    line.long 0x00 "CSI_CSI_DATA09_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 28.
group.long 0x658++0x3
    line.long 0x00 "CSI_CSI_DATA10_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 28.
group.long 0x65c++0x3
    line.long 0x00 "CSI_CSI_DATA11_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 28.
group.long 0x660++0x3
    line.long 0x00 "CSI_CSI_DATA12_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 28.
group.long 0x664++0x3
    line.long 0x00 "CSI_CSI_DATA13_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 28.
group.long 0x668++0x3
    line.long 0x00 "CSI_CSI_DATA14_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 28.
group.long 0x66c++0x3
    line.long 0x00 "CSI_CSI_DATA15_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 27.
group.long 0x670++0x3
    line.long 0x00 "CSI_CSI_HSYNC_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 28.
group.long 0x674++0x3
    line.long 0x00 "CSI_CSI_PIXCLK_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 27.
group.long 0x678++0x3
    line.long 0x00 "CSI_CSI_VSYNC_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 32.
group.long 0x67c++0x3
    line.long 0x00 "ECSPI1_CSPI_CLK_IN_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 32.
group.long 0x680++0x3
    line.long 0x00 "ECSPI1_DATAREADY_B_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 25.
group.long 0x684++0x3
    line.long 0x00 "ECSPI1_MISO_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 25.
group.long 0x688++0x3
    line.long 0x00 "ECSPI1_MOSI_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x68c++0x3
    line.long 0x00 "ECSPI1_SS0_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x690++0x3
    line.long 0x00 "ECSPI1_SS1_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x694++0x3
    line.long 0x00 "ECSPI1_SS2_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x698++0x3
    line.long 0x00 "ECSPI1_SS3_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 32.
group.long 0x69c++0x3
    line.long 0x00 "ECSPI2_CSPI_CLK_IN_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 25.
group.long 0x6a0++0x3
    line.long 0x00 "ECSPI2_MISO_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 25.
group.long 0x6a4++0x3
    line.long 0x00 "ECSPI2_MOSI_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 24.
group.long 0x6a8++0x3
    line.long 0x00 "ECSPI2_SS0_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x6ac++0x3
    line.long 0x00 "ECSPI2_SS1_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 32.
group.long 0x6b0++0x3
    line.long 0x00 "ECSPI3_CSPI_CLK_IN_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 32.
group.long 0x6b4++0x3
    line.long 0x00 "ECSPI3_DATAREADY_B_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 25.
group.long 0x6b8++0x3
    line.long 0x00 "ECSPI3_MISO_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 25.
group.long 0x6bc++0x3
    line.long 0x00 "ECSPI3_MOSI_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 24.
group.long 0x6c0++0x3
    line.long 0x00 "ECSPI3_SS0_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 24.
group.long 0x6c4++0x3
    line.long 0x00 "ECSPI3_SS1_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x6c8++0x3
    line.long 0x00 "ECSPI3_SS2_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x6cc++0x3
    line.long 0x00 "ECSPI3_SS3_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 32.
group.long 0x6d0++0x3
    line.long 0x00 "ECSPI4_CSPI_CLK_IN_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 25.
group.long 0x6d4++0x3
    line.long 0x00 "ECSPI4_MISO_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 25.
group.long 0x6d8++0x3
    line.long 0x00 "ECSPI4_MOSI_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 24.
group.long 0x6dc++0x3
    line.long 0x00 "ECSPI4_SS0_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 24.
group.long 0x6e0++0x3
    line.long 0x00 "ECSPI4_SS1_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x6e4++0x3
    line.long 0x00 "ECSPI4_SS2_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 31.
group.long 0x6e8++0x3
    line.long 0x00 "EPDC_EPDC_PWR_IRQ_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 32.
group.long 0x6ec++0x3
    line.long 0x00 "EPDC_EPDC_PWR_STAT_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 25.
group.long 0x6f0++0x3
    line.long 0x00 "FEC_FEC_COL_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 25.
group.long 0x6f4++0x3
    line.long 0x00 "FEC_FEC_MDI_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 30.
group.long 0x6f8++0x3
    line.long 0x00 "FEC_FEC_RX_DATA0_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 30.
group.long 0x6fc++0x3
    line.long 0x00 "FEC_FEC_RX_DATA1_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 28.
group.long 0x700++0x3
    line.long 0x00 "FEC_FEC_RX_CLK_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 27.
group.long 0x704++0x3
    line.long 0x00 "FEC_FEC_RX_DV_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 27.
group.long 0x708++0x3
    line.long 0x00 "FEC_FEC_RX_ER_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 28.
group.long 0x70c++0x3
    line.long 0x00 "FEC_FEC_TX_CLK_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 24.
group.long 0x710++0x3
    line.long 0x00 "GPT_CAPIN1_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x714++0x3
    line.long 0x00 "GPT_CAPIN2_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 23.
group.long 0x718++0x3
    line.long 0x00 "GPT_CLKIN_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 25.
group.long 0x71c++0x3
    line.long 0x00 "I2C1_SCL_IN_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 25.
group.long 0x720++0x3
    line.long 0x00 "I2C1_SDA_IN_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 25.
group.long 0x724++0x3
    line.long 0x00 "I2C2_SCL_IN_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 25.
group.long 0x728++0x3
    line.long 0x00 "I2C2_SDA_IN_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 25.
group.long 0x72c++0x3
    line.long 0x00 "I2C3_SCL_IN_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 25.
group.long 0x730++0x3
    line.long 0x00 "I2C3_SDA_IN_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 22.
group.long 0x734++0x3
    line.long 0x00 "KEY_COL0_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 22.
group.long 0x738++0x3
    line.long 0x00 "KEY_COL1_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 22.
group.long 0x73c++0x3
    line.long 0x00 "KEY_COL2_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 22.
group.long 0x740++0x3
    line.long 0x00 "KEY_COL3_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 22.
group.long 0x744++0x3
    line.long 0x00 "KEY_COL4_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 22.
group.long 0x748++0x3
    line.long 0x00 "KEY_COL5_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 22.
group.long 0x74c++0x3
    line.long 0x00 "KEY_COL6_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 22.
group.long 0x750++0x3
    line.long 0x00 "KEY_COL7_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 22.
group.long 0x754++0x3
    line.long 0x00 "KEY_ROW0_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 22.
group.long 0x758++0x3
    line.long 0x00 "KEY_ROW1_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 22.
group.long 0x75c++0x3
    line.long 0x00 "KEY_ROW2_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 22.
group.long 0x760++0x3
    line.long 0x00 "KEY_ROW3_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 22.
group.long 0x764++0x3
    line.long 0x00 "KEY_ROW4_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 22.
group.long 0x768++0x3
    line.long 0x00 "KEY_ROW5_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 22.
group.long 0x76c++0x3
    line.long 0x00 "KEY_ROW6_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 22.
group.long 0x770++0x3
    line.long 0x00 "KEY_ROW7_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 22.
group.long 0x774++0x3
    line.long 0x00 "LCD_BUSY_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x778++0x3
    line.long 0x00 "LCD_DATA00_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x77c++0x3
    line.long 0x00 "LCD_DATA01_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x780++0x3
    line.long 0x00 "LCD_DATA02_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x784++0x3
    line.long 0x00 "LCD_DATA03_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x788++0x3
    line.long 0x00 "LCD_DATA04_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x78c++0x3
    line.long 0x00 "LCD_DATA05_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x790++0x3
    line.long 0x00 "LCD_DATA06_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x794++0x3
    line.long 0x00 "LCD_DATA07_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x798++0x3
    line.long 0x00 "LCD_DATA08_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x79c++0x3
    line.long 0x00 "LCD_DATA09_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x7a0++0x3
    line.long 0x00 "LCD_DATA10_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x7a4++0x3
    line.long 0x00 "LCD_DATA11_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x7a8++0x3
    line.long 0x00 "LCD_DATA12_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x7ac++0x3
    line.long 0x00 "LCD_DATA13_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x7b0++0x3
    line.long 0x00 "LCD_DATA14_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x7b4++0x3
    line.long 0x00 "LCD_DATA15_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x7b8++0x3
    line.long 0x00 "LCD_DATA16_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x7bc++0x3
    line.long 0x00 "LCD_DATA17_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x7c0++0x3
    line.long 0x00 "LCD_DATA18_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x7c4++0x3
    line.long 0x00 "LCD_DATA19_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x7c8++0x3
    line.long 0x00 "LCD_DATA20_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x7cc++0x3
    line.long 0x00 "LCD_DATA21_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x7d0++0x3
    line.long 0x00 "LCD_DATA22_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x7d4++0x3
    line.long 0x00 "LCD_DATA23_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 27.
group.long 0x7d8++0x3
    line.long 0x00 "MSHC_DI_DATA0_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 27.
group.long 0x7dc++0x3
    line.long 0x00 "MSHC_DI_DATA1_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 27.
group.long 0x7e0++0x3
    line.long 0x00 "MSHC_DI_DATA2_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 27.
group.long 0x7e4++0x3
    line.long 0x00 "MSHC_DI_DATA3_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 26.
group.long 0x7e8++0x3
    line.long 0x00 "MSHC_DI_SCKI_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 29.
group.long 0x7f0++0x3
    line.long 0x00 "SPDIF_SPDIF_IN1_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 27.
group.long 0x7f4++0x3
    line.long 0x00 "SPDIF_TX_CLK2_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 30.
group.long 0x7f8++0x3
    line.long 0x00 "UART1_UART_RTS_B_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 32.
group.long 0x7fc++0x3
    line.long 0x00 "UART1_UART_RX_DATA_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 30.
group.long 0x800++0x3
    line.long 0x00 "UART2_UART_RTS_B_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--3. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 32.
group.long 0x804++0x3
    line.long 0x00 "UART2_UART_RX_DATA_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--3. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 30.
group.long 0x808++0x3
    line.long 0x00 "UART3_UART_RTS_B_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 32.
group.long 0x80c++0x3
    line.long 0x00 "UART3_UART_RX_DATA_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--3. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 30.
group.long 0x810++0x3
    line.long 0x00 "UART4_UART_RTS_B_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--3. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 32.
group.long 0x814++0x3
    line.long 0x00 "UART4_UART_RX_DATA_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--3. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 30.
group.long 0x818++0x3
    line.long 0x00 "UART5_UART_RTS_B_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--3. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 32.
group.long 0x81c++0x3
    line.long 0x00 "UART5_UART_RX_DATA_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--3. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 25.
group.long 0x820++0x3
    line.long 0x00 "USB_OTG2_OC_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 25.
group.long 0x824++0x3
    line.long 0x00 "USB_OTG1_OC_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 29.
group.long 0x828++0x3
    line.long 0x00 "USDHC1_CARD_DET_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 26.
group.long 0x82c++0x3
    line.long 0x00 "USDHC1_WP_ON_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 29.
group.long 0x830++0x3
    line.long 0x00 "USDHC2_CARD_DET_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 26.
group.long 0x834++0x3
    line.long 0x00 "USDHC2_WP_ON_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 29.
group.long 0x838++0x3
    line.long 0x00 "USDHC3_CARD_DET_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 29.
group.long 0x83c++0x3
    line.long 0x00 "USDHC3_DATA4_IN_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 29.
group.long 0x840++0x3
    line.long 0x00 "USDHC3_DATA5_IN_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 29.
group.long 0x844++0x3
    line.long 0x00 "USDHC3_DATA6_IN_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 29.
group.long 0x848++0x3
    line.long 0x00 "USDHC3_DATA7_IN_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 26.
group.long 0x84c++0x3
    line.long 0x00 "USDHC3_WP_ON_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 32.
group.long 0x850++0x3
    line.long 0x00 "USDHC4_CARD_CLK_IN_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 29.
group.long 0x854++0x3
    line.long 0x00 "USDHC4_CARD_DET_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 27.
group.long 0x858++0x3
    line.long 0x00 "USDHC4_CMD_IN_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 29.
group.long 0x85c++0x3
    line.long 0x00 "USDHC4_DATA0_IN_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 29.
group.long 0x860++0x3
    line.long 0x00 "USDHC4_DATA1_IN_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 29.
group.long 0x864++0x3
    line.long 0x00 "USDHC4_DATA2_IN_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 29.
group.long 0x868++0x3
    line.long 0x00 "USDHC4_DATA3_IN_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 29.
group.long 0x86c++0x3
    line.long 0x00 "USDHC4_DATA4_IN_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 29.
group.long 0x870++0x3
    line.long 0x00 "USDHC4_DATA5_IN_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 29.
group.long 0x874++0x3
    line.long 0x00 "USDHC4_DATA6_IN_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 29.
group.long 0x878++0x3
    line.long 0x00 "USDHC4_DATA7_IN_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 26.
group.long 0x87c++0x3
    line.long 0x00 "USDHC4_WP_ON_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 25.
group.long 0x880++0x3
    line.long 0x00 "EIM_DTACK_B_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x884++0x3
    line.long 0x00 "EIM_WAIT_B_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"


tree.end



;--------------------------------------------------------------------------------
; KPP
;--------------------------------------------------------------------------------
tree "KPP"
    base ad:0x020b8000

width 5.
group.word 0x0++0x1
    line.word 0x00 "KPCR,Keypad Control Register"
        hexmask.word.byte 0x00 0.--8. 1. " KRE ,Keypad Row Enable."
        textline "    "
        hexmask.word.byte 0x00 8.--16. 1. " KCO ,Keypad Column Strobe Open-Drain Enable."
width 5.
group.word 0x2++0x1
    line.word 0x00 "KPSR,Keypad Status Register"
        bitfld.word 0x00 0. " KPKD ,Keypad Key Depress." "0,1"
        textline "    "
        bitfld.word 0x00 1. " KPKR ,Keypad Key Release." "0,1"
        textline "    "
        bitfld.word 0x00 2. " KDSC ,Key Depress Synchronizer Clear." "0,1"
        textline "    "
        bitfld.word 0x00 3. " KRSS ,Key Release Synchronizer Set." "0,1"
        textline "    "
        bitfld.word 0x00 8. " KDIE ,Keypad Key Depress Interrupt Enable." "0,1"
        textline "    "
        bitfld.word 0x00 9. " KRIE ,Keypad Release Interrupt Enable." "0,1"
width 5.
group.word 0x4++0x1
    line.word 0x00 "KDDR,Keypad Data Direction Register"
        hexmask.word.byte 0x00 0.--8. 1. " KRDD ,Keypad Row Data Direction."
        textline "    "
        hexmask.word.byte 0x00 8.--16. 1. " KCDD ,Keypad Column Data Direction Register."
width 5.
group.word 0x6++0x1
    line.word 0x00 "KPDR,Keypad Data Register"
        hexmask.word.byte 0x00 0.--8. 1. " KRD ,Keypad Row Data."
        textline "    "
        hexmask.word.byte 0x00 8.--16. 1. " KCD ,Keypad Column Data."


tree.end



;--------------------------------------------------------------------------------
; MMDC
;--------------------------------------------------------------------------------
tree "MMDC"
    base ad:0x021b0000

width 6.
group.long 0x0++0x3
    line.long 0x00 "MDCTL,MMDC Core Control Register"
        hexmask.long.byte 0x00 16.--18. 1. " DSIZ ,DDR data bus size."
        textline "     "
        bitfld.long 0x00 19. " BL ,Burst Length." "0,1"
        textline "     "
        hexmask.long.byte 0x00 20.--23. 1. " COL ,Column Address Width."
        textline "     "
        hexmask.long.byte 0x00 24.--27. 1. " ROW ,Row Address Width."
        textline "     "
        bitfld.long 0x00 30. " SDE_1 ,MMDC Enable CS1." "0,1"
        textline "     "
        bitfld.long 0x00 31. " SDE_0 ,MMDC Enable CS0." "0,1"
width 6.
group.long 0x4++0x3
    line.long 0x00 "MDPDC,MMDC Core Power Down Control Register"
        hexmask.long.byte 0x00 0.--3. 1. " TCKSRE ,Valid clock cycles after self-refresh entry."
        textline "     "
        hexmask.long.byte 0x00 3.--6. 1. " TCKSRX ,Valid clock cycles before self-refresh exit."
        textline "     "
        bitfld.long 0x00 6. " BOTH_CS_PD ,Parallel power down entry to both chip selects." "0,1"
        textline "     "
        bitfld.long 0x00 7. " SLOW_PD ,Slow/fast power down." "0,1"
        textline "     "
        hexmask.long.byte 0x00 8.--12. 1. " PWDT_0 ,Power Down Timer - Chip Select 0."
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " PWDT_1 ,Power Down Timer - Chip Select 1."
        textline "     "
        hexmask.long.byte 0x00 16.--19. 1. " TCKE ,CKE minimum pulse width."
        textline "     "
        hexmask.long.byte 0x00 24.--27. 1. " PRCT_0 ,Precharge Timer - Chip Select 0."
        textline "     "
        hexmask.long.byte 0x00 28.--31. 1. " PRCT_1 ,Precharge Timer - Chip Select 1."
width 6.
group.long 0x8++0x3
    line.long 0x00 "MDOTC,MMDC Core ODT Timing Control Register"
        hexmask.long.byte 0x00 4.--9. 1. " TODT_IDLE_OFF ,ODT turn off latency."
        textline "     "
        hexmask.long.byte 0x00 12.--15. 1. " TODTLON ,ODT turn on latency."
        textline "     "
        hexmask.long.byte 0x00 16.--20. 1. " TAXPD ,Asynchronous ODT to power down exit delay."
        textline "     "
        hexmask.long.byte 0x00 20.--24. 1. " TANPD ,Asynchronous ODT to power down entry delay."
        textline "     "
        hexmask.long.byte 0x00 24.--27. 1. " TAONPD ,Asynchronous RTT turn-on delay (power down with DLL frozen)."
        textline "     "
        hexmask.long.byte 0x00 27.--30. 1. " TAOFPD ,Asynchronous RTT turn-off delay (power down with DLL frozen)."
width 7.
group.long 0xc++0x3
    line.long 0x00 "MDCFG0,MMDC Core Timing Configuration Register 0"
        hexmask.long.byte 0x00 0.--4. 1. " TCL ,CAS Read Latency."
        textline "      "
        hexmask.long.byte 0x00 4.--9. 1. " TFAW ,Four Active Window (all banks)."
        textline "      "
        hexmask.long.byte 0x00 9.--13. 1. " TXPDLL ,Exit precharge power down with DLL frozen to commands requiring DLL."
        textline "      "
        hexmask.long.byte 0x00 13.--16. 1. " TXP ,Exit power down with DLL-on to any valid command."
        textline "      "
        hexmask.long.byte 0x00 16.--24. 1. " TXS ,Exit self refresh to non READ command."
        textline "      "
        hexmask.long.byte 0x00 24.--32. 1. " TRFC ,Refresh command to Active or Refresh command time."
width 7.
group.long 0x10++0x3
    line.long 0x00 "MDCFG1,MMDC Core Timing Configuration Register 1"
        hexmask.long.byte 0x00 0.--3. 1. " TCWL ,CAS Write Latency."
        textline "      "
        hexmask.long.byte 0x00 5.--9. 1. " TMRD ,Mode Register Set command cycle (all banks)."
        textline "      "
        hexmask.long.byte 0x00 9.--12. 1. " TWR ,WRITE recovery time (same bank)."
        textline "      "
        bitfld.long 0x00 15. " TRPA ,Precharge-all command period." "0,1"
        textline "      "
        hexmask.long.byte 0x00 16.--21. 1. " TRAS ,Active to Precharge command period (same bank)."
        textline "      "
        hexmask.long.byte 0x00 21.--26. 1. " TRC ,Active to Active or Refresh command period (same bank)."
        textline "      "
        hexmask.long.byte 0x00 26.--29. 1. " TRP ,Precharge command period (same bank)."
        textline "      "
        hexmask.long.byte 0x00 29.--32. 1. " TRCD ,Active command to internal read or write delay time (same bank)."
width 7.
group.long 0x14++0x3
    line.long 0x00 "MDCFG2,MMDC Core Timing Configuration Register 2"
        hexmask.long.byte 0x00 0.--3. 1. " TRRD ,Active to Active command period (all banks)."
        textline "      "
        hexmask.long.byte 0x00 3.--6. 1. " TWTR ,Internal WRITE to READ command delay (same bank)."
        textline "      "
        hexmask.long.byte 0x00 6.--9. 1. " TRTP ,Internal READ command to Precharge command delay (same bank)."
        textline "      "
        hexmask.long.word 0x00 16.--25. 1. " TDLLK ,DLL locking time."
width 7.
group.long 0x18++0x3
    line.long 0x00 "MDMISC,MMDC Core Miscellaneous Register"
        bitfld.long 0x00 1. " RST ,Software Reset." "0,1"
        textline "      "
        hexmask.long.byte 0x00 3.--5. 1. " DDR_TYPE ,DDR TYPE."
        textline "      "
        bitfld.long 0x00 5. " DDR_4_BANK ,Number of banks per DDR device." "0,1"
        textline "      "
        hexmask.long.byte 0x00 6.--9. 1. " RALAT ,Read Additional Latency."
        textline "      "
        hexmask.long.byte 0x00 9.--11. 1. " MIF3_MODE ,Command prediction working mode."
        textline "      "
        bitfld.long 0x00 11. " LPDDR2_S2 ,LPDDR2 S2 device type indication." "0,1"
        textline "      "
        bitfld.long 0x00 12. " BI_ON ,Bank Interleaving On." "0,1"
        textline "      "
        hexmask.long.byte 0x00 16.--18. 1. " WALAT ,Write Additional latency."
        textline "      "
        bitfld.long 0x00 18. " LHD ,Latency hiding disable." "0,1"
        textline "      "
        bitfld.long 0x00 19. " ADDR_MIRROR ,Address mirroring." "0,1"
        textline "      "
        bitfld.long 0x00 20. " CALIB_PER_CS ,Number of chip-select for calibration process." "0,1"
        textline "      "
        bitfld.long 0x00 21. " CK1_GATING ,Gating the secondary DDR clock." "0,1"
        textline "      "
        bitfld.long 0x00 30. " CS1_RDY ,External status device on CS1." "0,1"
        textline "      "
        bitfld.long 0x00 31. " CS0_RDY ,External status device on CS0." "0,1"
width 6.
group.long 0x1c++0x3
    line.long 0x00 "MDSCR,MMDC Core Special Command Register"
        hexmask.long.byte 0x00 0.--3. 1. " CMD_BA ,Bank Address."
        textline "     "
        bitfld.long 0x00 3. " CMD_CS ,Chip Select." "0,1"
        textline "     "
        hexmask.long.byte 0x00 4.--7. 1. " CMD ,Command."
        textline "     "
        bitfld.long 0x00 9. " WL_EN ,DQS pads direction." "0,1"
        textline "     "
        bitfld.long 0x00 10. " MRR_READ_DATA_VALID ,MRR read data valid." "0,1"
        textline "     "
        bitfld.long 0x00 14. " CON_ACK ,Configuration acknowledge." "0,1"
        textline "     "
        bitfld.long 0x00 15. " CON_REQ ,Configuration request." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--24. 1. " CMD_ADDR_LSB_MR_ADDR ,Command/Address LSB."
        textline "     "
        hexmask.long.byte 0x00 24.--32. 1. " CMD_ADDR_MSB_MR_OP ,Command/Address MSB."
width 6.
group.long 0x20++0x3
    line.long 0x00 "MDREF,MMDC Core Refresh Control Register"
        bitfld.long 0x00 0. " START_REF ,Manual start of refresh cycle." "0,1"
        textline "     "
        hexmask.long.byte 0x00 11.--14. 1. " REFR ,Refresh Rate."
        textline "     "
        hexmask.long.byte 0x00 14.--16. 1. " REF_SEL ,Refresh Selector."
        textline "     "
        hexmask.long.word 0x00 16.--32. 1. " REF_CNT ,Refresh Counter at DDR clock period If REF_SEL equals '2' a refresh cycle will begin every amount of DDR cycles configured in this field."
width 6.
group.long 0x2c++0x3
    line.long 0x00 "MDRWD,MMDC Core Read/Write Command Delay Register"
        hexmask.long.byte 0x00 0.--3. 1. " RTR_DIFF ,Read to read delay for different chip-select."
        textline "     "
        hexmask.long.byte 0x00 3.--6. 1. " RTW_DIFF ,Read to write delay for different chip-select."
        textline "     "
        hexmask.long.byte 0x00 6.--9. 1. " WTW_DIFF ,Write to write delay for different chip-select."
        textline "     "
        hexmask.long.byte 0x00 9.--12. 1. " WTR_DIFF ,Write to read delay for different chip-select."
        textline "     "
        hexmask.long.byte 0x00 12.--15. 1. " RTW_SAME ,Read to write delay for the same chip-select."
        textline "     "
        hexmask.long.word 0x00 16.--29. 1. " TDAI ,Device auto initialization period.(maximum) This field is relevant only to LPDDR2 mode"
width 5.
group.long 0x30++0x3
    line.long 0x00 "MDOR,MMDC Core Out of Reset Delays Register"
        hexmask.long.byte 0x00 0.--6. 1. " RST_TO_CKE ,DDR3: Time from SDE enable to CKE rise."
        textline "    "
        hexmask.long.byte 0x00 8.--14. 1. " SDE_TO_RST ,DDR3: Time from SDE enable until DDR reset# is high."
        textline "    "
        hexmask.long.byte 0x00 16.--24. 1. " TXPR ,DDR3: CKE HIGH to a valid command."
width 6.
rgroup.long 0x34++0x3
    line.long 0x00 "MDMRR,MMDC Core MRR Data Register"
        hexmask.long.byte 0x00 0.--8. 1. " MRR_READ_DATA0 ,MRR DATA that arrived on DQ[7:0]"
        textline "     "
        hexmask.long.byte 0x00 8.--16. 1. " MRR_READ_DATA1 ,MRR DATA that arrived on DQ[15:8]"
        textline "     "
        hexmask.long.byte 0x00 16.--24. 1. " MRR_READ_DATA2 ,MRR DATA that arrived on DQ[23:16]"
        textline "     "
        hexmask.long.byte 0x00 24.--32. 1. " MRR_READ_DATA3 ,MRR DATA that arrived on DQ[31:24]"
width 9.
group.long 0x38++0x3
    line.long 0x00 "MDCFG3LP,MMDC Core Timing Configuration Register 3"
        hexmask.long.byte 0x00 0.--4. 1. " TRPAB_LP ,Precharge (all banks) command period."
        textline "        "
        hexmask.long.byte 0x00 4.--8. 1. " TRPPB_LP ,Precharge (per bank) command period (same bank)."
        textline "        "
        hexmask.long.byte 0x00 8.--12. 1. " TRCD_LP ,Active command to internal read or write delay time (same bank)."
        textline "        "
        hexmask.long.byte 0x00 16.--22. 1. " RC_LP ,Active to Active or Refresh command period (same bank)."
width 6.
group.long 0x3c++0x3
    line.long 0x00 "MDMR4,MMDC Core MR4 Derating Register"
        bitfld.long 0x00 0. " UPDATE_DE_REQ ,Update Derated Values Request." "0,1"
        textline "     "
        bitfld.long 0x00 1. " UPDATE_DE_ACK ,Update Derated Values Acknowledge." "0,1"
        textline "     "
        bitfld.long 0x00 4. " TRCD_DE ,tRCD derating value." "0,1"
        textline "     "
        bitfld.long 0x00 5. " TRC_DE ,tRC derating value." "0,1"
        textline "     "
        bitfld.long 0x00 6. " TRAS_DE ,tRAS derating value." "0,1"
        textline "     "
        bitfld.long 0x00 7. " TRP_DE ,tRP derating value." "0,1"
        textline "     "
        bitfld.long 0x00 8. " TRRD_DE ,tRRD derating value." "0,1"
width 6.
group.long 0x40++0x3
    line.long 0x00 "MDASP,MMDC Core Address Space Partition Register"
        hexmask.long.byte 0x00 0.--7. 1. " CS0_END ,CS0_END."
width 7.
group.long 0x400++0x3
    line.long 0x00 "MAARCR,MMDC Core AXI Reordering Control Regsiter"
        hexmask.long.byte 0x00 0.--4. 1. " ARCR_GUARD ,ARCR Guard."
        textline "      "
        hexmask.long.byte 0x00 4.--8. 1. " ARCR_DYN_MAX ,ARCR Dynamic Maximum."
        textline "      "
        hexmask.long.byte 0x00 8.--12. 1. " ARCR_DYN_JMP ,ARCR Dynamic Jump."
        textline "      "
        hexmask.long.byte 0x00 16.--19. 1. " ARCR_ACC_HIT ,ARCR Access Hit Rate."
        textline "      "
        hexmask.long.byte 0x00 20.--23. 1. " ARCR_PAG_HIT ,ARCR Page Hit Rate."
        textline "      "
        bitfld.long 0x00 24. " ARCR_RCH_EN ,This bit defines whether Real time channel is activated and bypassed all other pending accesses, So accesses with QoS=='F' will be granted the highest prioritiy in the optimization/reordering mechanism Default value is 0x1 - encoding 1 (Enabled)" "0,1"
        textline "      "
        bitfld.long 0x00 28. " ARCR_EXC_ERR_EN ,This bit defines whether exclusive read/write access violation of AXI 6.2.4 rule result in SLV Error response or in OKAY response Default value is 0x1 - encoding 1(response is SLV Error)" "0,1"
        textline "      "
        bitfld.long 0x00 30. " ARCR_SEC_ERR_EN ,This bit defines whether security read/write access violation result in SLV Error response or in OKAY response Default value is 0x1 - encoding 1(response is SLV Error, rresp/bresp=2'b10)" "0,1"
        textline "      "
        bitfld.long 0x00 31. " ARCR_SEC_ERR_LOCK ,Once set, this bit locks ARCR_SEC_ERR_EN and prevents from its updating." "0,1"
width 6.
group.long 0x404++0x3
    line.long 0x00 "MAPSR,MMDC Core Power Saving Control and Status Register"
        bitfld.long 0x00 0. " PSD ,Automatic Power Saving Disable." "0,1"
        textline "     "
        bitfld.long 0x00 4. " PSS ,Power Saving Status." "0,1"
        textline "     "
        bitfld.long 0x00 5. " RIS ,Read Idle Status.This read only bit indicates whether read request buffer is idle (empty) or not." "0,1"
        textline "     "
        bitfld.long 0x00 6. " WIS ,Write Idle Status.This read only bit indicates whether write request buffer is idle (empty) or not." "0,1"
        textline "     "
        hexmask.long.byte 0x00 8.--16. 1. " PST ,Automatic Power saving timer."
        textline "     "
        bitfld.long 0x00 20. " LPMD ,General LPMD request." "0,1"
        textline "     "
        bitfld.long 0x00 21. " DVFS ,General DVFS request." "0,1"
        textline "     "
        bitfld.long 0x00 24. " LPACK ,General low-power acknowledge." "0,1"
        textline "     "
        bitfld.long 0x00 25. " DVACK ,General DVFS acknowledge." "0,1"
width 9.
group.long 0x408++0x3
    line.long 0x00 "MAEXIDR0,MMDC Core Exclusive ID Monitor Register0"
        hexmask.long.word 0x00 0.--16. 1. " EXC_ID_MONITOR0 ,This feild defines ID for Exclusive monitor#0."
        textline "        "
        hexmask.long.word 0x00 16.--32. 1. " EXC_ID_MONITOR1 ,This feild defines ID for Exclusive monitor#1."
width 9.
group.long 0x40c++0x3
    line.long 0x00 "MAEXIDR1,MMDC Core Exclusive ID Monitor Register1"
        hexmask.long.word 0x00 0.--16. 1. " EXC_ID_MONITOR2 ,This feild defines ID for Exclusive monitor#2."
        textline "        "
        hexmask.long.word 0x00 16.--32. 1. " EXC_ID_MONITOR3 ,This feild defines ID for Exclusive monitor#3."
width 8.
group.long 0x410++0x3
    line.long 0x00 "MADPCR0,MMDC Core Debug and Profiling Control Register 0"
        bitfld.long 0x00 0. " DBG_EN ,Debug and Profiling Enable." "0,1"
        textline "       "
        bitfld.long 0x00 1. " DBG_RST ,Debug and Profiling Reset." "0,1"
        textline "       "
        bitfld.long 0x00 2. " PRF_FRZ ,Profiling freeze." "0,1"
        textline "       "
        bitfld.long 0x00 3. " CYC_OVF ,Total Profiling Cycles Count Overflow." "0,1"
        textline "       "
        bitfld.long 0x00 8. " SBS_EN ,Step By Step debug Enable." "0,1"
        textline "       "
        bitfld.long 0x00 9. " SBS ,Step By Step trigger." "0,1"
width 8.
group.long 0x414++0x3
    line.long 0x00 "MADPCR1,MMDC Core Debug and Profiling Control Register 1"
        hexmask.long.word 0x00 0.--16. 1. " PRF_AXI_ID ,Profiling AXI ID."
        textline "       "
        hexmask.long.word 0x00 16.--32. 1. " PRF_AXI_ID_MASK ,Profiling AXI ID Mask."
width 8.
rgroup.long 0x418++0x3
    line.long 0x00 "MADPSR0,MMDC Core Debug and Profiling Status Register 0"
        hexmask.long.long 0x00 0.--32. 1. " CYC_COUNT ,Total Profiling cycle Count."
width 8.
rgroup.long 0x41c++0x3
    line.long 0x00 "MADPSR1,MMDC Core Debug and Profiling Status Register 1"
        hexmask.long.long 0x00 0.--32. 1. " BUSY_COUNT ,Profiling Busy Cycles Count."
width 8.
rgroup.long 0x420++0x3
    line.long 0x00 "MADPSR2,MMDC Core Debug and Profiling Status Register 2"
        hexmask.long.long 0x00 0.--32. 1. " RD_ACC_COUNT ,Profiling Read Access Count."
width 8.
rgroup.long 0x424++0x3
    line.long 0x00 "MADPSR3,MMDC Core Debug and Profiling Status Register 3"
        hexmask.long.long 0x00 0.--32. 1. " WR_ACC_COUNT ,Profiling Write Access Count."
width 8.
rgroup.long 0x428++0x3
    line.long 0x00 "MADPSR4,MMDC Core Debug and Profiling Status Register 4"
        hexmask.long.long 0x00 0.--32. 1. " RD_BYTES_COUNT ,Profiling Read Bytes Count."
width 8.
rgroup.long 0x42c++0x3
    line.long 0x00 "MADPSR5,MMDC Core Debug and Profiling Status Register 5"
        hexmask.long.long 0x00 0.--32. 1. " WR_BYTES_COUNT ,Profiling Write Bytes Count."
width 7.
rgroup.long 0x430++0x3
    line.long 0x00 "MASBS0,MMDC Core Step By Step Address Register"
        hexmask.long.long 0x00 0.--32. 1. " SBS_ADDR ,Step By Step Address."
width 7.
rgroup.long 0x434++0x3
    line.long 0x00 "MASBS1,MMDC Core Step By Step Address Attributes Register"
        bitfld.long 0x00 0. " SBS_VLD ,Step By Step Valid." "0,1"
        textline "      "
        bitfld.long 0x00 1. " SBS_TYPE ,Step By Step Request Type." "0,1"
        textline "      "
        hexmask.long.byte 0x00 2.--4. 1. " SBS_LOCK ,Step By Step Lock."
        textline "      "
        hexmask.long.byte 0x00 4.--7. 1. " SBS_PROT ,Step By Step Protection."
        textline "      "
        hexmask.long.byte 0x00 7.--10. 1. " SBS_SIZE ,Step By Step Size."
        textline "      "
        hexmask.long.byte 0x00 10.--12. 1. " SBS_BURST ,Step By Step Burst."
        textline "      "
        bitfld.long 0x00 12. " SBS_BUFF ,Step By Step Buffered." "0,1"
        textline "      "
        hexmask.long.byte 0x00 13.--16. 1. " SBS_LEN ,Step By Step Length."
        textline "      "
        hexmask.long.word 0x00 16.--32. 1. " SBS_AXI_ID ,Step By Step AXI ID."
width 7.
group.long 0x440++0x3
    line.long 0x00 "MAGENP,MMDC Core General Purpose Register"
        hexmask.long.long 0x00 0.--32. 1. " GP31_GP0 ,General purpose read/write bits."
width 11.
group.long 0x800++0x3
    line.long 0x00 "MPZQHWCTRL,MMDC PHY ZQ HW control register"
        hexmask.long.byte 0x00 0.--2. 1. " ZQ_MODE ,ZQ calibration mode:"
        textline "          "
        hexmask.long.byte 0x00 2.--6. 1. " ZQ_HW_PER ,ZQ periodic calibration time."
        textline "          "
        hexmask.long.byte 0x00 6.--11. 1. " ZQ_HW_PU_RES ,ZQ automatic calibration pull-up result."
        textline "          "
        hexmask.long.byte 0x00 11.--16. 1. " ZQ_HW_PD_RES ,ZQ HW calibration pull-down result."
        textline "          "
        bitfld.long 0x00 16. " ZQ_HW_FOR ,Force ZQ automatic calibration process with the i.MX ZQ calibration pad." "0,1"
        textline "          "
        hexmask.long.byte 0x00 17.--20. 1. " TZQ_INIT ,Device ZQ long/init time."
        textline "          "
        hexmask.long.byte 0x00 20.--23. 1. " TZQ_OPER ,Device ZQ long/oper time."
        textline "          "
        hexmask.long.byte 0x00 23.--26. 1. " TZQ_CS ,Device ZQ short time."
        textline "          "
        hexmask.long.byte 0x00 27.--32. 1. " ZQ_EARLY_COMPARATOR_EN_TIMER ,ZQ early comparator enable timer."
width 11.
group.long 0x804++0x3
    line.long 0x00 "MPZQSWCTRL,MMDC PHY ZQ SW control register"
        bitfld.long 0x00 0. " ZQ_SW_FOR ,ZQ SW calibration enable." "0,1"
        textline "          "
        bitfld.long 0x00 1. " ZQ_SW_RES ,ZQ software calibration result." "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--7. 1. " ZQ_SW_PU_VAL ,ZQ software pull-up resistence.This field determines the value of the PU resistor during SW ZQ calibration."
        textline "          "
        hexmask.long.byte 0x00 7.--12. 1. " ZQ_SW_PD_VAL ,ZQ software pull-down resistence.This field determines the value of the PD resistor during SW ZQ calibration."
        textline "          "
        bitfld.long 0x00 12. " ZQ_SW_PD ,ZQ software PU/PD calibration." "0,1"
        textline "          "
        bitfld.long 0x00 13. " USE_ZQ_SW_VAL ,Use SW ZQ configured value for I/O pads resistor controls." "0,1"
        textline "          "
        hexmask.long.byte 0x00 16.--18. 1. " ZQ_CMP_OUT_SMP ,Defines the amount of cycles between driving the ZQ signals to the ZQ pad and till sampling the comparator enable output while performing ZQ calibration process with the i.MX ZQ calibration pad"
width 8.
group.long 0x808++0x3
    line.long 0x00 "MPWLGCR,MMDC PHY Write Leveling Configuration and Error Status Register"
        bitfld.long 0x00 0. " HW_WL_EN ,Write-Leveling HW (automatic) enable." "0,1"
        textline "       "
        bitfld.long 0x00 1. " SW_WL_EN ,Write-Leveling SW enable." "0,1"
        textline "       "
        bitfld.long 0x00 2. " SW_WL_CNT_EN ,SW write-leveling count down enable.This bit when asserted set a certain delay of (25+15) cycles from the setting of SW_WL_EN and before driving the DQS to the DDR device.This bit should be asserted before the first SW write-leveling request and after issuing the write leveling MRS command" "0,1"
        textline "       "
        bitfld.long 0x00 4. " WL_SW_RES0 ,Byte0 write-leveling software result." "0,1"
        textline "       "
        bitfld.long 0x00 5. " WL_SW_RES1 ,Byte1 write-leveling software result." "0,1"
        textline "       "
        bitfld.long 0x00 6. " WL_SW_RES2 ,Byte2 write-leveling software result." "0,1"
        textline "       "
        bitfld.long 0x00 7. " WL_SW_RES3 ,Byte3 write-leveling software result." "0,1"
        textline "       "
        bitfld.long 0x00 8. " WL_HW_ERR0 ,Byte0 write-leveling HW calibration error." "0,1"
        textline "       "
        bitfld.long 0x00 9. " WL_HW_ERR1 ,Byte1 write-leveling HW calibration error." "0,1"
        textline "       "
        bitfld.long 0x00 10. " WL_HW_ERR2 ,Byte2 write-leveling HW calibration error." "0,1"
        textline "       "
        bitfld.long 0x00 11. " WL_HW_ERR3 ,Byte3 write-leveling HW calibration error." "0,1"
width 12.
group.long 0x80c++0x3
    line.long 0x00 "MPWLDECTRL0,MMDC PHY Write Leveling Delay Control Register 0"
        hexmask.long.byte 0x00 0.--7. 1. " WL_DL_ABS_OFFSET0 ,Absolute write-leveling delay offset for Byte 0."
        textline "           "
        bitfld.long 0x00 8. " WL_HC_DEL0 ,Write leveling half cycle delay for Byte 0." "0,1"
        textline "           "
        hexmask.long.byte 0x00 9.--11. 1. " WL_CYC_DEL0 ,Write leveling cycle delay for Byte 0."
        textline "           "
        hexmask.long.byte 0x00 16.--23. 1. " WL_DL_ABS_OFFSET1 ,Absolute write-leveling delay offset for Byte 1."
        textline "           "
        bitfld.long 0x00 24. " WL_HC_DEL1 ,Write leveling half cycle delay for Byte 1." "0,1"
        textline "           "
        hexmask.long.byte 0x00 25.--27. 1. " WL_CYC_DEL1 ,Write leveling cycle delay for Byte 1."
width 12.
group.long 0x810++0x3
    line.long 0x00 "MPWLDECTRL1,MMDC PHY Write Leveling Delay Control Register 1"
        hexmask.long.byte 0x00 0.--7. 1. " WL_DL_ABS_OFFSET2 ,Absolute write-leveling delay offset for Byte 2."
        textline "           "
        bitfld.long 0x00 8. " WL_HC_DEL2 ,Write leveling half cycle delay for Byte 2." "0,1"
        textline "           "
        hexmask.long.byte 0x00 9.--11. 1. " WL_CYC_DEL2 ,Write leveling cycle delay for Byte 2."
        textline "           "
        hexmask.long.byte 0x00 16.--23. 1. " WL_DL_ABS_OFFSET3 ,Absolute write-leveling delay offset for Byte 3."
        textline "           "
        bitfld.long 0x00 24. " WL_HC_DEL3 ,Write leveling half cycle delay for Byte 3." "0,1"
        textline "           "
        hexmask.long.byte 0x00 25.--27. 1. " WL_CYC_DEL3 ,Write leveling cycle delay for Byte 3."
width 9.
rgroup.long 0x814++0x3
    line.long 0x00 "MPWLDLST,MMDC PHY Write Leveling delay-line Status Register"
        hexmask.long.byte 0x00 0.--7. 1. " WL_DL_UNIT_NUM0 ,This field reflects the number of delay units that are actually used by write leveling delay-line 0."
        textline "        "
        hexmask.long.byte 0x00 8.--15. 1. " WL_DL_UNIT_NUM1 ,This field reflects the number of delay units that are actually used by write leveling delay-line 1."
        textline "        "
        hexmask.long.byte 0x00 16.--23. 1. " WL_DL_UNIT_NUM2 ,This field reflects the number of delay units that are actually used by write leveling delay-line 2."
        textline "        "
        hexmask.long.byte 0x00 24.--31. 1. " WL_DL_UNIT_NUM3 ,This field reflects the number of delay units that are actually used by write leveling delay-line 3."
width 10.
group.long 0x818++0x3
    line.long 0x00 "MPODTCTRL,MMDC PHY ODT control register"
        bitfld.long 0x00 0. " ODT_WR_PAS_EN ,Inactive write CS ODT enable." "0,1"
        textline "         "
        bitfld.long 0x00 1. " ODT_WR_ACT_EN ,Active write CS ODT enable." "0,1"
        textline "         "
        bitfld.long 0x00 2. " ODT_RD_PAS_EN ,Inactive read CS ODT enable." "0,1"
        textline "         "
        bitfld.long 0x00 3. " ODT_RD_ACT_EN ,Active read CS ODT enable." "0,1"
        textline "         "
        hexmask.long.byte 0x00 4.--7. 1. " ODT0_INT_RES ,On chip ODT byte0 resistor - This field determines the Rtt_Nom of the on chip ODT byte0 resistor during read accesses."
        textline "         "
        hexmask.long.byte 0x00 8.--11. 1. " ODT1_INT_RES ,On chip ODT byte1 resistor - This field determines the Rtt_Nom of the on chip ODT byte1 resistor during read accesses."
        textline "         "
        hexmask.long.byte 0x00 12.--15. 1. " ODT2_INT_RES ,On chip ODT byte2 resistor - This field determines the Rtt_Nom of the on chip ODT byte2 resistor during read accesses."
        textline "         "
        hexmask.long.byte 0x00 16.--19. 1. " ODT3_INT_RES ,On chip ODT byte3 resistor - This field determines the Rtt_Nom of the on chip ODT byte3 resistor during read accesses."
width 12.
group.long 0x81c++0x3
    line.long 0x00 "MPRDDQBY0DL,MMDC PHY Read DQ Byte0 Delay Register"
        hexmask.long.byte 0x00 0.--3. 1. " RD_DQ0_DEL ,Read dqs0 to dq0 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 4.--7. 1. " RD_DQ1_DEL ,Read dqs0 to dq1 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 8.--11. 1. " RD_DQ2_DEL ,Read dqs0 to dq2 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 12.--15. 1. " RD_DQ3_DEL ,Read dqs0 to dq3 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 16.--19. 1. " RD_DQ4_DEL ,Read dqs0 to dq4 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 20.--23. 1. " RD_DQ5_DEL ,Read dqs0 to dq5 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 24.--27. 1. " RD_DQ6_DEL ,Read dqs0 to dq6 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 28.--31. 1. " RD_DQ7_DEL ,Read dqs0 to dq7 delay fine-tuning."
width 12.
group.long 0x820++0x3
    line.long 0x00 "MPRDDQBY1DL,MMDC PHY Read DQ Byte1 Delay Register"
        hexmask.long.byte 0x00 0.--3. 1. " RD_DQ8_DEL ,Read dqs1 to dq8 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 4.--7. 1. " RD_DQ9_DEL ,Read dqs1 to dq9 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 8.--11. 1. " RD_DQ10_DEL ,Read dqs1 to dq10 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 12.--15. 1. " RD_DQ11_DEL ,Read dqs1 to dq11 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 16.--19. 1. " RD_DQ12_DEL ,Read dqs1 to dq12 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 20.--23. 1. " RD_DQ13_DEL ,Read dqs1 to dq13 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 24.--27. 1. " RD_DQ14_DEL ,Read dqs1 to dq14 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 28.--31. 1. " RD_DQ15_DEL ,Read dqs1 to dq15 delay fine-tuning."
width 12.
group.long 0x824++0x3
    line.long 0x00 "MPRDDQBY2DL,MMDC PHY Read DQ Byte2 Delay Register"
        hexmask.long.byte 0x00 0.--3. 1. " RD_DQ16_DEL ,Read dqs2 to dq16 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 4.--7. 1. " RD_DQ17_DEL ,Read dqs2 to dq17 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 8.--11. 1. " RD_DQ18_DEL ,Read dqs2 to dq18 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 12.--15. 1. " RD_DQ19_DEL ,Read dqs2 to dq19 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 16.--19. 1. " RD_DQ20_DEL ,Read dqs2 to dq20 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 20.--23. 1. " RD_DQ21_DEL ,Read dqs2 to dq21 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 24.--27. 1. " RD_DQ22_DEL ,Read dqs2 to dq22 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 28.--31. 1. " RD_DQ23_DEL ,Read dqs2 to dq23 delay fine-tuning."
width 12.
group.long 0x828++0x3
    line.long 0x00 "MPRDDQBY3DL,MMDC PHY Read DQ Byte3 Delay Register"
        hexmask.long.byte 0x00 0.--3. 1. " RD_DQ24_DEL ,Read dqs3 to dq24 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 4.--7. 1. " RD_DQ25_DEL ,Read dqs3 to dq25 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 8.--11. 1. " RD_DQ26_DEL ,Read dqs3 to dq26 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 12.--15. 1. " RD_DQ27_DEL ,Read dqs3 to dq27 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 16.--19. 1. " RD_DQ28_DEL ,Read dqs3 to dq28 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 20.--23. 1. " RD_DQ29_DEL ,Read dqs3 to dq29 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 24.--27. 1. " RD_DQ30_DEL ,Read dqs3 to dq30 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 28.--31. 1. " RD_DQ31_DEL ,Read dqs3 to dq31 delay fine-tuning."
width 12.
group.long 0x82c++0x3
    line.long 0x00 "MPWRDQBY0DL,MMDC PHY Write DQ Byte0 Delay Register"
        hexmask.long.byte 0x00 0.--2. 1. " WR_DQ0_DEL ,Write dq0 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 4.--6. 1. " WR_DQ1_DEL ,Write dq1 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 8.--10. 1. " WR_DQ2_DEL ,Write dq2 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 12.--14. 1. " WR_DQ3_DEL ,Write dq3 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 16.--18. 1. " WR_DQ4_DEL ,Write dq4 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 20.--22. 1. " WR_DQ5_DEL ,Write dq5 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 24.--26. 1. " WR_DQ6_DEL ,Write dq6 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 28.--30. 1. " WR_DQ7_DEL ,Write dq7 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 30.--32. 1. " WR_DM0_DEL ,Write dm0 delay fine-tuning."
width 12.
group.long 0x830++0x3
    line.long 0x00 "MPWRDQBY1DL,MMDC PHY Write DQ Byte1 Delay Register"
        hexmask.long.byte 0x00 0.--2. 1. " WR_DQ8_DEL ,Write dq8 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 4.--6. 1. " WR_DQ9_DEL ,Write dq9 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 8.--10. 1. " WR_DQ10_DEL ,Write dq10 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 12.--14. 1. " WR_DQ11_DEL ,Write dq11 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 16.--18. 1. " WR_DQ12_DEL ,Write dq12 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 20.--22. 1. " WR_DQ13_DEL ,Write dq13 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 24.--26. 1. " WR_DQ14_DEL ,Write dq14 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 28.--30. 1. " WR_DQ15_DEL ,Write dq15 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 30.--32. 1. " WR_DM1_DEL ,Write dm1 delay fine-tuning."
width 12.
group.long 0x834++0x3
    line.long 0x00 "MPWRDQBY2DL,MMDC PHY Write DQ Byte2 Delay Register"
        hexmask.long.byte 0x00 0.--2. 1. " WR_DQ16_DEL ,Write dq16 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 4.--6. 1. " WR_DQ17_DEL ,Write dq17 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 8.--10. 1. " WR_DQ18_DEL ,Write dq18 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 12.--14. 1. " WR_DQ19_DEL ,Write dq19 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 16.--18. 1. " WR_DQ20_DEL ,Write dq20 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 20.--22. 1. " WR_DQ21_DEL ,Write dq21 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 24.--26. 1. " WR_DQ22_DEL ,Write dq22 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 28.--30. 1. " WR_DQ23_DEL ,Write dq23 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 30.--32. 1. " WR_DM2_DEL ,Write dm2 delay fine-tuning."
width 12.
group.long 0x838++0x3
    line.long 0x00 "MPWRDQBY3DL,MMDC PHY Write DQ Byte3 Delay Register"
        hexmask.long.byte 0x00 0.--2. 1. " WR_DQ24_DEL ,Write dq24 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 4.--6. 1. " WR_DQ25_DEL ,Write dq25 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 8.--10. 1. " WR_DQ26_DEL ,Write dq26 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 12.--14. 1. " WR_DQ27_DEL ,Write dq27 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 16.--18. 1. " WR_DQ28_DEL ,Write dq28 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 20.--22. 1. " WR_DQ29_DEL ,Write dq29 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 24.--26. 1. " WR_DQ30_DEL ,Write dq30 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 28.--30. 1. " WR_DQ31_DEL ,Write dq31 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 30.--32. 1. " WR_DM3_DEL ,Write dm3 delay fine tuning."
width 10.
group.long 0x83c++0x3
    line.long 0x00 "MPDGCTRL0,MMDC PHY Read DQS Gating Control Register 0"
        hexmask.long.byte 0x00 0.--7. 1. " DG_DL_ABS_OFFSET0 ,Absolute read DQS gating delay offset for Byte0."
        textline "         "
        hexmask.long.byte 0x00 8.--12. 1. " DG_HC_DEL0 ,Read DQS gating half cycles delay for Byte0 ."
        textline "         "
        bitfld.long 0x00 12. " HW_DG_ERR ,HW DQS gating error." "0,1"
        textline "         "
        hexmask.long.byte 0x00 16.--23. 1. " DG_DL_ABS_OFFSET1 ,Absolute read DQS gating delay offset for Byte1."
        textline "         "
        bitfld.long 0x00 23. " DG_EXT_UP ,DG extend upper boundary." "0,1"
        textline "         "
        hexmask.long.byte 0x00 24.--28. 1. " DG_HC_DEL1 ,Read DQS gating half cycles delay for Byte1 ."
        textline "         "
        bitfld.long 0x00 28. " HW_DG_EN ,Enable automatic read DQS gating calibration." "0,1"
        textline "         "
        bitfld.long 0x00 29. " DG_DIS ,Read DQS gating disable." "0,1"
        textline "         "
        bitfld.long 0x00 30. " DG_CMP_CYC ,Read DQS gating sample cycle." "0,1"
        textline "         "
        bitfld.long 0x00 31. " RST_RD_FIFO ,Reset Read Data FIFO and associated pointers." "0,1"
width 10.
group.long 0x840++0x3
    line.long 0x00 "MPDGCTRL1,MMDC PHY Read DQS Gating Control Register 1"
        hexmask.long.byte 0x00 0.--7. 1. " DG_DL_ABS_OFFSET2 ,Absolute read DQS gating delay offset for Byte2."
        textline "         "
        hexmask.long.byte 0x00 8.--12. 1. " DG_HC_DEL2 ,Read DQS gating half cycles delay for Byte2 ."
        textline "         "
        hexmask.long.byte 0x00 16.--23. 1. " DG_DL_ABS_OFFSET3 ,Absolute read DQS gating delay offset for Byte3."
        textline "         "
        hexmask.long.byte 0x00 24.--28. 1. " DG_HC_DEL3 ,Read DQS gating half cycles delay for Byte3 ."
width 10.
rgroup.long 0x844++0x3
    line.long 0x00 "MPDGDLST0,MMDC PHY Read DQS Gating delay-line Status Register"
        hexmask.long.byte 0x00 0.--7. 1. " DG_DL_UNIT_NUM0 ,This field reflects the number of delay units that are actually used by read DQS gating delay-line 0."
        textline "         "
        hexmask.long.byte 0x00 8.--15. 1. " DG_DL_UNIT_NUM1 ,This field reflects the number of delay units that are actually used by read DQS gating delay-line 1."
        textline "         "
        hexmask.long.byte 0x00 16.--23. 1. " DG_DL_UNIT_NUM2 ,This field reflects the number of delay units that are actually used by read DQS gating delay-line 2."
        textline "         "
        hexmask.long.byte 0x00 24.--31. 1. " DG_DL_UNIT_NUM3 ,This field reflects the number of delay units that are actually used by read DQS gating delay-line 3."
width 10.
group.long 0x848++0x3
    line.long 0x00 "MPRDDLCTL,MMDC PHY Read delay-lines Configuration Register"
        hexmask.long.byte 0x00 0.--7. 1. " RD_DL_ABS_OFFSET0 ,Absolute read delay offset for Byte0."
        textline "         "
        hexmask.long.byte 0x00 8.--15. 1. " RD_DL_ABS_OFFSET1 ,Absolute read delay offset for Byte1."
        textline "         "
        hexmask.long.byte 0x00 16.--23. 1. " RD_DL_ABS_OFFSET2 ,Absolute read delay offset for Byte2."
        textline "         "
        hexmask.long.byte 0x00 24.--31. 1. " RD_DL_ABS_OFFSET3 ,Absolute read delay offset for Byte3."
width 9.
rgroup.long 0x84c++0x3
    line.long 0x00 "MPRDDLST,MMDC PHY Read delay-lines Status Register"
        hexmask.long.byte 0x00 0.--7. 1. " RD_DL_UNIT_NUM0 ,This field reflects the number of delay units that are actually used by read delay-line 0."
        textline "        "
        hexmask.long.byte 0x00 8.--15. 1. " RD_DL_UNIT_NUM1 ,This field reflects the number of delay units that are actually used by read delay-line 1."
        textline "        "
        hexmask.long.byte 0x00 16.--23. 1. " RD_DL_UNIT_NUM2 ,This field reflects the number of delay units that are actually used by read delay-line 2."
        textline "        "
        hexmask.long.byte 0x00 24.--31. 1. " RD_DL_UNIT_NUM3 ,This field reflects the number of delay units that are actually used by read delay-line 3."
width 10.
group.long 0x850++0x3
    line.long 0x00 "MPWRDLCTL,MMDC PHY Write delay-lines Configuration Register"
        hexmask.long.byte 0x00 0.--7. 1. " WR_DL_ABS_OFFSET0 ,Absolute write delay offset for Byte0."
        textline "         "
        hexmask.long.byte 0x00 8.--15. 1. " WR_DL_ABS_OFFSET1 ,Absolute write delay offset for Byte1."
        textline "         "
        hexmask.long.byte 0x00 16.--23. 1. " WR_DL_ABS_OFFSET2 ,Absolute write delay offset for Byte2."
        textline "         "
        hexmask.long.byte 0x00 24.--31. 1. " WR_DL_ABS_OFFSET3 ,Absolute write delay offset for Byte3."
width 9.
rgroup.long 0x854++0x3
    line.long 0x00 "MPWRDLST,MMDC PHY Write delay-lines Status Register"
        hexmask.long.byte 0x00 0.--7. 1. " WR_DL_UNIT_NUM0 ,This field reflects the number of delay units that are actually used by write delay-line 0."
        textline "        "
        hexmask.long.byte 0x00 8.--15. 1. " WR_DL_UNIT_NUM1 ,This field reflects the number of delay units that are actually used by write delay-line 1."
        textline "        "
        hexmask.long.byte 0x00 16.--23. 1. " WR_DL_UNIT_NUM2 ,This field reflects the number of delay units that are actually used by write delay-line 2."
        textline "        "
        hexmask.long.byte 0x00 24.--31. 1. " WR_DL_UNIT_NUM3 ,This field reflects the number of delay units that are actually used by write delay-line 3."
width 9.
group.long 0x858++0x3
    line.long 0x00 "MPSDCTRL,MMDC PHY CK Control Register"
        hexmask.long.byte 0x00 8.--10. 1. " SDCLK0_DEL ,DDR clock0 delay fine tuning."
        textline "        "
        hexmask.long.byte 0x00 10.--12. 1. " SDCLK1_DEL ,DDR clock1 delay fine tuning."
width 11.
group.long 0x85c++0x3
    line.long 0x00 "MPZQLP2CTL,MMDC ZQ LPDDR2 HW Control Register"
        hexmask.long.word 0x00 0.--9. 1. " ZQ_LP2_HW_ZQINIT ,This register defines the period in cycles that it takes the memory device to perform a Init ZQ calibration."
        textline "          "
        hexmask.long.byte 0x00 16.--24. 1. " ZQ_LP2_HW_ZQCL ,This register defines the period in cycles that it takes the memory device to perform a long ZQ calibration."
        textline "          "
        hexmask.long.byte 0x00 24.--31. 1. " ZQ_LP2_HW_ZQCS ,This register defines the period in cycles that it takes the memory device to perform a Short ZQ calibration."
width 12.
group.long 0x860++0x3
    line.long 0x00 "MPRDDLHWCTL,MMDC PHY Read Delay HW Calibration Control Register"
        bitfld.long 0x00 0. " HW_RD_DL_ERR0 ,Automatic (HW) read calibration error of Byte0." "0,1"
        textline "           "
        bitfld.long 0x00 1. " HW_RD_DL_ERR1 ,Automatic (HW) read calibration error of Byte1." "0,1"
        textline "           "
        bitfld.long 0x00 2. " HW_RD_DL_ERR2 ,Automatic (HW) read calibration error of Byte2." "0,1"
        textline "           "
        bitfld.long 0x00 3. " HW_RD_DL_ERR3 ,Automatic (HW) read calibration error of Byte3." "0,1"
        textline "           "
        bitfld.long 0x00 4. " HW_RD_DL_EN ,Enable automatic (HW) read calibration." "0,1"
        textline "           "
        bitfld.long 0x00 5. " HW_RD_DL_CMP_CYC ,Automatic (HW) read sample cycle." "0,1"
width 12.
group.long 0x864++0x3
    line.long 0x00 "MPWRDLHWCTL,MMDC PHY Write Delay HW Calibration Control Register"
        bitfld.long 0x00 0. " HW_WR_DL_ERR0 ,Automatic (HW) write calibration error of Byte0." "0,1"
        textline "           "
        bitfld.long 0x00 1. " HW_WR_DL_ERR1 ,Automatic (HW) write calibration error of Byte1." "0,1"
        textline "           "
        bitfld.long 0x00 2. " HW_WR_DL_ERR2 ,Automatic (HW) write calibration error of Byte2." "0,1"
        textline "           "
        bitfld.long 0x00 3. " HW_WR_DL_ERR3 ,Automatic (HW) write calibration error of Byte3." "0,1"
        textline "           "
        bitfld.long 0x00 4. " HW_WR_DL_EN ,Enable automatic (HW) write calibration." "0,1"
        textline "           "
        bitfld.long 0x00 5. " HW_WR_DL_CMP_CYC ,Write sample cycle." "0,1"
width 12.
rgroup.long 0x868++0x3
    line.long 0x00 "MPRDDLHWST0,MMDC PHY Read Delay HW Calibration Status Register 0"
        hexmask.long.byte 0x00 0.--7. 1. " HW_RD_DL_LOW0 ,Automatic (HW) read calibration result of the lower boundary of Byte0."
        textline "           "
        hexmask.long.byte 0x00 8.--15. 1. " HW_RD_DL_UP0 ,Automatic (HW) read calibration result of the upper boundary of Byte0."
        textline "           "
        hexmask.long.byte 0x00 16.--23. 1. " HW_RD_DL_LOW1 ,Automatic (HW) read calibration result of the lower boundary of Byte1."
        textline "           "
        hexmask.long.byte 0x00 24.--31. 1. " HW_RD_DL_UP1 ,Automatic (HW) read calibration result of the upper boundary of Byte1."
width 12.
rgroup.long 0x86c++0x3
    line.long 0x00 "MPRDDLHWST1,MMDC PHY Read Delay HW Calibration Status Register 1"
        hexmask.long.byte 0x00 0.--7. 1. " HW_RD_DL_LOW2 ,Automatic (HW) read calibration result of the lower boundary of Byte2."
        textline "           "
        hexmask.long.byte 0x00 8.--15. 1. " HW_RD_DL_UP2 ,Automatic (HW) read calibration result of the upper boundary of Byte2."
        textline "           "
        hexmask.long.byte 0x00 16.--23. 1. " HW_RD_DL_LOW3 ,Automatic (HW) read calibration result of the lower boundary of Byte3."
        textline "           "
        hexmask.long.byte 0x00 24.--31. 1. " HW_RD_DL_UP3 ,Automatic (HW) read calibration result of the upper boundary of Byte3."
width 12.
rgroup.long 0x870++0x3
    line.long 0x00 "MPWRDLHWST0,MMDC PHY Write Delay HW Calibration Status Register 0"
        hexmask.long.byte 0x00 0.--7. 1. " HW_WR_DL_LOW0 ,Automatic (HW) write calibration result of the lower boundary of Byte0."
        textline "           "
        hexmask.long.byte 0x00 8.--15. 1. " HW_WR_DL_UP0 ,Automatic (HW) write calibration result of the upper boundary of Byte0."
        textline "           "
        hexmask.long.byte 0x00 16.--23. 1. " HW_WR_DL_LOW1 ,Automatic (HW) write calibration result of the lower boundary of Byte1."
        textline "           "
        hexmask.long.byte 0x00 24.--31. 1. " HW_WR_DL_UP1 ,Aautomatic (HW) write utomatic (HW) write calibration result of the upper boundary of Byte1."
width 12.
rgroup.long 0x874++0x3
    line.long 0x00 "MPWRDLHWST1,MMDC PHY Write Delay HW Calibration Status Register 1"
        hexmask.long.byte 0x00 0.--7. 1. " HW_WR_DL_LOW2 ,Automatic (HW) write calibration result of the lower boundary of Byte2."
        textline "           "
        hexmask.long.byte 0x00 8.--15. 1. " HW_WR_DL_UP2 ,Automatic (HW) write calibration result of the upper boundary of Byte2."
        textline "           "
        hexmask.long.byte 0x00 16.--23. 1. " HW_WR_DL_LOW3 ,Automatic (HW) write calibration result of the lower boundary of Byte3."
        textline "           "
        hexmask.long.byte 0x00 24.--31. 1. " HW_WR_DL_UP3 ,Automatic (HW) write calibration result of the upper boundary of Byte3."
width 10.
group.long 0x878++0x3
    line.long 0x00 "MPWLHWERR,MMDC PHY Write Leveling HW Error Register"
        hexmask.long.byte 0x00 0.--8. 1. " HW_WL0_DQ ,HW write-leveling calibration result of Byte0."
        textline "         "
        hexmask.long.byte 0x00 8.--16. 1. " HW_WL1_DQ ,HW write-leveling calibration result of Byte1."
        textline "         "
        hexmask.long.byte 0x00 16.--24. 1. " HW_WL2_DQ ,HW write-leveling calibration result of Byte2."
        textline "         "
        hexmask.long.byte 0x00 24.--32. 1. " HW_WL3_DQ ,HW write-leveling calibration result of Byte3."
width 10.
rgroup.long 0x87c++0x3
    line.long 0x00 "MPDGHWST0,MMDC PHY Read DQS Gating HW Status Register 0"
        hexmask.long.word 0x00 0.--11. 1. " HW_DG_LOW0 ,HW DQS gating calibration result of the lower boundary of Byte0."
        textline "         "
        hexmask.long.word 0x00 16.--27. 1. " HW_DG_UP0 ,HW DQS gating calibration result of the upper boundary of Byte0."
width 10.
rgroup.long 0x880++0x3
    line.long 0x00 "MPDGHWST1,MMDC PHY Read DQS Gating HW Status Register 1"
        hexmask.long.word 0x00 0.--11. 1. " HW_DG_LOW1 ,HW DQS gating calibration result of the lower boundary of Byte1."
        textline "         "
        hexmask.long.word 0x00 16.--27. 1. " HW_DG_UP1 ,HW DQS gating calibration result of the upper boundary of Byte1."
width 10.
rgroup.long 0x884++0x3
    line.long 0x00 "MPDGHWST2,MMDC PHY Read DQS Gating HW Status Register 2"
        hexmask.long.word 0x00 0.--11. 1. " HW_DG_LOW2 ,HW DQS gating calibration result of the lower boundary of Byte2."
        textline "         "
        hexmask.long.word 0x00 16.--27. 1. " HW_DG_UP2 ,HW DQS gating calibration result of the upper boundary of Byte2."
width 10.
rgroup.long 0x888++0x3
    line.long 0x00 "MPDGHWST3,MMDC PHY Read DQS Gating HW Status Register 3"
        hexmask.long.word 0x00 0.--11. 1. " HW_DG_LOW3 ,HW DQS gating calibration result of the lower boundary of Byte3."
        textline "         "
        hexmask.long.word 0x00 16.--27. 1. " HW_DG_UP3 ,HW DQS gating calibration result of the upper boundary of Byte3."
width 10.
group.long 0x88c++0x3
    line.long 0x00 "MPPDCMPR1,MMDC PHY Pre-defined Compare Register 1"
        hexmask.long.word 0x00 0.--16. 1. " PDV1 ,MMDC Pre defined comapre value2."
        textline "         "
        hexmask.long.word 0x00 16.--32. 1. " PDV2 ,MMDC Pre defined comapre value2."
width 10.
group.long 0x890++0x3
    line.long 0x00 "MPPDCMPR2,MMDC PHY Pre-defined Compare and CA delay-line Configuration Register"
        bitfld.long 0x00 0. " MPR_CMP ,MPR(DDR3)/DQ calibration (LPDDR2) comapre enable." "0,1"
        textline "         "
        bitfld.long 0x00 1. " MPR_FULL_CMP ,MPR(DDR3)/DQ calibration (LPDDR2) full compare enable." "0,1"
        textline "         "
        bitfld.long 0x00 2. " READ_LEVEL_PATTERN ,MPR(DDR3)/DQ calibration(LPDDR2) read compare pattern." "0,1"
        textline "         "
        hexmask.long.byte 0x00 16.--23. 1. " CA_DL_ABS_OFFSET ,Absolute CA (Command/Address of LPDDRR2) offset."
        textline "         "
        hexmask.long.byte 0x00 24.--31. 1. " PHY_CA_DL_UNIT ,This field reflects the number of delay units that are actually used by CA (Command/Address of LPDDR2) delay-line"
width 9.
group.long 0x894++0x3
    line.long 0x00 "MPSWDAR0,MMDC PHY SW Dummy Access Register"
        bitfld.long 0x00 0. " SW_DUMMY_WR ,SW dummy write." "0,1"
        textline "        "
        bitfld.long 0x00 1. " SW_DUMMY_RD ,SW dummy read." "0,1"
        textline "        "
        bitfld.long 0x00 2. " SW_DUM_CMP0 ,SW dummy read byte0 compare results." "0,1"
        textline "        "
        bitfld.long 0x00 3. " SW_DUM_CMP1 ,SW dummy read byte1 compare results." "0,1"
        textline "        "
        bitfld.long 0x00 4. " SW_DUM_CMP2 ,SW dummy read byte2 compare results." "0,1"
        textline "        "
        bitfld.long 0x00 5. " SW_DUM_CMP3 ,SW dummy read byte3 compare results." "0,1"
width 10.
rgroup.long 0x898++0x3
    line.long 0x00 "MPSWDRDR0,MMDC PHY SW Dummy Read Data Register 0"
        hexmask.long.long 0x00 0.--32. 1. " DUM_RD0 ,Dummy read data0."
width 10.
rgroup.long 0x89c++0x3
    line.long 0x00 "MPSWDRDR1,MMDC PHY SW Dummy Read Data Register 1"
        hexmask.long.long 0x00 0.--32. 1. " DUM_RD1 ,Dummy read data1."
width 10.
rgroup.long 0x8a0++0x3
    line.long 0x00 "MPSWDRDR2,MMDC PHY SW Dummy Read Data Register 2"
        hexmask.long.long 0x00 0.--32. 1. " DUM_RD2 ,Dummy read data2."
width 10.
rgroup.long 0x8a4++0x3
    line.long 0x00 "MPSWDRDR3,MMDC PHY SW Dummy Read Data Register 3"
        hexmask.long.long 0x00 0.--32. 1. " DUM_RD3 ,Dummy read data3."
width 10.
rgroup.long 0x8a8++0x3
    line.long 0x00 "MPSWDRDR4,MMDC PHY SW Dummy Read Data Register 4"
        hexmask.long.long 0x00 0.--32. 1. " DUM_RD4 ,Dummy read data4."
width 10.
rgroup.long 0x8ac++0x3
    line.long 0x00 "MPSWDRDR5,MMDC PHY SW Dummy Read Data Register 5"
        hexmask.long.long 0x00 0.--32. 1. " DUM_RD5 ,Dummy read data5."
width 10.
rgroup.long 0x8b0++0x3
    line.long 0x00 "MPSWDRDR6,MMDC PHY SW Dummy Read Data Register 6"
        hexmask.long.long 0x00 0.--32. 1. " DUM_RD6 ,Dummy read data6."
width 10.
rgroup.long 0x8b4++0x3
    line.long 0x00 "MPSWDRDR7,MMDC PHY SW Dummy Read Data Register 7"
        hexmask.long.long 0x00 0.--32. 1. " DUM_RD7 ,Dummy read data7."
width 7.
group.long 0x8b8++0x3
    line.long 0x00 "MPMUR0,MMDC PHY Measure Unit Register"
        hexmask.long.word 0x00 0.--10. 1. " MU_BYP_VAL ,Number of delay units for measurement bypass."
        textline "      "
        bitfld.long 0x00 10. " MU_BYP_EN ,Measure unit bypass enable." "0,1"
        textline "      "
        bitfld.long 0x00 11. " FRC_MSR ,Force measuement on delay-lines." "0,1"
        textline "      "
        hexmask.long.word 0x00 16.--26. 1. " MU_UNIT_DEL_NUM ,Number of delay units measured per cycle."
width 9.
group.long 0x8bc++0x3
    line.long 0x00 "MPWRCADL,MMDC Write CA delay-line controller"
        hexmask.long.byte 0x00 0.--2. 1. " WR_CA0_DEL ,CA (Command/Address LPDDR2 bus) bit 0 delay fine tuning."
        textline "        "
        hexmask.long.byte 0x00 2.--4. 1. " WR_CA1_DEL ,CA (Command/Address LPDDR2 bus) bit 1 delay fine tuning."
        textline "        "
        hexmask.long.byte 0x00 4.--6. 1. " WR_CA2_DEL ,CA (Command/Address LPDDR2 bus) bit 2 delay fine tuning."
        textline "        "
        hexmask.long.byte 0x00 6.--8. 1. " WR_CA3_DEL ,CA (Command/Address LPDDR2 bus) bit 3 delay fine tuning."
        textline "        "
        hexmask.long.byte 0x00 8.--10. 1. " WR_CA4_DEL ,CA (Command/Address LPDDR2 bus) bit 4 delay fine tuning."
        textline "        "
        hexmask.long.byte 0x00 10.--12. 1. " WR_CA5_DEL ,CA (Command/Address LPDDR2 bus) bit 5 delay fine tuning."
        textline "        "
        hexmask.long.byte 0x00 12.--14. 1. " WR_CA6_DEL ,CA (Command/Address LPDDR2 bus) bit 6 delay fine tuning."
        textline "        "
        hexmask.long.byte 0x00 14.--16. 1. " WR_CA7_DEL ,CA (Command/Address LPDDR2 bus) bit 7 delay fine tuning."
        textline "        "
        hexmask.long.byte 0x00 16.--18. 1. " WR_CA8_DEL ,CA (Command/Address LPDDR2 bus) bit 8 delay fine tuning."
        textline "        "
        hexmask.long.byte 0x00 18.--20. 1. " WR_CA9_DEL ,CA (Command/Address LPDDR2 bus) bit 9 delay fine tuning."
width 7.
rgroup.long 0x8c0++0x3
    line.long 0x00 "MPDCCR,MMDC Duty Cycle Control Register"
        hexmask.long.byte 0x00 0.--3. 1. " WR_DQS0_FT_DCC ,Write DQS duty cycle fine tuning control of Byte0."
        textline "      "
        hexmask.long.byte 0x00 3.--6. 1. " WR_DQS1_FT_DCC ,Write DQS duty cycle fine tuning control of Byte1."
        textline "      "
        hexmask.long.byte 0x00 6.--9. 1. " WR_DQS2_FT_DCC ,Write DQS duty cycle fine tuning control of Byte1."
        textline "      "
        hexmask.long.byte 0x00 9.--12. 1. " WR_DQS3_FT_DCC ,Write DQS duty cycle fine tuning control of Byte0."
        textline "      "
        hexmask.long.byte 0x00 12.--15. 1. " CK_FT0_DCC ,Primary duty cycle fine tuning control of DDR clock."
        textline "      "
        hexmask.long.byte 0x00 16.--19. 1. " CK_FT1_DCC ,Secondary duty cycle fine tuning control of DDR clock."
        textline "      "
        hexmask.long.byte 0x00 19.--22. 1. " RD_DQS0_FT_DCC ,Read DQS duty cycle fine tuning control of Byte0."
        textline "      "
        hexmask.long.byte 0x00 22.--25. 1. " RD_DQS1_FT_DCC ,Read DQS duty cycle fine tuning control of Byte1."
        textline "      "
        hexmask.long.byte 0x00 25.--28. 1. " RD_DQS2_FT_DCC ,Read DQS duty cycle fine tuning control of Byte2."
        textline "      "
        hexmask.long.byte 0x00 28.--31. 1. " RD_DQS3_FT_DCC ,Read DQS duty cycle fine tuning control of Byte3."


tree.end



;--------------------------------------------------------------------------------
; OCOTP
;--------------------------------------------------------------------------------
tree "OCOTP"
    base ad:0x021bc000

width 5.
group.long 0x0++0x3
    line.long 0x00 "CTRL,OTP Controller Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " ADDR ,OTP write and read access address register."
        textline "    "
        bitfld.long 0x00 8. " BUSY ,OTP controller status bit." "0,1"
        textline "    "
        bitfld.long 0x00 9. " ERROR ,Set by the controller when an access to a locked region(OTP or shadow register) is requested." "0,1"
        textline "    "
        bitfld.long 0x00 10. " RELOAD_SHADOWS ,Set to force re-loading the shadow registers (HW/SW capability and LOCK)." "0,1"
        textline "    "
        bitfld.long 0x00 11. " CRC_TEST ,Set to calculate CRC according to start address and end address in CRC_ADDR register.And compare with CRC fuse word according CRC address in CRC_ADDR register to generate CRC_FAIL flag" "0,1"
        textline "    "
        bitfld.long 0x00 12. " CRC_FAIL ,Set by controller when calculated CRC value is not equal to appointed CRC fuse word" "0,1"
        textline "    "
        hexmask.long.word 0x00 16.--32. 1. " WR_UNLOCK ,Write 0x3E77 to enable OTP write accesses."
width 7.
group.long 0x10++0x3
    line.long 0x00 "TIMING,OTP Controller Timing Register"
        hexmask.long.word 0x00 0.--12. 1. " STROBE_PROG ,This count value specifies the strobe period in one time write OTP."
        textline "      "
        hexmask.long.byte 0x00 12.--16. 1. " RELAX ,This count value specifies the time to add to all default timing parameters other than the Tpgm and Trd."
        textline "      "
        hexmask.long.byte 0x00 16.--22. 1. " STROBE_READ ,This count value specifies the strobe period in one time read OTP."
        textline "      "
        hexmask.long.byte 0x00 22.--28. 1. " WAIT ,This count value specifies time interval between auto read and write access in one time program."
width 5.
group.long 0x20++0x3
    line.long 0x00 "DATA,OTP Controller Write Data Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Used to initiate a write to OTP."
width 10.
group.long 0x30++0x3
    line.long 0x00 "READ_CTRL,OTP Controller Write Data Register"
        bitfld.long 0x00 0. " READ_FUSE ,Used to initiate a read to OTP." "0,1"
width 15.
group.long 0x40++0x3
    line.long 0x00 "READ_FUSE_DATA,OTP Controller Read Data Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,The data read from OTP"
width 10.
group.long 0x50++0x3
    line.long 0x00 "SW_STICKY,Sticky bit Register"
        bitfld.long 0x00 1. " SRK_REVOKE_LOCK ,Shadow register write and OTP write lock for SRK_REVOKE region." "0,1"
        textline "         "
        bitfld.long 0x00 2. " FIELD_RETURN_LOCK ,Shadow register write and OTP write lock for FIELD_RETURN region." "0,1"
width 4.
group.long 0x60++0x3
    line.long 0x00 "SCS,Software Controllable Signals Register"
        bitfld.long 0x00 0. " HAB_JDE ,HAB JTAG Debug Enable." "0,1"
        textline "   "
        hexmask.long.long 0x00 1.--31. 1. " SPARE ,Unallocated read/write bits for implementation specific software use."
        textline "   "
        bitfld.long 0x00 31. " LOCK ,When set, all of the bits in this register are locked and can not be changed through SW programming." "0,1"
width 9.
group.long 0x70++0x3
    line.long 0x00 "CRC_ADDR,OTP Controller CRC test address"
        hexmask.long.byte 0x00 0.--8. 1. " DATA_START_ADDR ,End address of fuse location for CRC calculation"
        textline "        "
        hexmask.long.byte 0x00 8.--16. 1. " DATA_END_ADDR ,Start address of fuse location for CRC calculation"
        textline "        "
        hexmask.long.byte 0x00 16.--19. 1. " CRC_ADDR ,Address of 32-bit CRC result for comparing"
width 10.
group.long 0x80++0x3
    line.long 0x00 "CRC_VALUE,OTP Controller CRC Value Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,The crc32 value based on CRC_ADDR"
width 11.
group.long 0x90++0x3
    line.long 0x00 "UMC_TIMING,OTP Controller Timing Register"
        hexmask.long.word 0x00 0.--12. 1. " STROBE_PROG_INT ,This count value specifies the strobe pulse interval in one time write OTP."
width 8.
group.long 0xa0++0x3
    line.long 0x00 "VERSION,OTP Controller Version Register"
        hexmask.long.word 0x00 0.--16. 1. " STEP ,Fixed read-only value reflecting the stepping of the RTL version."
        textline "       "
        hexmask.long.byte 0x00 16.--24. 1. " MINOR ,Fixed read-only value reflecting the MINOR field of the RTL version."
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " MAJOR ,Fixed read-only value reflecting the MAJOR field of the RTL version."
width 5.
group.long 0x400++0x3
    line.long 0x00 "LOCK,Value of OTP Bank0 Word0 (Lock controls)"
        hexmask.long.byte 0x00 0.--2. 1. " TESTER ,Status of shadow register and OTP write lock for tester region."
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " BOOT_CFG ,Status of shadow register and OTP write lock for boot_cfg region."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " MEM_TRIM ,Status of shadow register and OTP write lock for mem_trim region."
        textline "    "
        bitfld.long 0x00 6. " SJC_RESP ,Status of shadow register read and write, OTP read and write lock for sjc_resp region." "0,1"
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " MAC_ADDR ,Status of shadow register and OTP write lock for mac_addr region."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " GP1 ,Status of shadow register and OTP write lock for gp2 region."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " GP2 ,Status of shadow register and OTP write lock for gp2 region."
        textline "    "
        bitfld.long 0x00 14. " SRK ,Status of shadow register and OTP write lock for srk region." "0,1"
        textline "    "
        bitfld.long 0x00 16. " SW_GP ,Status of shadow register lock for the region contained in the SW_GP registers." "0,1"
        textline "    "
        bitfld.long 0x00 17. " DCP ,Status of shadow register read and write, OTP read and write lock for otpmk region." "0,1"
        textline "    "
        hexmask.long.byte 0x00 18.--20. 1. " ANALOG ,Status of shadow register and OTP write lock for analog region."
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " CRC_GP_LOCK ,Status of shadow register write and read, OTP program and read lock for CRC region."
        textline "    "
        bitfld.long 0x00 22. " MISC_CONF ,Status of shadow register and OTP write lock for misc_conf region." "0,1"
        textline "    "
        bitfld.long 0x00 25. " PIN ,Status of Pin access lock bit." "0,1"
        textline "    "
        hexmask.long.byte 0x00 26.--28. 1. " GP_LO_LOCK ,Status of shadow register and OTP write lock for GP region."
        textline "    "
        hexmask.long.byte 0x00 28.--30. 1. " GP_HI_LOCK ,Status of shadow register and OTP write lock for GP region."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " UNALLOCATED ,Value of un-used portion of LOCK word"
width 5.
group.long 0x410++0x3
    line.long 0x00 "CFG0,Value of OTP Bank0 Word1 (Configuration and Manufacturing Info.)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,This register contains 32 bits of the Unique ID and SJC_CHALLENGE field."
width 5.
group.long 0x420++0x3
    line.long 0x00 "CFG1,Value of OTP Bank0 Word2 (Configuration and Manufacturing Info.)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,This register contains 32 bits of the Unique ID and SJC_CHALLENGE field."
width 5.
group.long 0x430++0x3
    line.long 0x00 "CFG2,Value of OTP Bank0 Word3 (Configuration and Manufacturing Info.)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 0, word 3 (ADDR = 0x03)."
width 5.
group.long 0x440++0x3
    line.long 0x00 "CFG3,Value of OTP Bank0 Word4 (Configuration and Manufacturing Info.)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 0, word 4 (ADDR = 0x04)."
width 5.
group.long 0x450++0x3
    line.long 0x00 "CFG4,Value of OTP Bank0 Word5 (Configuration and Manufacturing Info.)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 0, word 5 (ADDR = 0x05)."
width 5.
group.long 0x460++0x3
    line.long 0x00 "CFG5,Value of OTP Bank0 Word6 (Configuration and Manufacturing Info.)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 0, word 6 (ADDR = 0x06)."
width 5.
group.long 0x470++0x3
    line.long 0x00 "CFG6,Value of OTP Bank0 Word7 (Configuration and Manufacturing Info.)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 0, word 7 (ADDR = 0x07)."
width 5.
group.long 0x480++0x3
    line.long 0x00 "MEM0,Value of OTP Bank1 Word0 (Memory Related Info.)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP bank 1, word 0 (ADDR = 0x08)."
width 5.
group.long 0x490++0x3
    line.long 0x00 "MEM1,Value of OTP Bank1 Word1 (Memory Related Info.)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP bank 1, word 1 (ADDR = 0x09)."
width 5.
group.long 0x4a0++0x3
    line.long 0x00 "MEM2,Value of OTP Bank1 Word2 (Memory Related Info.)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP bank 1, word 2 (ADDR = 0x0A)."
width 5.
group.long 0x4b0++0x3
    line.long 0x00 "MEM3,Value of OTP Bank1 Word3 (Memory Related Info.)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP bank 1, word 3 (ADDR = 0x0B)."
width 5.
group.long 0x4c0++0x3
    line.long 0x00 "MEM4,Value of OTP Bank1 Word4 (Memory Related Info.)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP bank 1, word 4 (ADDR = 0x0C)."
width 5.
group.long 0x4d0++0x3
    line.long 0x00 "ANA0,Value of OTP Bank1 Word5 (Memory Related Info.)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP bank 1, word 5 (ADDR = 0x0D)."
width 5.
group.long 0x4e0++0x3
    line.long 0x00 "ANA1,Value of OTP Bank1 Word6 (General Purpose Customer Defined Info.)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP bank 1, word 6 (ADDR = 0x0E)."
width 5.
group.long 0x4f0++0x3
    line.long 0x00 "ANA2,Value of OTP Bank1 Word7 (General Purpose Customer Defined Info.)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP bank 1, word 7 (ADDR = 0x0F)."
width 5.
group.long 0x500++0x3
    line.long 0x00 "DCP0,Shadow Register for OTP Bank2 Word0 (DCP and CRYPTO Key)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Shadow register for the DCP Key word0 (Copy of OTP Bank 2, word 0 (ADDR = 0x10))."
width 5.
group.long 0x510++0x3
    line.long 0x00 "DCP1,Shadow Register for OTP Bank2 Word1 (DCP and CRYPTO Key)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Shadow register for the DCP Key word1 (Copy of OTP Bank 2, word 1 (ADDR = 0x11))."
width 5.
group.long 0x520++0x3
    line.long 0x00 "DCP2,Shadow Register for OTP Bank2 Word2 (DCP and CRYPTO Key)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Shadow register for the DCP Key word2 (Copy of OTP Bank 2, word 2 (ADDR = 0x12))."
width 5.
group.long 0x530++0x3
    line.long 0x00 "DCP3,Shadow Register for OTP Bank2 Word3 (DCP and CRYPTO Key)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Shadow register for the DCP Key word3 (Copy of OTP Bank 2, word 3 (ADDR = 0x13))."
width 5.
group.long 0x540++0x3
    line.long 0x00 "DCP4,Shadow Register for OTP Bank2 Word4 (DCP Key)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Shadow register for the DCP Key word4 (Copy of OTP Bank 2, word 4 (ADDR = 0x14))."
width 5.
group.long 0x550++0x3
    line.long 0x00 "DCP5,Shadow Register for OTP Bank2 Word5 (DCP Key)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Shadow register for the DCP Key word5 (Copy of OTP Bank 2, word 5 (ADDR = 0x15))."
width 5.
group.long 0x560++0x3
    line.long 0x00 "DCP6,Shadow Register for OTP Bank2 Word6 (DCP Key)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Shadow register for the DCP Key word6 (Copy of OTP Bank 2, word 6 (ADDR = 0x16))."
width 5.
group.long 0x570++0x3
    line.long 0x00 "DCP7,Shadow Register for OTP Bank2 Word7 (DCP Key)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Shadow register for the DCP Key word7 (Copy of OTP Bank 2, word 7 (ADDR = 0x17))."
width 5.
group.long 0x580++0x3
    line.long 0x00 "SRK0,Shadow Register for OTP Bank3 Word0 (SRK Hash)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Shadow register for the hash of the Super Root Key word0 (Copy of OTP Bank 3, word 0 (ADDR = 0x1C))."
width 5.
group.long 0x590++0x3
    line.long 0x00 "SRK1,Shadow Register for OTP Bank3 Word1 (SRK Hash)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Shadow register for the hash of the Super Root Key word1 (Copy of OTP Bank 3, word 1 (ADDR = 0x1D))."
width 5.
group.long 0x5a0++0x3
    line.long 0x00 "SRK2,Shadow Register for OTP Bank3 Word2 (SRK Hash)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Shadow register for the hash of the Super Root Key word2 (Copy of OTP Bank 3, word 2 (ADDR = 0x1E))."
width 5.
group.long 0x5b0++0x3
    line.long 0x00 "SRK3,Shadow Register for OTP Bank3 Word3 (SRK Hash)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Shadow register for the hash of the Super Root Key word3 (Copy of OTP Bank 3, word 3 (ADDR = 0x1F))."
width 5.
group.long 0x5c0++0x3
    line.long 0x00 "SRK4,Shadow Register for OTP Bank3 Word4 (SRK Hash)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Shadow register for the hash of the Super Root Key word4 (Copy of OTP Bank 3, word 4 (ADDR = 0x20))."
width 5.
group.long 0x5d0++0x3
    line.long 0x00 "SRK5,Shadow Register for OTP Bank3 Word5 (SRK Hash)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Shadow register for the hash of the Super Root Key word5 (Copy of OTP Bank 3, word 5 (ADDR = 0x21))."
width 5.
group.long 0x5e0++0x3
    line.long 0x00 "SRK6,Shadow Register for OTP Bank3 Word6 (SRK Hash)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Shadow register for the hash of the Super Root Key word6 (Copy of OTP Bank 3, word 6 (ADDR = 0x22))."
width 5.
group.long 0x5f0++0x3
    line.long 0x00 "SRK7,Shadow Register for OTP Bank3 Word7 (SRK Hash)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Shadow register for the hash of the Super Root Key word7 (Copy of OTP Bank 3, word 7 (ADDR = 0x23))."
width 10.
group.long 0x600++0x3
    line.long 0x00 "SJC_RESP0,Value of OTP Bank4 Word0 (Secure JTAG Response Field)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Shadow register for the SJC_RESP Key word0 (Copy of OTP Bank 4, word 0 (ADDR = 0x20))."
width 10.
group.long 0x610++0x3
    line.long 0x00 "SJC_RESP1,Value of OTP Bank4 Word1 (Secure JTAG Response Field)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Shadow register for the SJC_RESP Key word1 (Copy of OTP Bank 4, word 1 (ADDR = 0x21))."
width 5.
group.long 0x620++0x3
    line.long 0x00 "MAC0,Value of OTP Bank4 Word2 (MAC Address)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 4, word 2 (ADDR = 0x22)."
width 5.
group.long 0x630++0x3
    line.long 0x00 "MAC1,Value of OTP Bank4 Word3 (MAC Address)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 4, word 3 (ADDR = 0x23)."
width 5.
group.long 0x640++0x3
    line.long 0x00 "CRC0,Value of OTP Bank4 Word4 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 4, word 4 (ADDR = 0x24)."
width 5.
group.long 0x650++0x3
    line.long 0x00 "CRC1,Value of OTP Bank4 Word5 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 4, word 5 (ADDR = 0x25)."
width 4.
group.long 0x660++0x3
    line.long 0x00 "GP1,Value of OTP Bank4 Word6 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 4, word 6 (ADDR = 0x26)."
width 4.
group.long 0x670++0x3
    line.long 0x00 "GP2,Value of OTP Bank4 Word7 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 4, word 7 (ADDR = 0x27)."
width 7.
group.long 0x680++0x3
    line.long 0x00 "SW_GP0,Value of OTP Bank5 Word0 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 5, word 0 (ADDR = 0x28)."
width 7.
group.long 0x690++0x3
    line.long 0x00 "SW_GP1,Value of OTP Bank5 Word1 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 5, word 1 (ADDR = 0x29)."
width 7.
group.long 0x6a0++0x3
    line.long 0x00 "SW_GP2,Value of OTP Bank5 Word2 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 5, word 2 (ADDR = 0x2a)."
width 7.
group.long 0x6b0++0x3
    line.long 0x00 "SW_GP3,Value of OTP Bank5 Word3 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 5, word 3 (ADDR = 0x2b)."
width 7.
group.long 0x6c0++0x3
    line.long 0x00 "SW_GP4,Value of OTP Bank5 Word4 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 5, word 4 (ADDR = 0x2c)."
width 10.
group.long 0x6d0++0x3
    line.long 0x00 "MISC_CONF,Value of OTP Bank5 Word5 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 5, word 5 (ADDR = 0x2d)."
width 13.
group.long 0x6e0++0x3
    line.long 0x00 "FIELD_RETURN,Value of OTP Bank5 Word6 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 5, word 6 (ADDR = 0x2e)."
width 11.
group.long 0x6f0++0x3
    line.long 0x00 "SRK_REVOKE,Value of OTP Bank5 Word7 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 5, word 7 (ADDR = 0x2f)."
width 7.
group.long 0x700++0x3
    line.long 0x00 "GP_LO0,Value of OTP Bank6 Word0 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 6, word 0 (ADDR = 0x30)."
width 7.
group.long 0x710++0x3
    line.long 0x00 "GP_LO1,Value of OTP Bank6 Word1 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 6, word 1 (ADDR = 0x31)."
width 7.
group.long 0x720++0x3
    line.long 0x00 "GP_LO2,Value of OTP Bank6 Word2 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 6, word 2 (ADDR = 0x32)."
width 7.
group.long 0x730++0x3
    line.long 0x00 "GP_LO3,Value of OTP Bank6 Word3 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 6, word 3 (ADDR = 0x33)."
width 7.
group.long 0x740++0x3
    line.long 0x00 "GP_LO4,Value of OTP Bank6 Word4 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 6, word 4 (ADDR = 0x34)."
width 7.
group.long 0x750++0x3
    line.long 0x00 "GP_LO5,Value of OTP Bank6 Word5 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 6, word 5 (ADDR = 0x35)."
width 7.
group.long 0x760++0x3
    line.long 0x00 "GP_LO6,Value of OTP Bank6 Word6 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 6, word 6 (ADDR = 0x36)."
width 7.
group.long 0x770++0x3
    line.long 0x00 "GP_LO7,Value of OTP Bank6 Word7 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 6, word 7 (ADDR = 0x37)."
width 7.
group.long 0x780++0x3
    line.long 0x00 "GP_HI0,Value of OTP Bank7 Word0 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 7, word 0 (ADDR = 0x38)."
width 7.
group.long 0x790++0x3
    line.long 0x00 "GP_HI1,Value of OTP Bank7 Word1 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 7, word 1 (ADDR = 0x39)."
width 7.
group.long 0x7a0++0x3
    line.long 0x00 "GP_HI2,Value of OTP Bank7 Word2 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 7, word 2 (ADDR = 0x3a)."
width 7.
group.long 0x7b0++0x3
    line.long 0x00 "GP_HI3,Value of OTP Bank7 Word3 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 7, word 3 (ADDR = 0x3b)."
width 7.
group.long 0x7c0++0x3
    line.long 0x00 "GP_HI4,Value of OTP Bank7 Word4 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 7, word 4 (ADDR = 0x3c)."
width 7.
group.long 0x7d0++0x3
    line.long 0x00 "GP_HI5,Value of OTP Bank7 Word5 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 7, word 5 (ADDR = 0x3d)."
width 7.
group.long 0x7e0++0x3
    line.long 0x00 "GP_HI6,Value of OTP Bank7 Word6 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 7, word 6 (ADDR = 0x3e)."
width 7.
group.long 0x7f0++0x3
    line.long 0x00 "GP_HI7,Value of OTP Bank7 Word7 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 7, word 7 (ADDR = 0x3f)."


tree.end



;--------------------------------------------------------------------------------
; PGC
;--------------------------------------------------------------------------------
tree "PGC"
    base ad:0x020dc000

width 13.
group.long 0x240++0x3
    line.long 0x00 "DISPLAY_CTRL,PGC Control Register"
        bitfld.long 0x00 0. " PCR ,Power Control PCR must not change from power-down request (pdn_req) assertion until the target subsystem is completely powered up." "0,1"
width 15.
group.long 0x244++0x3
    line.long 0x00 "DISPLAY_PUPSCR,Power Up Sequence Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " SW ,After a power-up request (pup_req assertion), the PGC waits a number of clocks equal to the value of SW before asserting switch_b."
        textline "              "
        hexmask.long.byte 0x00 8.--14. 1. " SW2ISO ,After asserting switch_b, the PGC waits a number of clocks equal to the value of SW2ISO before negating isolation."
width 15.
group.long 0x248++0x3
    line.long 0x00 "DISPLAY_PDNSCR,Pull Down Sequence Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " ISO ,After a power-down request (pdn_req assertion), the PGC waits a number of clocks equal to the value of ISO before asserting isolation."
        textline "              "
        hexmask.long.byte 0x00 8.--14. 1. " ISO2SW ,After asserting isolation, the PGC waits a number of clocks equal to the value of ISO2SW before negating switch_b."
width 11.
group.long 0x24c++0x3
    line.long 0x00 "DISPLAY_SR,Power Gating Controller Status Register"
        bitfld.long 0x00 0. " PSR ,Power status." "0,1"
width 9.
group.long 0x260++0x3
    line.long 0x00 "GPU_CTRL,PGC Control Register"
        bitfld.long 0x00 0. " PCR ,Power Control PCR must not change from power-down request (pdn_req) assertion until the target subsystem is completely powered up." "0,1"
width 11.
group.long 0x264++0x3
    line.long 0x00 "GPU_PUPSCR,Power Up Sequence Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " SW ,After a power-up request (pup_req assertion), the PGC waits a number of clocks equal to the value of SW before asserting switch_b."
        textline "          "
        hexmask.long.byte 0x00 8.--14. 1. " SW2ISO ,After asserting switch_b, the PGC waits a number of clocks equal to the value of SW2ISO before negating isolation."
width 11.
group.long 0x268++0x3
    line.long 0x00 "GPU_PDNSCR,Pull Down Sequence Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " ISO ,After a power-down request (pdn_req assertion), the PGC waits a number of clocks equal to the value of ISO before asserting isolation."
        textline "          "
        hexmask.long.byte 0x00 8.--14. 1. " ISO2SW ,After asserting isolation, the PGC waits a number of clocks equal to the value of ISO2SW before negating switch_b."
width 7.
group.long 0x26c++0x3
    line.long 0x00 "GPU_SR,Power Gating Controller Status Register"
        bitfld.long 0x00 0. " PSR ,Power status." "0,1"
width 9.
group.long 0x2a0++0x3
    line.long 0x00 "CPU_CTRL,PGC Control Register"
        bitfld.long 0x00 0. " PCR ,Power Control PCR must not change from power-down request (pdn_req) assertion until the target subsystem is completely powered up." "0,1"
width 11.
group.long 0x2a4++0x3
    line.long 0x00 "CPU_PUPSCR,Power Up Sequence Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " SW ,After a power-up request (pup_req assertion), the PGC waits a number of clocks equal to the value of SW before asserting switch_b."
        textline "          "
        hexmask.long.byte 0x00 8.--14. 1. " SW2ISO ,After asserting switch_b, the PGC waits a number of clocks equal to the value of SW2ISO before negating isolation."
width 11.
group.long 0x2a8++0x3
    line.long 0x00 "CPU_PDNSCR,Pull Down Sequence Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " ISO ,After a power-down request (pdn_req assertion), the PGC waits a number of clocks equal to the value of ISO before asserting isolation."
        textline "          "
        hexmask.long.byte 0x00 8.--14. 1. " ISO2SW ,After asserting isolation, the PGC waits a number of clocks equal to the value of ISO2SW before negating switch_b."
width 7.
group.long 0x2ac++0x3
    line.long 0x00 "CPU_SR,Power Gating Controller Status Register"
        bitfld.long 0x00 0. " PSR ,Power status." "0,1"


tree.end



;--------------------------------------------------------------------------------
; PMU
;--------------------------------------------------------------------------------
tree "PMU"
    base ad:0x020c8000

width 8.
group.long 0x110++0x3
    line.long 0x00 "REG_1P1,Regulator 1P1 Register"
        bitfld.long 0x00 0. " ENABLE_LINREG ,Control bit to enable the regulator output." "0,1"
        textline "       "
        bitfld.long 0x00 1. " ENABLE_BO ,Control bit to enable the brown-out circuitry in the regulator." "0,1"
        textline "       "
        bitfld.long 0x00 2. " ENABLE_ILIMIT ,Control bit to enable the current-limit circuitry in the regulator." "0,1"
        textline "       "
        bitfld.long 0x00 3. " ENABLE_PULLDOWN ,Control bit to enable the pull-down circuitry in the regulator" "0,1"
        textline "       "
        hexmask.long.byte 0x00 4.--7. 1. " BO_OFFSET ,Control bits to adjust the regulator brown-out offset voltage in 25mV steps."
        textline "       "
        hexmask.long.byte 0x00 8.--13. 1. " OUTPUT_TRG ,Control bits to adjust the regulator output voltage."
        textline "       "
        bitfld.long 0x00 16. " BO_VDD1P1 ,Status bit that signals when a brown-out is detected on the regulator output." "0,1"
        textline "       "
        bitfld.long 0x00 17. " OK_VDD1P1 ,Status bit that signals when the regulator output is ok." "0,1"
width 8.
group.long 0x120++0x3
    line.long 0x00 "REG_3P0,Regulator 3P0 Register"
        bitfld.long 0x00 0. " ENABLE_LINREG ,Control bit to enable the regulator output to be set by the programmed target voltage setting and internal bandgap reference." "0,1"
        textline "       "
        bitfld.long 0x00 1. " ENABLE_BO ,Control bit to enable the brown-out circuitry in the regulator." "0,1"
        textline "       "
        bitfld.long 0x00 2. " ENABLE_ILIMIT ,Control bit to enable the current-limit circuitry in the regulator." "0,1"
        textline "       "
        hexmask.long.byte 0x00 4.--7. 1. " BO_OFFSET ,Control bits to adjust the regulator brown-out offset voltage in 25mV steps."
        textline "       "
        bitfld.long 0x00 7. " VBUS_SEL ,Select input voltage source for LDO_3P0 from either USB_OTG1_VBUS or USB_OTG2_VBUS." "0,1"
        textline "       "
        hexmask.long.byte 0x00 8.--13. 1. " OUTPUT_TRG ,Control bits to adjust the regulator output voltage."
        textline "       "
        bitfld.long 0x00 16. " BO_VDD3P0 ,Status bit that signals when a brown-out is detected on the regulator output." "0,1"
        textline "       "
        bitfld.long 0x00 17. " OK_VDD3P0 ,Status bit that signals when the regulator output is ok." "0,1"
width 8.
group.long 0x130++0x3
    line.long 0x00 "REG_2P5,Regulator 2P5 Register"
        bitfld.long 0x00 0. " ENABLE_LINREG ,Control bit to enable the regulator output." "0,1"
        textline "       "
        bitfld.long 0x00 1. " ENABLE_BO ,Control bit to enable the brown-out circuitry in the regulator." "0,1"
        textline "       "
        bitfld.long 0x00 2. " ENABLE_ILIMIT ,Control bit to enable the current-limit circuitry in the regulator." "0,1"
        textline "       "
        bitfld.long 0x00 3. " ENABLE_PULLDOWN ,Control bit to enable the pull-down circuitry in the regulator" "0,1"
        textline "       "
        hexmask.long.byte 0x00 4.--7. 1. " BO_OFFSET ,Control bits to adjust the regulator brown-out offset voltage in 25mV steps."
        textline "       "
        hexmask.long.byte 0x00 8.--13. 1. " OUTPUT_TRG ,Control bits to adjust the regulator output voltage."
        textline "       "
        bitfld.long 0x00 16. " BO_VDD2P5 ,Status bit that signals when a brown-out is detected on the regulator output." "0,1"
        textline "       "
        bitfld.long 0x00 17. " OK_VDD2P5 ,Status bit that signals when the regulator output is ok." "0,1"
        textline "       "
        bitfld.long 0x00 18. " ENABLE_WEAK_LINREG ,Enables the weak 2p5 regulator." "0,1"
width 9.
group.long 0x140++0x3
    line.long 0x00 "REG_CORE,Digital Regulator Core Register"
        hexmask.long.byte 0x00 0.--5. 1. " REG0_TARG ,This bitfield defines the target voltage for the arm core power domain."
        textline "        "
        hexmask.long.byte 0x00 5.--9. 1. " REG0_ADJ ,This bitfield defines the adjustment bits to calibrate the target value of REG1 (ARM_CORE)."
        textline "        "
        hexmask.long.byte 0x00 9.--14. 1. " REG1_TARG ,This bitfield defines the target voltage for the VPU/GPU power domain."
        textline "        "
        hexmask.long.byte 0x00 14.--18. 1. " REG1_ADJ ,This bitfield defines the adjustment bits to calibrate the target value of REG1 (REG_PU)."
        textline "        "
        hexmask.long.byte 0x00 18.--23. 1. " REG2_TARG ,This bitfield defines the target voltage for the SOC power domain."
        textline "        "
        hexmask.long.byte 0x00 23.--27. 1. " REG2_ADJ ,This bitfield defines the adjustment bits to calibrate the target value of REG2 (REG_SOC)."
        textline "        "
        bitfld.long 0x00 29. " FET_ODRIVE ,If set, increases the gate drive on power gating fets to reduce leakage in the off state." "0,1"
width 6.
group.long 0x150++0x3
    line.long 0x00 "MISC0,Miscellaneous Register 0"
        bitfld.long 0x00 0. " REFTOP_PWD ,Control bit to power-down the analog bandgap reference circuitry." "0,1"
        textline "     "
        bitfld.long 0x00 3. " REFTOP_SELFBIASOFF ,Control bit to disable the self-bias circuit in the analog bandgap." "0,1"
        textline "     "
        hexmask.long.byte 0x00 4.--7. 1. " REFTOP_VBGADJ ,"
        textline "     "
        bitfld.long 0x00 7. " REFTOP_VBGUP ,Status bit which signals that the analog bandgap voltage is up and stable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 11.--13. 1. " STOP_MODE_CONFIG ,Configure the analog behavior in stop mode."
        textline "     "
        bitfld.long 0x00 13. " DISCON_HIGH_SNVS ,This bit forces the short between VDDHIGH_IN and VSNVS_IN to open when asserted." "0,1"
        textline "     "
        hexmask.long.byte 0x00 14.--16. 1. " OSC_I ,This bit field determines the bias current in the 24MHz oscillator."
        textline "     "
        bitfld.long 0x00 16. " OSC_XTALOK ,Status bit which signals that the output of the 24MHz crystal oscillator is stable." "0,1"
        textline "     "
        bitfld.long 0x00 17. " OSC_XTALOK_EN ,This bit enables the detector which signals when the 24MHz crystal oscillator is stable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 18.--20. 1. " WBCP_VPW_THRESH ,This signal alters the voltage that the pwell is charged pumped to."
        textline "     "
        bitfld.long 0x00 25. " CLKGATE_CTRL ,This bit allows disabling the clock gate (always un-gated) for the xtal 24MHz clock that clocks the digital logic in the analog block." "0,1"
        textline "     "
        hexmask.long.byte 0x00 26.--29. 1. " CLKGATE_DELAY ,This field specifies the delay between powering up the XTAL 24MHz clock and release the clock to the digital logic inside the analog block."
width 6.
group.long 0x160++0x3
    line.long 0x00 "MISC1,Miscellaneous Register 1"
        hexmask.long.byte 0x00 0.--5. 1. " LVDS1_CLK_SEL ,This field selects the clk to be routed to anaclk2/2b."
        textline "     "
        bitfld.long 0x00 10. " LVDSCLK1_OBEN ,This enables the lvds output buffer for anaclk1/1b." "0,1"
        textline "     "
        bitfld.long 0x00 12. " LVDSCLK1_IBEN ,This enables the lvds input buffer for anaclk1/1b." "0,1"
        textline "     "
        bitfld.long 0x00 29. " IRQ_TEMPSENSE ,This status bit is set to one when when the temperature sensor interrupt asserts." "0,1"
        textline "     "
        bitfld.long 0x00 30. " IRQ_ANA_BO ,This status bit is set to one when when any of the analog regulator brownout interrupts assert." "0,1"
        textline "     "
        bitfld.long 0x00 31. " IRQ_DIG_BO ,This status bit is set to one when when any of the digital regulator brownout interrupts assert." "0,1"
width 6.
group.long 0x170++0x3
    line.long 0x00 "MISC2,Miscellaneous Register 2"
        hexmask.long.byte 0x00 0.--3. 1. " REG0_BO_OFFSET ,This bit field defines the brown out voltage offset for the CORE power domain."
        textline "     "
        bitfld.long 0x00 3. " REG0_BO_STATUS ,Reg0 brownout status bit." "0,1"
        textline "     "
        bitfld.long 0x00 5. " REG0_ENABLE_BO ,Enables the brownout detection." "0,1"
        textline "     "
        bitfld.long 0x00 7. " PLL3_DISABLE ,Default value of ""0""." "0,1"
        textline "     "
        hexmask.long.byte 0x00 8.--11. 1. " REG1_BO_OFFSET ,This bit field defines the brown out voltage offset for the xPU power domain."
        textline "     "
        bitfld.long 0x00 11. " REG1_BO_STATUS ,Reg1 brownout status bit." "0,1"
        textline "     "
        bitfld.long 0x00 13. " REG1_ENABLE_BO ,Enables the brownout detection." "0,1"
        textline "     "
        bitfld.long 0x00 15. " AUDIO_DIV_LSB ,LSB of Audio Pll post divider two bit control: 0x0=div-by-1(default), 0x1=div-by-2, 0x2-div-by-1, 0x3=div-by-4." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--19. 1. " REG2_BO_OFFSET ,This bit field defines the brown out voltage offset for the xPU power domain."
        textline "     "
        bitfld.long 0x00 19. " REG2_BO_STATUS ,Reg2 brownout status bit." "0,1"
        textline "     "
        bitfld.long 0x00 21. " REG2_ENABLE_BO ,Enables the brownout detection." "0,1"
        textline "     "
        bitfld.long 0x00 22. " REG2_OK ,Signals that the voltage is above the brownout level for the SOC supply." "0,1"
        textline "     "
        bitfld.long 0x00 23. " AUDIO_DIV_MSB ,MSB of 2 bit post-divider field for the Audio PLL: 0x0=div-by-1(default), 0x1=div-by-2, 0x2=div-by-1, 0x3=div-by-4." "0,1"
        textline "     "
        hexmask.long.byte 0x00 24.--26. 1. " REG0_STEP_TIME ,Number of clock periods (24MHz clock)."
        textline "     "
        hexmask.long.byte 0x00 26.--28. 1. " REG1_STEP_TIME ,Number of clock periods (24MHz clock)."
        textline "     "
        hexmask.long.byte 0x00 28.--30. 1. " REG2_STEP_TIME ,Number of clock periods (24MHz clock)."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " VIDEO_DIV ,Post-divider for video PLL."
width 12.
group.long 0x260++0x3
    line.long 0x00 "LOWPWR_CTRL,Low Power Control Register"
        bitfld.long 0x00 0. " RC_OSC_EN ,RC Osc." "0,1"
        textline "           "
        hexmask.long.byte 0x00 1.--4. 1. " RC_OSC_PROG ,RC osc."
        textline "           "
        bitfld.long 0x00 4. " OSC_SEL ,Select the source for the 24MHz clock." "0,1"
        textline "           "
        bitfld.long 0x00 5. " LPBG_SEL ,Bandgap select." "0,1"
        textline "           "
        bitfld.long 0x00 6. " LPBG_TEST ,Low power bandgap test bit." "0,1"
        textline "           "
        bitfld.long 0x00 7. " REFTOP_IBIAS_OFF ,Low power reftop ibias disable." "0,1"
        textline "           "
        bitfld.long 0x00 8. " L1_PWRGATE ,L1 power gate control." "0,1"
        textline "           "
        bitfld.long 0x00 9. " L2_PWRGATE ,L2 power gate control." "0,1"
        textline "           "
        bitfld.long 0x00 10. " CPU_PWRGATE ,CPU power gate control." "0,1"
        textline "           "
        bitfld.long 0x00 11. " DISPLAY_PWRGATE ,Display logic power gate control." "0,1"
        textline "           "
        bitfld.long 0x00 12. " RWB_EN ,Reverse well bias enable control." "0,1"
        textline "           "
        bitfld.long 0x00 13. " RCOSC_CG_OVERRIDE ,For debug purposes only." "0,1"
        textline "           "
        hexmask.long.byte 0x00 14.--16. 1. " XTALOSC_PWRUP_DELAY ,Specifies the time delay between when the 24MHz xtal is powered up until it is stable and ready to use."
        textline "           "
        bitfld.long 0x00 16. " XTALOSC_PWRUP_STAT ,Status of the 24MHz xtal oscillator." "0,1"


tree.end



;--------------------------------------------------------------------------------
; PWM
;--------------------------------------------------------------------------------
tree.open "PWM"
    tree "PWM1"
        base ad:0x02080000

width 6.
group.long 0x0++0x3
    line.long 0x00 "PWMCR,PWM Control Register"
        bitfld.long 0x00 0. " EN ,PWM Enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 1.--3. 1. " REPEAT ,Sample Repeat."
        textline "     "
        bitfld.long 0x00 3. " SWR ,Software Reset." "0,1"
        textline "     "
        hexmask.long.word 0x00 4.--16. 1. " PRESCALER ,Counter Clock Prescaler Value."
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " CLKSRC ,Select Clock Source."
        textline "     "
        hexmask.long.byte 0x00 18.--20. 1. " POUTC ,PWM Output Configuration."
        textline "     "
        bitfld.long 0x00 20. " HCTR ,Half-word Data Swap Control." "0,1"
        textline "     "
        bitfld.long 0x00 21. " BCTR ,Byte Data Swap Control." "0,1"
        textline "     "
        bitfld.long 0x00 22. " DBGEN ,Debug Mode Enable." "0,1"
        textline "     "
        bitfld.long 0x00 23. " WAITEN ,Wait Mode Enable." "0,1"
        textline "     "
        bitfld.long 0x00 24. " DOZEN ,Doze Mode Enable." "0,1"
        textline "     "
        bitfld.long 0x00 25. " STOPEN ,Stop Mode Enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 26.--28. 1. " FWM ,FIFO Water Mark."
width 6.
group.long 0x4++0x3
    line.long 0x00 "PWMSR,PWM Status Register"
        hexmask.long.byte 0x00 0.--3. 1. " FIFOAV ,FIFO Available."
        textline "     "
        bitfld.long 0x00 3. " FE ,FIFO Empty Status Bit." "0,1"
        textline "     "
        bitfld.long 0x00 4. " ROV ,Roll-over Status." "0,1"
        textline "     "
        bitfld.long 0x00 5. " CMP ,Compare Status." "0,1"
        textline "     "
        bitfld.long 0x00 6. " FWE ,FIFO Write Error Status." "0,1"
width 6.
group.long 0x8++0x3
    line.long 0x00 "PWMIR,PWM Interrupt Register"
        bitfld.long 0x00 0. " FIE ,FIFO Empty Interrupt Enable." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RIE ,Roll-over Interrupt Enable." "0,1"
        textline "     "
        bitfld.long 0x00 2. " CIE ,Compare Interrupt Enable." "0,1"
width 7.
group.long 0xc++0x3
    line.long 0x00 "PWMSAR,PWM Sample Register"
        hexmask.long.word 0x00 0.--16. 1. " SAMPLE ,Sample Value."
width 6.
group.long 0x10++0x3
    line.long 0x00 "PWMPR,PWM Period Register"
        hexmask.long.word 0x00 0.--16. 1. " PERIOD ,Period Value."
width 7.
rgroup.long 0x14++0x3
    line.long 0x00 "PWMCNR,PWM Counter Register"
        hexmask.long.word 0x00 0.--16. 1. " COUNT ,Counter Value."


    tree.end
    tree "PWM2"
        base ad:0x02084000

width 6.
group.long 0x0++0x3
    line.long 0x00 "PWMCR,PWM Control Register"
        bitfld.long 0x00 0. " EN ,PWM Enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 1.--3. 1. " REPEAT ,Sample Repeat."
        textline "     "
        bitfld.long 0x00 3. " SWR ,Software Reset." "0,1"
        textline "     "
        hexmask.long.word 0x00 4.--16. 1. " PRESCALER ,Counter Clock Prescaler Value."
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " CLKSRC ,Select Clock Source."
        textline "     "
        hexmask.long.byte 0x00 18.--20. 1. " POUTC ,PWM Output Configuration."
        textline "     "
        bitfld.long 0x00 20. " HCTR ,Half-word Data Swap Control." "0,1"
        textline "     "
        bitfld.long 0x00 21. " BCTR ,Byte Data Swap Control." "0,1"
        textline "     "
        bitfld.long 0x00 22. " DBGEN ,Debug Mode Enable." "0,1"
        textline "     "
        bitfld.long 0x00 23. " WAITEN ,Wait Mode Enable." "0,1"
        textline "     "
        bitfld.long 0x00 24. " DOZEN ,Doze Mode Enable." "0,1"
        textline "     "
        bitfld.long 0x00 25. " STOPEN ,Stop Mode Enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 26.--28. 1. " FWM ,FIFO Water Mark."
width 6.
group.long 0x4++0x3
    line.long 0x00 "PWMSR,PWM Status Register"
        hexmask.long.byte 0x00 0.--3. 1. " FIFOAV ,FIFO Available."
        textline "     "
        bitfld.long 0x00 3. " FE ,FIFO Empty Status Bit." "0,1"
        textline "     "
        bitfld.long 0x00 4. " ROV ,Roll-over Status." "0,1"
        textline "     "
        bitfld.long 0x00 5. " CMP ,Compare Status." "0,1"
        textline "     "
        bitfld.long 0x00 6. " FWE ,FIFO Write Error Status." "0,1"
width 6.
group.long 0x8++0x3
    line.long 0x00 "PWMIR,PWM Interrupt Register"
        bitfld.long 0x00 0. " FIE ,FIFO Empty Interrupt Enable." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RIE ,Roll-over Interrupt Enable." "0,1"
        textline "     "
        bitfld.long 0x00 2. " CIE ,Compare Interrupt Enable." "0,1"
width 7.
group.long 0xc++0x3
    line.long 0x00 "PWMSAR,PWM Sample Register"
        hexmask.long.word 0x00 0.--16. 1. " SAMPLE ,Sample Value."
width 6.
group.long 0x10++0x3
    line.long 0x00 "PWMPR,PWM Period Register"
        hexmask.long.word 0x00 0.--16. 1. " PERIOD ,Period Value."
width 7.
rgroup.long 0x14++0x3
    line.long 0x00 "PWMCNR,PWM Counter Register"
        hexmask.long.word 0x00 0.--16. 1. " COUNT ,Counter Value."


    tree.end
    tree "PWM3"
        base ad:0x02088000

width 6.
group.long 0x0++0x3
    line.long 0x00 "PWMCR,PWM Control Register"
        bitfld.long 0x00 0. " EN ,PWM Enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 1.--3. 1. " REPEAT ,Sample Repeat."
        textline "     "
        bitfld.long 0x00 3. " SWR ,Software Reset." "0,1"
        textline "     "
        hexmask.long.word 0x00 4.--16. 1. " PRESCALER ,Counter Clock Prescaler Value."
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " CLKSRC ,Select Clock Source."
        textline "     "
        hexmask.long.byte 0x00 18.--20. 1. " POUTC ,PWM Output Configuration."
        textline "     "
        bitfld.long 0x00 20. " HCTR ,Half-word Data Swap Control." "0,1"
        textline "     "
        bitfld.long 0x00 21. " BCTR ,Byte Data Swap Control." "0,1"
        textline "     "
        bitfld.long 0x00 22. " DBGEN ,Debug Mode Enable." "0,1"
        textline "     "
        bitfld.long 0x00 23. " WAITEN ,Wait Mode Enable." "0,1"
        textline "     "
        bitfld.long 0x00 24. " DOZEN ,Doze Mode Enable." "0,1"
        textline "     "
        bitfld.long 0x00 25. " STOPEN ,Stop Mode Enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 26.--28. 1. " FWM ,FIFO Water Mark."
width 6.
group.long 0x4++0x3
    line.long 0x00 "PWMSR,PWM Status Register"
        hexmask.long.byte 0x00 0.--3. 1. " FIFOAV ,FIFO Available."
        textline "     "
        bitfld.long 0x00 3. " FE ,FIFO Empty Status Bit." "0,1"
        textline "     "
        bitfld.long 0x00 4. " ROV ,Roll-over Status." "0,1"
        textline "     "
        bitfld.long 0x00 5. " CMP ,Compare Status." "0,1"
        textline "     "
        bitfld.long 0x00 6. " FWE ,FIFO Write Error Status." "0,1"
width 6.
group.long 0x8++0x3
    line.long 0x00 "PWMIR,PWM Interrupt Register"
        bitfld.long 0x00 0. " FIE ,FIFO Empty Interrupt Enable." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RIE ,Roll-over Interrupt Enable." "0,1"
        textline "     "
        bitfld.long 0x00 2. " CIE ,Compare Interrupt Enable." "0,1"
width 7.
group.long 0xc++0x3
    line.long 0x00 "PWMSAR,PWM Sample Register"
        hexmask.long.word 0x00 0.--16. 1. " SAMPLE ,Sample Value."
width 6.
group.long 0x10++0x3
    line.long 0x00 "PWMPR,PWM Period Register"
        hexmask.long.word 0x00 0.--16. 1. " PERIOD ,Period Value."
width 7.
rgroup.long 0x14++0x3
    line.long 0x00 "PWMCNR,PWM Counter Register"
        hexmask.long.word 0x00 0.--16. 1. " COUNT ,Counter Value."


    tree.end
    tree "PWM4"
        base ad:0x0208c000

width 6.
group.long 0x0++0x3
    line.long 0x00 "PWMCR,PWM Control Register"
        bitfld.long 0x00 0. " EN ,PWM Enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 1.--3. 1. " REPEAT ,Sample Repeat."
        textline "     "
        bitfld.long 0x00 3. " SWR ,Software Reset." "0,1"
        textline "     "
        hexmask.long.word 0x00 4.--16. 1. " PRESCALER ,Counter Clock Prescaler Value."
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " CLKSRC ,Select Clock Source."
        textline "     "
        hexmask.long.byte 0x00 18.--20. 1. " POUTC ,PWM Output Configuration."
        textline "     "
        bitfld.long 0x00 20. " HCTR ,Half-word Data Swap Control." "0,1"
        textline "     "
        bitfld.long 0x00 21. " BCTR ,Byte Data Swap Control." "0,1"
        textline "     "
        bitfld.long 0x00 22. " DBGEN ,Debug Mode Enable." "0,1"
        textline "     "
        bitfld.long 0x00 23. " WAITEN ,Wait Mode Enable." "0,1"
        textline "     "
        bitfld.long 0x00 24. " DOZEN ,Doze Mode Enable." "0,1"
        textline "     "
        bitfld.long 0x00 25. " STOPEN ,Stop Mode Enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 26.--28. 1. " FWM ,FIFO Water Mark."
width 6.
group.long 0x4++0x3
    line.long 0x00 "PWMSR,PWM Status Register"
        hexmask.long.byte 0x00 0.--3. 1. " FIFOAV ,FIFO Available."
        textline "     "
        bitfld.long 0x00 3. " FE ,FIFO Empty Status Bit." "0,1"
        textline "     "
        bitfld.long 0x00 4. " ROV ,Roll-over Status." "0,1"
        textline "     "
        bitfld.long 0x00 5. " CMP ,Compare Status." "0,1"
        textline "     "
        bitfld.long 0x00 6. " FWE ,FIFO Write Error Status." "0,1"
width 6.
group.long 0x8++0x3
    line.long 0x00 "PWMIR,PWM Interrupt Register"
        bitfld.long 0x00 0. " FIE ,FIFO Empty Interrupt Enable." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RIE ,Roll-over Interrupt Enable." "0,1"
        textline "     "
        bitfld.long 0x00 2. " CIE ,Compare Interrupt Enable." "0,1"
width 7.
group.long 0xc++0x3
    line.long 0x00 "PWMSAR,PWM Sample Register"
        hexmask.long.word 0x00 0.--16. 1. " SAMPLE ,Sample Value."
width 6.
group.long 0x10++0x3
    line.long 0x00 "PWMPR,PWM Period Register"
        hexmask.long.word 0x00 0.--16. 1. " PERIOD ,Period Value."
width 7.
rgroup.long 0x14++0x3
    line.long 0x00 "PWMCNR,PWM Counter Register"
        hexmask.long.word 0x00 0.--16. 1. " COUNT ,Counter Value."


    tree.end

tree.end



;--------------------------------------------------------------------------------
; PXP
;--------------------------------------------------------------------------------
tree "PXP"
    base ad:0x020f0000

width 5.
group.long 0x0++0x3
    line.long 0x00 "CTRL,Control Register 0"
        bitfld.long 0x00 0. " ENABLE ,Enables PXP operation with specified parameters." "0,1"
        textline "    "
        bitfld.long 0x00 1. " IRQ_ENABLE ,Interrupt enable." "0,1"
        textline "    "
        bitfld.long 0x00 2. " NEXT_IRQ_ENABLE ,Next command interrupt enable." "0,1"
        textline "    "
        bitfld.long 0x00 3. " LUT_DMA_IRQ_ENABLE ,LUT DMA interrupt enable." "0,1"
        textline "    "
        bitfld.long 0x00 4. " ENABLE_LCD_HANDSHAKE ,Enable handshake with LCD controller." "0,1"
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " ROTATE ,Indicates the clockwise rotation to be applied at the output buffer."
        textline "    "
        bitfld.long 0x00 10. " HFLIP ,Indicates that the output buffer should be flipped horizontally (effect applied before rotation)." "0,1"
        textline "    "
        bitfld.long 0x00 11. " VFLIP ,Indicates that the output buffer should be flipped vertically (effect applied before rotation)." "0,1"
        textline "    "
        bitfld.long 0x00 22. " ROT_POS ,This bit controls where rotation will occur in the PXP datapath." "0,1"
        textline "    "
        bitfld.long 0x00 23. " BLOCK_SIZE ,Select the block size to process." "0,1"
        textline "    "
        bitfld.long 0x00 28. " EN_REPEAT ,Enable the PXP to run continuously." "0,1"
        textline "    "
        bitfld.long 0x00 30. " CLKGATE ,This bit must be set to zero for normal operation." "0,1"
        textline "    "
        bitfld.long 0x00 31. " SFTRST ,Set this bit to zero to enable normal PXP operation." "0,1"
width 5.
group.long 0x10++0x3
    line.long 0x00 "STAT,Status Register"
        bitfld.long 0x00 0. " IRQ ,Indicates current PXP interrupt status." "0,1"
        textline "    "
        bitfld.long 0x00 1. " AXI_WRITE_ERROR ,Indicates PXP encountered an AXI write error and processing has been terminated." "0,1"
        textline "    "
        bitfld.long 0x00 2. " AXI_READ_ERROR ,Indicates PXP encountered an AXI read error and processing has been terminated." "0,1"
        textline "    "
        bitfld.long 0x00 3. " NEXT_IRQ ,Indicates that a command issued with the ""Next Command"" functionality has been issued and that a new command may be initiated with a write to the PXP_NEXT register." "0,1"
        textline "    "
        hexmask.long.byte 0x00 4.--8. 1. " AXI_ERROR_ID ,Indicates the AXI ID of the failing bus operation."
        textline "    "
        bitfld.long 0x00 8. " LUT_DMA_LOAD_DONE_IRQ ,Indicates that the LUT DMA transfer has completed." "0,1"
        textline "    "
        hexmask.long.byte 0x00 16.--24. 1. " BLOCKY ,Indicates the X coordinate of the block currently being rendered."
        textline "    "
        hexmask.long.byte 0x00 24.--32. 1. " BLOCKX ,Indicates the X coordinate of the block currently being rendered."
width 9.
group.long 0x20++0x3
    line.long 0x00 "OUT_CTRL,Output Buffer Control Register"
        hexmask.long.byte 0x00 0.--5. 1. " FORMAT ,Output framebuffer format."
        textline "        "
        hexmask.long.byte 0x00 8.--10. 1. " INTERLACED_OUTPUT ,Determines how the PXP writes it's output data."
        textline "        "
        bitfld.long 0x00 23. " ALPHA_OUTPUT ,Indicates that alpha component in output buffer pixels should be overwritten by PXP_OUT_CTRL[ALPHA]." "0,1"
        textline "        "
        hexmask.long.byte 0x00 24.--32. 1. " ALPHA ,When generating an output buffer with an alpha component, the value in this field will be used when enabled to override the alpha passed through the pixel data pipeline."
width 8.
group.long 0x30++0x3
    line.long 0x00 "OUT_BUF,Output Frame Buffer Pointer"
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,Current address pointer for the output frame buffer."
width 9.
group.long 0x40++0x3
    line.long 0x00 "OUT_BUF2,Output Frame Buffer Pointer #2"
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,Current address pointer for the output frame buffer."
width 10.
group.long 0x50++0x3
    line.long 0x00 "OUT_PITCH,Output Buffer Pitch"
        hexmask.long.word 0x00 0.--16. 1. " PITCH ,Indicates the number of bytes in memory between two vertically adjacent pixels."
width 8.
group.long 0x60++0x3
    line.long 0x00 "OUT_LRC,Output Surface Lower Right Coordinate"
        hexmask.long.word 0x00 0.--14. 1. " Y ,Indicates the number of vertical PIXELS in the output surface (non-rotated)."
        textline "       "
        hexmask.long.word 0x00 16.--30. 1. " X ,Indicates number of horizontal PIXELS in the output surface (non-rotated)."
width 11.
group.long 0x70++0x3
    line.long 0x00 "OUT_PS_ULC,Processed Surface Upper Left Coordinate"
        hexmask.long.word 0x00 0.--14. 1. " Y ,This field indicates the upper left Y-coordinate (in pixels) of the processed surface in the output buffer."
        textline "          "
        hexmask.long.word 0x00 16.--30. 1. " X ,This field indicates the upper left X-coordinate (in pixels) of the processed surface (PS) in the output buffer."
width 11.
group.long 0x80++0x3
    line.long 0x00 "OUT_PS_LRC,Processed Surface Lower Right Coordinate"
        hexmask.long.word 0x00 0.--14. 1. " Y ,This field indicates the lower right Y-coordinate (in pixels) of the processed surface in the output frame buffer."
        textline "          "
        hexmask.long.word 0x00 16.--30. 1. " X ,This field indicates the lower right X-coordinate (in pixels) of the processed surface (PS) in the output frame buffer."
width 11.
group.long 0x90++0x3
    line.long 0x00 "OUT_AS_ULC,Alpha Surface Upper Left Coordinate"
        hexmask.long.word 0x00 0.--14. 1. " Y ,This field indicates the upper left Y-coordinate (in pixels) of the alpha surface in the output frame buffer."
        textline "          "
        hexmask.long.word 0x00 16.--30. 1. " X ,This field indicates the upper left X-coordinate (in pixels) of the alpha surface (AS) in the output frame buffer."
width 11.
group.long 0xa0++0x3
    line.long 0x00 "OUT_AS_LRC,Alpha Surface Lower Right Coordinate"
        hexmask.long.word 0x00 0.--14. 1. " Y ,This field indicates the lower right Y-coordinate (in pixels) of the alpha surface in the output frame buffer."
        textline "          "
        hexmask.long.word 0x00 16.--30. 1. " X ,This field indicates the lower right X-coordinate (in pixels) of the alpha surface (AS) in the output frame buffer."
width 8.
group.long 0xb0++0x3
    line.long 0x00 "PS_CTRL,Processed Surface (PS) Control Register"
        hexmask.long.byte 0x00 0.--5. 1. " FORMAT ,PS buffer format."
        textline "       "
        bitfld.long 0x00 5. " WB_SWAP ,Swap bytes in words." "0,1"
        textline "       "
        hexmask.long.byte 0x00 8.--10. 1. " DECY ,Verticle pre decimation filter control."
        textline "       "
        hexmask.long.byte 0x00 10.--12. 1. " DECX ,Horizontal pre decimation filter control."
width 7.
group.long 0xc0++0x3
    line.long 0x00 "PS_BUF,PS Input Buffer Address"
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,Address pointer for the PS RGB or Y (luma) input buffer."
width 8.
group.long 0xd0++0x3
    line.long 0x00 "PS_UBUF,PS U/Cb or 2 Plane UV Input Buffer Address"
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,Address pointer for the PS U/Cb or 2 plane UV Chroma input buffer."
width 8.
group.long 0xe0++0x3
    line.long 0x00 "PS_VBUF,PS V/Cr Input Buffer Address"
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,Address pointer for the PS V/Cr Chroma input buffer."
width 9.
group.long 0xf0++0x3
    line.long 0x00 "PS_PITCH,Processed Surface Pitch"
        hexmask.long.word 0x00 0.--16. 1. " PITCH ,Indicates the number of bytes in memory between two vertically adjacent pixels."
width 14.
group.long 0x100++0x3
    line.long 0x00 "PS_BACKGROUND,PS Background Color"
        hexmask.long.long 0x00 0.--24. 1. " COLOR ,Background color (in 24bpp format) for any pixels not within the buffer range specified by the PS ULC/LRC."
width 9.
group.long 0x110++0x3
    line.long 0x00 "PS_SCALE,PS Scale Factor Register"
        hexmask.long.word 0x00 0.--15. 1. " XSCALE ,This is a two bit integer and 12 bit fractional representation (##.####_####_####) of the X scaling factor for the PS source buffer."
        textline "        "
        hexmask.long.word 0x00 16.--31. 1. " YSCALE ,This is a two bit integer and 12 bit fractional representation (##.####_####_####) of the Y scaling factor for the PS source buffer."
width 10.
group.long 0x120++0x3
    line.long 0x00 "PS_OFFSET,PS Scale Offset Register"
        hexmask.long.word 0x00 0.--12. 1. " XOFFSET ,This is a 12 bit fractional representation (0.####_####_####) of the X scaling offset."
        textline "         "
        hexmask.long.word 0x00 16.--28. 1. " YOFFSET ,This is a 12 bit fractional representation (0.####_####_####) of the Y scaling offset."
width 13.
group.long 0x130++0x3
    line.long 0x00 "PS_CLRKEYLOW,PS Color Key Low"
        hexmask.long.long 0x00 0.--24. 1. " PIXEL ,Low range of color key applied to PS buffer."
width 14.
group.long 0x140++0x3
    line.long 0x00 "PS_CLRKEYHIGH,PS Color Key High"
        hexmask.long.long 0x00 0.--24. 1. " PIXEL ,High range of color key applied to PS buffer."
width 8.
group.long 0x150++0x3
    line.long 0x00 "AS_CTRL,Alpha Surface Control"
        hexmask.long.byte 0x00 1.--3. 1. " ALPHA_CTRL ,Determines how the alpha value is constructed for this alpha surface."
        textline "       "
        bitfld.long 0x00 3. " ENABLE_COLORKEY ,Indicates that colorkey functionality is enabled for this alpha surface." "0,1"
        textline "       "
        hexmask.long.byte 0x00 4.--8. 1. " FORMAT ,Indicates the input buffer format for AS."
        textline "       "
        hexmask.long.byte 0x00 8.--16. 1. " ALPHA ,Alpha modifier used when the ALPHA_MULTIPLY or ALPHA_OVERRIDE values are programmed in PXP_AS_CTRL[ALPHA_CTRL]."
        textline "       "
        hexmask.long.byte 0x00 16.--20. 1. " ROP ,Indicates a raster operation to perform when enabled."
        textline "       "
        bitfld.long 0x00 20. " ALPHA_INVERT ,Setting this bit to logic 0 will not alter the alpha value." "0,1"
width 7.
group.long 0x160++0x3
    line.long 0x00 "AS_BUF,Alpha Surface Buffer Pointer"
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,Address pointer for the alpha surface 0 buffer."
width 9.
group.long 0x170++0x3
    line.long 0x00 "AS_PITCH,Alpha Surface Pitch"
        hexmask.long.word 0x00 0.--16. 1. " PITCH ,Indicates the number of bytes in memory between two vertically adjacent pixels."
width 13.
group.long 0x180++0x3
    line.long 0x00 "AS_CLRKEYLOW,Overlay Color Key Low"
        hexmask.long.long 0x00 0.--24. 1. " PIXEL ,Low range of RGB color key applied to AS buffer."
width 14.
group.long 0x190++0x3
    line.long 0x00 "AS_CLRKEYHIGH,Overlay Color Key High"
        hexmask.long.long 0x00 0.--24. 1. " PIXEL ,High range of RGB color key applied to AS buffer."
width 11.
group.long 0x1a0++0x3
    line.long 0x00 "CSC1_COEF0,Color Space Conversion Coefficient Register 0"
        hexmask.long.word 0x00 0.--9. 1. " Y_OFFSET ,Two's compliment amplitude offset implicit in the Y data."
        textline "          "
        hexmask.long.word 0x00 9.--18. 1. " UV_OFFSET ,Two's compliment phase offset implicit for CbCr data."
        textline "          "
        hexmask.long.word 0x00 18.--29. 1. " C0 ,Two's compliment Y multiplier coefficient."
        textline "          "
        bitfld.long 0x00 30. " BYPASS ,Bypass the CSC unit in the scaling engine." "0,1"
        textline "          "
        bitfld.long 0x00 31. " YCBCR_MODE ,Set to 1 when performing YCbCr conversion to RGB." "0,1"
width 11.
group.long 0x1b0++0x3
    line.long 0x00 "CSC1_COEF1,Color Space Conversion Coefficient Register 1"
        hexmask.long.word 0x00 0.--11. 1. " C4 ,Two's compliment Blue U/Cb multiplier coefficient."
        textline "          "
        hexmask.long.word 0x00 16.--27. 1. " C1 ,Two's compliment Red V/Cr multiplier coefficient."
width 11.
group.long 0x1c0++0x3
    line.long 0x00 "CSC1_COEF2,Color Space Conversion Coefficient Register 2"
        hexmask.long.word 0x00 0.--11. 1. " C3 ,Two's complement Green U/Cb multiplier coefficient."
        textline "          "
        hexmask.long.word 0x00 16.--27. 1. " C2 ,Two's complement Green V/Cr multiplier coefficient."
width 10.
group.long 0x1d0++0x3
    line.long 0x00 "CSC2_CTRL,Color Space Conversion Control Register."
        bitfld.long 0x00 0. " BYPASS ,This bit controls whether the pixels entering the CSC2 unit get converted or not." "0,1"
        textline "         "
        hexmask.long.byte 0x00 1.--3. 1. " CSC_MODE ,This field controls how the CSC unit operates on pixels when the CSC is not bypassed."
width 11.
group.long 0x1e0++0x3
    line.long 0x00 "CSC2_COEF0,Color Space Conversion Coefficient Register 0"
        hexmask.long.word 0x00 0.--11. 1. " A1 ,Two's complement coefficient offset."
        textline "          "
        hexmask.long.word 0x00 16.--27. 1. " A2 ,Two's complement coefficient offset."
width 11.
group.long 0x1f0++0x3
    line.long 0x00 "CSC2_COEF1,Color Space Conversion Coefficient Register 1"
        hexmask.long.word 0x00 0.--11. 1. " A3 ,Two's complement coefficient offset."
        textline "          "
        hexmask.long.word 0x00 16.--27. 1. " B1 ,Two's complement coefficient offset."
width 11.
group.long 0x200++0x3
    line.long 0x00 "CSC2_COEF2,Color Space Conversion Coefficient Register 2"
        hexmask.long.word 0x00 0.--11. 1. " B2 ,Two's complement coefficient offset."
        textline "          "
        hexmask.long.word 0x00 16.--27. 1. " B3 ,Two's complement coefficient offset."
width 11.
group.long 0x210++0x3
    line.long 0x00 "CSC2_COEF3,Color Space Conversion Coefficient Register 3"
        hexmask.long.word 0x00 0.--11. 1. " C1 ,Two's complement coefficient offset."
        textline "          "
        hexmask.long.word 0x00 16.--27. 1. " C2 ,Two's complement coefficient offset."
width 11.
group.long 0x220++0x3
    line.long 0x00 "CSC2_COEF4,Color Space Conversion Coefficient Register 4"
        hexmask.long.word 0x00 0.--11. 1. " C3 ,Two's complement coefficient offset."
        textline "          "
        hexmask.long.word 0x00 16.--25. 1. " D1 ,Two's complement coefficient integer offset to be added."
width 11.
group.long 0x230++0x3
    line.long 0x00 "CSC2_COEF5,Color Space Conversion Coefficient Register 5"
        hexmask.long.word 0x00 0.--9. 1. " D2 ,Two's complement D1 coefficient integer offset to be added."
        textline "          "
        hexmask.long.word 0x00 16.--25. 1. " D3 ,Two's complement coefficient integer offset to be added."
width 9.
group.long 0x240++0x3
    line.long 0x00 "LUT_CTRL,Lookup Table Control Register."
        bitfld.long 0x00 0. " DMA_START ,Setting this bit will result in the DMA operation to load the PXP LUT memory based on PXP_LUT_ADDR_NUM_BYTES, PXP_LUT_ADDR_ADDR, and PXP_LUT_MEM_ADDR." "0,1"
        textline "        "
        bitfld.long 0x00 8. " INVALID ,Invalidate the cache LRU and valid bits." "0,1"
        textline "        "
        bitfld.long 0x00 9. " LRU_UPD ,Least Recently Used Policy Update Control: 1=> block LRU update for hit after miss." "0,1"
        textline "        "
        bitfld.long 0x00 10. " SEL_8KB ,Selects which 8KB bank of memory to use for direct 12bpp lookup modes." "0,1"
        textline "        "
        hexmask.long.byte 0x00 16.--18. 1. " OUT_MODE ,Select the output mode of operation for the LUT resource."
        textline "        "
        hexmask.long.byte 0x00 24.--26. 1. " LOOKUP_MODE ,Configure the input address for the 16KB LUT memory."
        textline "        "
        bitfld.long 0x00 31. " BYPASS ,Setting this bit will bypass the LUT memory resource completely." "0,1"
width 9.
group.long 0x250++0x3
    line.long 0x00 "LUT_ADDR,Lookup Table Control Register."
        hexmask.long.word 0x00 0.--14. 1. " ADDR ,LUT indexed address pointer."
        textline "        "
        hexmask.long.word 0x00 16.--31. 1. " NUM_BYTES ,Indicates the number of bytes to load via a DMA operation."
width 9.
group.long 0x260++0x3
    line.long 0x00 "LUT_DATA,Lookup Table Data Register."
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Writing this field will load 4 bytes, aligned to four byte boundaries, of data indexed by the ADDR field of the PXP_LUT_CTRL register."
width 11.
group.long 0x270++0x3
    line.long 0x00 "LUT_EXTMEM,Lookup Table External Memory Address Register."
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,This register contains the external memory address used for LUT memory operation."
width 4.
group.long 0x280++0x3
    line.long 0x00 "CFA,Color Filter Array Register."
        hexmask.long.long 0x00 0.--32. 1. " DATA ,This register contains the Color Filter Array pattern for decimation of RGBW4444 16 bit pixels to individual R, G, B, W values."
width 10.
group.long 0x290++0x3
    line.long 0x00 "HIST_CTRL,Histogram Control Register."
        hexmask.long.byte 0x00 0.--4. 1. " STATUS ,Indicates which histogram matched the processed bitmap."
        textline "         "
        hexmask.long.byte 0x00 4.--6. 1. " PANEL_MODE ,Specifies the EPDC panel grayscale depth."
width 12.
group.long 0x2a0++0x3
    line.long 0x00 "HIST2_PARAM,2-level Histogram Parameter Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE0 ,Black value for 2-level histogram"
        textline "           "
        hexmask.long.byte 0x00 8.--13. 1. " VALUE1 ,White value for 2-level histogram"
width 12.
group.long 0x2b0++0x3
    line.long 0x00 "HIST4_PARAM,4-level Histogram Parameter Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE0 ,GRAY0 (Black) value for 4-level histogram"
        textline "           "
        hexmask.long.byte 0x00 8.--13. 1. " VALUE1 ,GRAY1 value for 4-level histogram"
        textline "           "
        hexmask.long.byte 0x00 16.--21. 1. " VALUE2 ,GRAY2 value for 4-level histogram"
        textline "           "
        hexmask.long.byte 0x00 24.--29. 1. " VALUE3 ,GRAY3 (White) value for 4-level histogram"
width 13.
group.long 0x2c0++0x3
    line.long 0x00 "HIST8_PARAM0,8-level Histogram Parameter 0 Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE0 ,GRAY0 (Black) value for 8-level histogram"
        textline "            "
        hexmask.long.byte 0x00 8.--13. 1. " VALUE1 ,GRAY1 value for 8-level histogram"
        textline "            "
        hexmask.long.byte 0x00 16.--21. 1. " VALUE2 ,GRAY2 value for 8-level histogram"
        textline "            "
        hexmask.long.byte 0x00 24.--29. 1. " VALUE3 ,GRAY3 value for 8-level histogram"
width 13.
group.long 0x2d0++0x3
    line.long 0x00 "HIST8_PARAM1,8-level Histogram Parameter 1 Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE4 ,GRAY4 value for 8-level histogram"
        textline "            "
        hexmask.long.byte 0x00 8.--13. 1. " VALUE5 ,GRAY5 value for 8-level histogram"
        textline "            "
        hexmask.long.byte 0x00 16.--21. 1. " VALUE6 ,GRAY6 value for 8-level histogram"
        textline "            "
        hexmask.long.byte 0x00 24.--29. 1. " VALUE7 ,GRAY7 (White) value for 8-level histogram"
width 14.
group.long 0x2e0++0x3
    line.long 0x00 "HIST16_PARAM0,16-level Histogram Parameter 0 Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE0 ,GRAY0 (Black) value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 8.--13. 1. " VALUE1 ,GRAY1 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 16.--21. 1. " VALUE2 ,GRAY2 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 24.--29. 1. " VALUE3 ,GRAY3 value for 16-level histogram"
width 14.
group.long 0x2f0++0x3
    line.long 0x00 "HIST16_PARAM1,16-level Histogram Parameter 1 Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE4 ,GRAY4 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 8.--13. 1. " VALUE5 ,GRAY5 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 16.--21. 1. " VALUE6 ,GRAY6 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 24.--29. 1. " VALUE7 ,GRAY7 value for 16-level histogram"
width 14.
group.long 0x300++0x3
    line.long 0x00 "HIST16_PARAM2,16-level Histogram Parameter 2 Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE8 ,GRAY8 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 8.--13. 1. " VALUE9 ,GRAY9 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 16.--21. 1. " VALUE10 ,GRAY10 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 24.--29. 1. " VALUE11 ,GRAY11 value for 16-level histogram"
width 14.
group.long 0x310++0x3
    line.long 0x00 "HIST16_PARAM3,16-level Histogram Parameter 3 Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE12 ,GRAY12 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 8.--13. 1. " VALUE13 ,GRAY13 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 16.--21. 1. " VALUE14 ,GRAY14 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 24.--29. 1. " VALUE15 ,GRAY15 (White) value for 16-level histogram"
width 6.
group.long 0x320++0x3
    line.long 0x00 "POWER,PXP Power Control Register."
        hexmask.long.byte 0x00 0.--3. 1. " LUT_LP_STATE_WAY0_BANK0 ,Select the low power state of the LUT's WAY0-BANK0 memory."
        textline "     "
        hexmask.long.byte 0x00 3.--6. 1. " LUT_LP_STATE_WAY0_BANKN ,Select the low power state of the LUT's WAY0-BANK1,2,3 memory."
        textline "     "
        hexmask.long.byte 0x00 6.--9. 1. " LUT_LP_STATE_WAY1_BANKN ,Select the low power state of the LUT's WAY0-BANK0,1,2,3 memory."
        textline "     "
        hexmask.long.byte 0x00 9.--12. 1. " ROT_MEM_LP_STATE ,Select the low power state of the ROT memory."
        textline "     "
        hexmask.long.long 0x00 12.--32. 1. " CTRL ,This register contains power control for the PXP."
width 5.
group.long 0x400++0x3
    line.long 0x00 "NEXT,Next Frame Pointer"
        bitfld.long 0x00 0. " ENABLED ,Indicates that the ""next frame"" functionality has been enabled." "0,1"
        textline "    "
        hexmask.long.long 0x00 2.--32. 1. " POINTER ,A pointer to a data structure containing register values to be used when processing the next frame."


tree.end



;--------------------------------------------------------------------------------
; QOS
;--------------------------------------------------------------------------------
tree "QOS"
    base ad:0x02094000

width 5.
group.long 0x0++0x3
    line.long 0x00 "CTRL,QOS Control Register"
        bitfld.long 0x00 0. " EMI_PRIORITY_MODE ,Set this bit to one to enable QoS and priority values to be set separately for the AXI fabric and EMI." "0,1"
        textline "    "
        bitfld.long 0x00 1. " XLATE_AXI_MODE ,This bit selects the way in which AXI QoS information is translated into EMI priority values." "0,1"
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " EPDC_PRIORITY_BOOST ,Set this field to enable a feedback path that allows the EPDC to request higher priority for its accesses when needed."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " LCDIF_PRIORITY_BOOST ,Set this field to enable a feedback path that allows the eLCDIF to request higher priority for its accesses when needed."
        textline "    "
        bitfld.long 0x00 30. " CLKGATE ,This bit must be set to zero for normal operation." "0,1"
        textline "    "
        bitfld.long 0x00 31. " SFTRST ,Set to zero for normal operation." "0,1"
width 9.
group.long 0x10++0x3
    line.long 0x00 "AXI_QOS0,AXI QOS Register"
        hexmask.long.byte 0x00 0.--3. 1. " M0_AWQOS ,Specifies the QOS level for the write commands on MasterID 0."
        textline "        "
        hexmask.long.byte 0x00 4.--7. 1. " M0_ARQOS ,Specifies the QOS level for the read commands on MasterID 0."
        textline "        "
        hexmask.long.byte 0x00 8.--11. 1. " M1_0_AWQOS ,Specifies the QOS level for the write commands on MasterID 1."
        textline "        "
        hexmask.long.byte 0x00 12.--15. 1. " M1_0_ARQOS ,Specifies the QOS level for the read commands on MasterID 1."
        textline "        "
        hexmask.long.byte 0x00 16.--19. 1. " M1_1_AWQOS ,Specifies the QOS level for the write commands on MasterID 2."
        textline "        "
        hexmask.long.byte 0x00 20.--23. 1. " M1_1_ARQOS ,Specifies the QOS level for the read commands on MasterID 2."
        textline "        "
        hexmask.long.byte 0x00 24.--27. 1. " M1_2_AWQOS ,Specifies the QOS level for the write commands on MasterID 3."
        textline "        "
        hexmask.long.byte 0x00 28.--31. 1. " M1_2_ARQOS ,Specifies the QOS level for the read commands on MasterID 3."
width 9.
group.long 0x20++0x3
    line.long 0x00 "AXI_QOS1,AXI QOS Register"
        hexmask.long.byte 0x00 0.--3. 1. " M2_AWQOS ,Specifies the QOS level for the write commands on MasterID 4."
        textline "        "
        hexmask.long.byte 0x00 4.--7. 1. " M2_ARQOS ,Specifies the QOS level for the read commands on MasterID 4."
        textline "        "
        hexmask.long.byte 0x00 8.--11. 1. " M3_AWQOS ,Specifies the QOS level for the write commands on MasterID 5."
        textline "        "
        hexmask.long.byte 0x00 12.--15. 1. " M3_ARQOS ,Specifies the QOS level for the read commands on MasterID 5."
        textline "        "
        hexmask.long.byte 0x00 16.--19. 1. " M4_AWQOS ,Specifies the QOS level for the write commands on MasterID 6."
        textline "        "
        hexmask.long.byte 0x00 20.--23. 1. " M4_ARQOS ,Specifies the QOS level for the read commands on MasterID 6."
        textline "        "
        hexmask.long.byte 0x00 24.--27. 1. " M5_AWQOS ,Specifies the QOS level for the write commands on MasterID 7."
        textline "        "
        hexmask.long.byte 0x00 28.--31. 1. " M5_ARQOS ,Specifies the QOS level for the read commands on MasterID 7."
width 9.
group.long 0x30++0x3
    line.long 0x00 "AXI_QOS2,AXI QOS Register"
        hexmask.long.byte 0x00 0.--3. 1. " M6_AWQOS ,Specifies the QOS level for the write commands on MasterID 8."
        textline "        "
        hexmask.long.byte 0x00 4.--7. 1. " M6_ARQOS ,Specifies the QOS level for the read commands on MasterID 8."
        textline "        "
        hexmask.long.byte 0x00 8.--11. 1. " M7_AWQOS ,Specifies the QOS level for the write commands on MasterID 9."
        textline "        "
        hexmask.long.byte 0x00 12.--15. 1. " M7_ARQOS ,Specifies the QOS level for the read commands on MasterID 9."
        textline "        "
        hexmask.long.byte 0x00 16.--19. 1. " M8_AWQOS ,Specifies the QOS level for the write commands on MasterID 10."
        textline "        "
        hexmask.long.byte 0x00 20.--23. 1. " M8_ARQOS ,Specifies the QOS level for the read commands on MasterID 10."
        textline "        "
        hexmask.long.byte 0x00 24.--27. 1. " M9_AWQOS ,Specifies the QOS level for the write commands on MasterID 10."
        textline "        "
        hexmask.long.byte 0x00 28.--31. 1. " M9_ARQOS ,Specifies the QOS level for the read commands on MasterID 11."
width 14.
group.long 0x40++0x3
    line.long 0x00 "EMI_PRIORITY0,EMI priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " M0_WR ,Specifies the priority level for the write commands on MasterID 0."
        textline "             "
        hexmask.long.byte 0x00 4.--7. 1. " M0_RD ,Specifies the priority level for the read commands on MasterID 0."
        textline "             "
        hexmask.long.byte 0x00 8.--11. 1. " M1_0_WR ,Specifies the priority level for the write commands on MasterID 1."
        textline "             "
        hexmask.long.byte 0x00 12.--15. 1. " M1_0_RD ,Specifies the priority level for the read commands on MasterID 1."
        textline "             "
        hexmask.long.byte 0x00 16.--19. 1. " M1_1_WR ,Specifies the priority level for the write commands on MasterID 2."
        textline "             "
        hexmask.long.byte 0x00 20.--23. 1. " M1_1_RD ,Specifies the priority level for the read commands on MasterID 2."
        textline "             "
        hexmask.long.byte 0x00 24.--27. 1. " M1_2_WR ,Specifies the priority level for the write commands on MasterID 3."
        textline "             "
        hexmask.long.byte 0x00 28.--31. 1. " M1_2_RD ,Specifies the priority level for the read commands on MasterID 3."
width 14.
group.long 0x50++0x3
    line.long 0x00 "EMI_PRIORITY1,EMI priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " M2_WR ,Specifies the priority level for the write commands on MasterID 4."
        textline "             "
        hexmask.long.byte 0x00 4.--7. 1. " M2_RD ,Specifies the priority level for the read commands on MasterID 4."
        textline "             "
        hexmask.long.byte 0x00 8.--11. 1. " M3_WR ,Specifies the priority level for the write commands on MasterID 5."
        textline "             "
        hexmask.long.byte 0x00 12.--15. 1. " M3_RD ,Specifies the priority level for the read commands on MasterID 5."
        textline "             "
        hexmask.long.byte 0x00 16.--19. 1. " M4_WR ,Specifies the priority level for the write commands on MasterID 6."
        textline "             "
        hexmask.long.byte 0x00 20.--23. 1. " M4_RD ,Specifies the priority level for the read commands on MasterID 6."
        textline "             "
        hexmask.long.byte 0x00 24.--27. 1. " M5_WR ,Specifies the priority level for the write commands on MasterID 7."
        textline "             "
        hexmask.long.byte 0x00 28.--31. 1. " M5_RD ,Specifies the priority level for the read commands on MasterID 7."
width 14.
group.long 0x60++0x3
    line.long 0x00 "EMI_PRIORITY2,EMI priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " M6_WR ,Specifies the priority level for the write commands on MasterID 8."
        textline "             "
        hexmask.long.byte 0x00 4.--7. 1. " M6_RD ,Specifies the priority level for the read commands on MasterID 8."
        textline "             "
        hexmask.long.byte 0x00 8.--11. 1. " M7_WR ,Specifies the priority level for the write commands on MasterID 9."
        textline "             "
        hexmask.long.byte 0x00 12.--15. 1. " M7_RD ,Specifies the priority level for the read commands on MasterID 9."
        textline "             "
        hexmask.long.byte 0x00 16.--19. 1. " M8_WR ,Specifies the priority level for the write commands on MasterID 10."
        textline "             "
        hexmask.long.byte 0x00 20.--23. 1. " M8_RD ,Specifies the priority level for the read commands on MasterID 10."
        textline "             "
        hexmask.long.byte 0x00 24.--27. 1. " M9_WR ,Specifies the priority level for the write commands on MasterID 10."
        textline "             "
        hexmask.long.byte 0x00 28.--31. 1. " M9_RD ,Specifies the priority level for the read commands on MasterID 11."
width 8.
group.long 0x70++0x3
    line.long 0x00 "DISABLE,AXI Master Disble Register"
        bitfld.long 0x00 1. " M1_0_DIS ,Setting this bit disables the interface between master1_0 and the AXI fabric." "0,1"
        textline "       "
        bitfld.long 0x00 2. " M1_1_DIS ,Setting this bit disables the interface between master1_1 and the AXI fabric." "0,1"
        textline "       "
        bitfld.long 0x00 3. " M1_2_DIS ,Setting this bit disables the interface between master1_2 and the AXI fabric." "0,1"
        textline "       "
        bitfld.long 0x00 4. " M2_DIS ,Setting this bit disables the interface between master2 and the AXI fabric." "0,1"
        textline "       "
        bitfld.long 0x00 5. " M3_DIS ,Setting this bit disables the interface between master3 and the AXI fabric." "0,1"
        textline "       "
        bitfld.long 0x00 6. " M4_DIS ,Setting this bit disables the interface between master4 and the AXI fabric." "0,1"
        textline "       "
        bitfld.long 0x00 7. " M5_DIS ,Setting this bit disables the interface between master5 and the AXI fabric." "0,1"
        textline "       "
        bitfld.long 0x00 8. " M6_DIS ,Setting this bit disables the interface between master6 and the AXI fabric." "0,1"
        textline "       "
        bitfld.long 0x00 9. " M7_DIS ,Setting this bit disables the interface between master7 and the AXI fabric." "0,1"
        textline "       "
        bitfld.long 0x00 10. " M8_DIS ,Setting this bit disables the interface between master8 and the AXI fabric." "0,1"
        textline "       "
        bitfld.long 0x00 11. " M9_DIS ,Setting this bit disables the interface between master9 and the AXI fabric." "0,1"
        textline "       "
        bitfld.long 0x00 17. " M1_0_DIS_STAT ,This bit indicates the enable/disable status for master port1_0 on the AXI fabric." "0,1"
        textline "       "
        bitfld.long 0x00 18. " M1_1_DIS_STAT ,This bit indicates the enable/disable status for master port1_1 on the AXI fabric." "0,1"
        textline "       "
        bitfld.long 0x00 19. " M1_2_DIS_STAT ,This bit indicates the enable/disable status for master port1_2 on the AXI fabric." "0,1"
        textline "       "
        bitfld.long 0x00 20. " M2_DIS_STAT ,This bit indicates the enable/disable status for master port0 on the AXI fabric." "0,1"
        textline "       "
        bitfld.long 0x00 21. " M3_DIS_STAT ,This bit indicates the enable/disable status for master port0 on the AXI fabric." "0,1"
        textline "       "
        bitfld.long 0x00 22. " M4_DIS_STAT ,This bit indicates the enable/disable status for master port0 on the AXI fabric." "0,1"
        textline "       "
        bitfld.long 0x00 23. " M5_DIS_STAT ,This bit indicates the enable/disable status for master port0 on the AXI fabric." "0,1"
        textline "       "
        bitfld.long 0x00 24. " M6_DIS_STAT ,This bit indicates the enable/disable status for master port0 on the AXI fabric." "0,1"
        textline "       "
        bitfld.long 0x00 25. " M7_DIS_STAT ,This bit indicates the enable/disable status for master port0 on the AXI fabric." "0,1"
        textline "       "
        bitfld.long 0x00 26. " M8_DIS_STAT ,This bit indicates the enable/disable status for master port0 on the AXI fabric." "0,1"
        textline "       "
        bitfld.long 0x00 27. " M9_DIS_STAT ,This bit indicates the enable/disable status for master port0 on the AXI fabric." "0,1"
width 8.
rgroup.long 0x80++0x3
    line.long 0x00 "VERSION,QOS Version Register"
        hexmask.long.word 0x00 0.--16. 1. " STEP ,Fixed read-only value reflecting the stepping of the RTL version."
        textline "       "
        hexmask.long.byte 0x00 16.--24. 1. " MINOR ,Fixed read-only value reflecting the MINOR field of the RTL version."
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " MAJOR ,Fixed read-only value reflecting the MAJOR field of the RTL version."


tree.end



;--------------------------------------------------------------------------------
; RNG
;--------------------------------------------------------------------------------
tree "RNG"
    base ad:0x021b4000

width 4.
rgroup.long 0x0++0x3
    line.long 0x00 "VER,RNGB Version ID Register"
        hexmask.long.byte 0x00 0.--8. 1. " MINOR ,Subjiect to change."
        textline "   "
        hexmask.long.byte 0x00 8.--16. 1. " MAJOR ,This field is always set to 0x02."
        textline "   "
        hexmask.long.byte 0x00 28.--32. 1. " TYPE ,"
width 4.
group.long 0x4++0x3
    line.long 0x00 "CMD,RNGB Command Register"
        bitfld.long 0x00 0. " ST ,Initiates a self test of the RNGB's internal logic." "0,1"
        textline "   "
        bitfld.long 0x00 1. " GS ,Initiates the seed generation process." "0,1"
        textline "   "
        bitfld.long 0x00 4. " CI ,Clears the RNGB interrupt if an error is not present." "0,1"
        textline "   "
        bitfld.long 0x00 5. " CE ,Clears the errors in the RNG_ESR register and the RNGB interrupt.This bit is self-clearing." "0,1"
        textline "   "
        bitfld.long 0x00 6. " SR ,Performs a software reset of the RNGB." "0,1"
width 3.
group.long 0x8++0x3
    line.long 0x00 "CR,RNGB Control Register"
        hexmask.long.byte 0x00 0.--2. 1. " FUFMOD ,Controls the RNGB's response to a FIFO underflow condition."
        textline "  "
        bitfld.long 0x00 4. " AR ,Setting this bit allows the RNGB to automatically generate a new seed whenever one is needed." "0,1"
        textline "  "
        bitfld.long 0x00 5. " MASKDONE ,Masks interrupts generated upon completion of seed and self test modes." "0,1"
        textline "  "
        bitfld.long 0x00 6. " MASKERR ,Masks interrupts generated by errors in the RNGB." "0,1"
width 3.
rgroup.long 0xc++0x3
    line.long 0x00 "SR,RNGB Status Register"
        bitfld.long 0x00 1. " BUSY ,Reflects the current state of RNGB." "0,1"
        textline "  "
        bitfld.long 0x00 2. " SLP ,Indicates if the RNGB is in sleep mode." "0,1"
        textline "  "
        bitfld.long 0x00 3. " RS ,Indicates the RNGB needs to be reseeded." "0,1"
        textline "  "
        bitfld.long 0x00 4. " STDN ,Indicates the self test is complete." "0,1"
        textline "  "
        bitfld.long 0x00 5. " SDN ,Indicates the RNG has generated the first seed." "0,1"
        textline "  "
        bitfld.long 0x00 6. " NSDN ,Indicates that a new seed is ready for use during the next seed generation process." "0,1"
        textline "  "
        hexmask.long.byte 0x00 8.--12. 1. " FIFO_LVL ,Indicates the number of random words currently in the output FIFO."
        textline "  "
        hexmask.long.byte 0x00 12.--16. 1. " FIFO_SIZE ,Size of the FIFO, and maximum possible FIFO level."
        textline "  "
        bitfld.long 0x00 16. " ERR ,Indicates an error was detected in the RNGB." "0,1"
        textline "  "
        hexmask.long.byte 0x00 21.--24. 1. " ST_PF ,Indicates Pass or Fail status of the TRNG, PRNG, and RESEED self tests, Bit 23 - TRNG self test pass/fail Bit 22 - PRNG self test pass/fail Bit 21 - RESEED self test pass/fail"
        textline "  "
        hexmask.long.byte 0x00 24.--32. 1. " STATPF ,Indicates pass or fail status of the various statistics tests on the last seed generated."
width 4.
rgroup.long 0x10++0x3
    line.long 0x00 "ESR,RNGB Error Status Register"
        bitfld.long 0x00 0. " LFE ,When this bit is set, the interrupt generated was caused by a failure of one of the LFSRs in one of the RNGB's three entropy sources." "0,1"
        textline "   "
        bitfld.long 0x00 1. " OSCE ,Indicates the oscillator in the RNG may be broken." "0,1"
        textline "   "
        bitfld.long 0x00 2. " STE ,Indicates the RNGB has failed the most recent self test." "0,1"
        textline "   "
        bitfld.long 0x00 3. " SATE ,Indicates if RNGB has failed the statistical tests for the last generated seed." "0,1"
        textline "   "
        bitfld.long 0x00 4. " FUFE ,Indicates the RNGB has experienced a FIFO underflow condition resulting in the last random data read being unreliable." "0,1"
width 4.
rgroup.long 0x14++0x3
    line.long 0x00 "OUT,RNGB Output FIFO"
        hexmask.long.long 0x00 0.--32. 1. " RANDOUT ,"


tree.end



;--------------------------------------------------------------------------------
; ROMC
;--------------------------------------------------------------------------------
tree "ROMC"
    base ad:0x021ac000

width 11.
group.long 0xd4++0x3
    line.long 0x00 "ROMPATCH0D,ROMC Data Registers"
        hexmask.long.long 0x00 0.--32. 1. " DATAX ,Data Fix Registers - Stores the data used for 1-word data fix operations."
width 11.
group.long 0xd8++0x3
    line.long 0x00 "ROMPATCH1D,ROMC Data Registers"
        hexmask.long.long 0x00 0.--32. 1. " DATAX ,Data Fix Registers - Stores the data used for 1-word data fix operations."
width 11.
group.long 0xdc++0x3
    line.long 0x00 "ROMPATCH2D,ROMC Data Registers"
        hexmask.long.long 0x00 0.--32. 1. " DATAX ,Data Fix Registers - Stores the data used for 1-word data fix operations."
width 11.
group.long 0xe0++0x3
    line.long 0x00 "ROMPATCH3D,ROMC Data Registers"
        hexmask.long.long 0x00 0.--32. 1. " DATAX ,Data Fix Registers - Stores the data used for 1-word data fix operations."
width 11.
group.long 0xe4++0x3
    line.long 0x00 "ROMPATCH4D,ROMC Data Registers"
        hexmask.long.long 0x00 0.--32. 1. " DATAX ,Data Fix Registers - Stores the data used for 1-word data fix operations."
width 11.
group.long 0xe8++0x3
    line.long 0x00 "ROMPATCH5D,ROMC Data Registers"
        hexmask.long.long 0x00 0.--32. 1. " DATAX ,Data Fix Registers - Stores the data used for 1-word data fix operations."
width 11.
group.long 0xec++0x3
    line.long 0x00 "ROMPATCH6D,ROMC Data Registers"
        hexmask.long.long 0x00 0.--32. 1. " DATAX ,Data Fix Registers - Stores the data used for 1-word data fix operations."
width 11.
group.long 0xf0++0x3
    line.long 0x00 "ROMPATCH7D,ROMC Data Registers"
        hexmask.long.long 0x00 0.--32. 1. " DATAX ,Data Fix Registers - Stores the data used for 1-word data fix operations."
width 13.
group.long 0xf4++0x3
    line.long 0x00 "ROMPATCHCNTL,ROMC Control Register"
        hexmask.long.byte 0x00 0.--8. 1. " DATAFIX ,Data Fix Enable - Controls the use of the first 8 address comparators for 1-word data fix or for code patch routine."
        textline "            "
        bitfld.long 0x00 29. " DIS ,ROMC Disable -- This bit, when set, disables all ROMC operations." "0,1"
width 12.
rgroup.long 0xf8++0x3
    line.long 0x00 "ROMPATCHENH,ROMC Enable Register High"
width 12.
group.long 0xfc++0x3
    line.long 0x00 "ROMPATCHENL,ROMC Enable Register Low"
        hexmask.long.word 0x00 0.--16. 1. " ENABLE ,Enable Address Comparator - This bit enables the corresponding address comparator to trigger an event."
width 11.
group.long 0x100++0x3
    line.long 0x00 "ROMPATCH0A,ROMC Address Registers"
        bitfld.long 0x00 0. " THUMBX ,THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an ARM opcode patch." "0,1"
        textline "          "
        hexmask.long.long 0x00 1.--23. 1. " ADDRX ,Address Comparator Registers - Indicates the memory address to be watched."
width 11.
group.long 0x104++0x3
    line.long 0x00 "ROMPATCH1A,ROMC Address Registers"
        bitfld.long 0x00 0. " THUMBX ,THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an ARM opcode patch." "0,1"
        textline "          "
        hexmask.long.long 0x00 1.--23. 1. " ADDRX ,Address Comparator Registers - Indicates the memory address to be watched."
width 11.
group.long 0x108++0x3
    line.long 0x00 "ROMPATCH2A,ROMC Address Registers"
        bitfld.long 0x00 0. " THUMBX ,THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an ARM opcode patch." "0,1"
        textline "          "
        hexmask.long.long 0x00 1.--23. 1. " ADDRX ,Address Comparator Registers - Indicates the memory address to be watched."
width 11.
group.long 0x10c++0x3
    line.long 0x00 "ROMPATCH3A,ROMC Address Registers"
        bitfld.long 0x00 0. " THUMBX ,THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an ARM opcode patch." "0,1"
        textline "          "
        hexmask.long.long 0x00 1.--23. 1. " ADDRX ,Address Comparator Registers - Indicates the memory address to be watched."
width 11.
group.long 0x110++0x3
    line.long 0x00 "ROMPATCH4A,ROMC Address Registers"
        bitfld.long 0x00 0. " THUMBX ,THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an ARM opcode patch." "0,1"
        textline "          "
        hexmask.long.long 0x00 1.--23. 1. " ADDRX ,Address Comparator Registers - Indicates the memory address to be watched."
width 11.
group.long 0x114++0x3
    line.long 0x00 "ROMPATCH5A,ROMC Address Registers"
        bitfld.long 0x00 0. " THUMBX ,THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an ARM opcode patch." "0,1"
        textline "          "
        hexmask.long.long 0x00 1.--23. 1. " ADDRX ,Address Comparator Registers - Indicates the memory address to be watched."
width 11.
group.long 0x118++0x3
    line.long 0x00 "ROMPATCH6A,ROMC Address Registers"
        bitfld.long 0x00 0. " THUMBX ,THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an ARM opcode patch." "0,1"
        textline "          "
        hexmask.long.long 0x00 1.--23. 1. " ADDRX ,Address Comparator Registers - Indicates the memory address to be watched."
width 11.
group.long 0x11c++0x3
    line.long 0x00 "ROMPATCH7A,ROMC Address Registers"
        bitfld.long 0x00 0. " THUMBX ,THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an ARM opcode patch." "0,1"
        textline "          "
        hexmask.long.long 0x00 1.--23. 1. " ADDRX ,Address Comparator Registers - Indicates the memory address to be watched."
width 11.
group.long 0x120++0x3
    line.long 0x00 "ROMPATCH8A,ROMC Address Registers"
        bitfld.long 0x00 0. " THUMBX ,THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an ARM opcode patch." "0,1"
        textline "          "
        hexmask.long.long 0x00 1.--23. 1. " ADDRX ,Address Comparator Registers - Indicates the memory address to be watched."
width 11.
group.long 0x124++0x3
    line.long 0x00 "ROMPATCH9A,ROMC Address Registers"
        bitfld.long 0x00 0. " THUMBX ,THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an ARM opcode patch." "0,1"
        textline "          "
        hexmask.long.long 0x00 1.--23. 1. " ADDRX ,Address Comparator Registers - Indicates the memory address to be watched."
width 12.
group.long 0x128++0x3
    line.long 0x00 "ROMPATCH10A,ROMC Address Registers"
        bitfld.long 0x00 0. " THUMBX ,THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an ARM opcode patch." "0,1"
        textline "           "
        hexmask.long.long 0x00 1.--23. 1. " ADDRX ,Address Comparator Registers - Indicates the memory address to be watched."
width 12.
group.long 0x12c++0x3
    line.long 0x00 "ROMPATCH11A,ROMC Address Registers"
        bitfld.long 0x00 0. " THUMBX ,THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an ARM opcode patch." "0,1"
        textline "           "
        hexmask.long.long 0x00 1.--23. 1. " ADDRX ,Address Comparator Registers - Indicates the memory address to be watched."
width 12.
group.long 0x130++0x3
    line.long 0x00 "ROMPATCH12A,ROMC Address Registers"
        bitfld.long 0x00 0. " THUMBX ,THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an ARM opcode patch." "0,1"
        textline "           "
        hexmask.long.long 0x00 1.--23. 1. " ADDRX ,Address Comparator Registers - Indicates the memory address to be watched."
width 12.
group.long 0x134++0x3
    line.long 0x00 "ROMPATCH13A,ROMC Address Registers"
        bitfld.long 0x00 0. " THUMBX ,THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an ARM opcode patch." "0,1"
        textline "           "
        hexmask.long.long 0x00 1.--23. 1. " ADDRX ,Address Comparator Registers - Indicates the memory address to be watched."
width 12.
group.long 0x138++0x3
    line.long 0x00 "ROMPATCH14A,ROMC Address Registers"
        bitfld.long 0x00 0. " THUMBX ,THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an ARM opcode patch." "0,1"
        textline "           "
        hexmask.long.long 0x00 1.--23. 1. " ADDRX ,Address Comparator Registers - Indicates the memory address to be watched."
width 12.
group.long 0x13c++0x3
    line.long 0x00 "ROMPATCH15A,ROMC Address Registers"
        bitfld.long 0x00 0. " THUMBX ,THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an ARM opcode patch." "0,1"
        textline "           "
        hexmask.long.long 0x00 1.--23. 1. " ADDRX ,Address Comparator Registers - Indicates the memory address to be watched."
width 11.
group.long 0x208++0x3
    line.long 0x00 "ROMPATCHSR,ROMC Status Register"
        hexmask.long.byte 0x00 0.--6. 1. " SOURCE ,ROMC Source Number - Binary encoding of the number of the address comparator which has an address match in the most recent patch event on ROMC AHB."
        textline "          "
        bitfld.long 0x00 17. " SW ,ROMC AHB Multiple Address Comparator matches Indicator - Indicates that multiple address comparator matches occurred." "0,1"


tree.end



;--------------------------------------------------------------------------------
; SDMAARM
;--------------------------------------------------------------------------------
tree "SDMAARM"
    base ad:0x020ec000

width 7.
group.long 0x0++0x3
    line.long 0x00 "MC0PTR,ARM platform Channel 0 Pointer"
        hexmask.long.long 0x00 0.--32. 1. " MC0PTR ,Channel 0 Pointer contains the 32-bit address, in ARM platform memory, of channel 0 control block (the boot channel)."
width 5.
group.long 0x4++0x3
    line.long 0x00 "INTR,Channel Interrupts"
        hexmask.long.long 0x00 0.--32. 1. " HI ,The ARM platform Interrupts register contains the 32 HI[i] bits."
width 10.
group.long 0x8++0x3
    line.long 0x00 "STOP_STAT,Channel Stop/Channel Status"
        hexmask.long.long 0x00 0.--32. 1. " HE ,This 32-bit register gives access to the ARM platform Enable bits."
width 7.
group.long 0xc++0x3
    line.long 0x00 "HSTART,Channel Start"
        hexmask.long.long 0x00 0.--32. 1. " HSTART_HE ,The HSTART_HE registers are 32 bits wide with one bit for every channel."
width 7.
group.long 0x10++0x3
    line.long 0x00 "EVTOVR,Channel Event Override"
        hexmask.long.long 0x00 0.--32. 1. " EO ,The Channel Event Override register contains the 32 EO[i] bits."
width 7.
group.long 0x14++0x3
    line.long 0x00 "DSPOVR,Channel BP Override"
        hexmask.long.long 0x00 0.--32. 1. " DO ,This register is reserved."
width 8.
group.long 0x18++0x3
    line.long 0x00 "HOSTOVR,Channel ARM platform Override"
        hexmask.long.long 0x00 0.--32. 1. " HO ,The Channel ARM platform Override register contains the 32 HO[i] bits."
width 8.
group.long 0x1c++0x3
    line.long 0x00 "EVTPEND,Channel Event Pending"
        hexmask.long.long 0x00 0.--32. 1. " EP ,The Channel Event Pending register contains the 32 EP[i] bits."
width 6.
rgroup.long 0x24++0x3
    line.long 0x00 "RESET,Reset Register"
        bitfld.long 0x00 0. " RESET ,When set, this bit causes the SDMA to be held in a software reset." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RESCHED ,When set, this bit forces the SDMA to reschedule as if a script had executed a done instruction." "0,1"
width 7.
rgroup.long 0x28++0x3
    line.long 0x00 "EVTERR,DMA Request Error Register"
        hexmask.long.long 0x00 0.--32. 1. " CHNERR ,This register is used by the SDMA to warn the ARM platform when an incoming DMA request was detected and it triggers a channel that is already pending or being serviced."
width 9.
group.long 0x2c++0x3
    line.long 0x00 "INTRMASK,Channel ARM platform Interrupt Mask"
        hexmask.long.long 0x00 0.--32. 1. " HIMASK ,The Interrupt Mask Register contains 32 interrupt generation mask bits."
width 4.
rgroup.long 0x30++0x3
    line.long 0x00 "PSW,Schedule Status"
        hexmask.long.byte 0x00 0.--4. 1. " CCR ,The Current Channel Register indicates the number of the channel that is being executed by the SDMA."
        textline "   "
        hexmask.long.byte 0x00 4.--8. 1. " CCP ,The Current Channel Priority indicates the priority of the current active channel."
        textline "   "
        hexmask.long.byte 0x00 8.--13. 1. " NCR ,The Next Channel Register indicates the number of the next scheduled pending channel with the highest priority."
        textline "   "
        hexmask.long.byte 0x00 13.--16. 1. " NCP ,The Next Channel Priority gives the next pending channel priority."
width 10.
rgroup.long 0x34++0x3
    line.long 0x00 "EVTERRDBG,DMA Request Error Register"
        hexmask.long.long 0x00 0.--32. 1. " CHNERR ,This register is the same as EVTERR, except reading it does not clear its contents."
width 7.
group.long 0x38++0x3
    line.long 0x00 "CONFIG,Configuration Register"
        hexmask.long.byte 0x00 0.--2. 1. " CSM ,Selects the Context Switch Mode."
        textline "      "
        bitfld.long 0x00 4. " ACR ,ARM platform DMA / SDMA Core Clock Ratio." "0,1"
        textline "      "
        bitfld.long 0x00 11. " RTDOBS ,Indicates if Real-Time Debug pins are used: They do not toggle by default in order to reduce power consumption." "0,1"
        textline "      "
        bitfld.long 0x00 12. " DSPDMA ,This bit's function is reserved and should be configured as zero." "0,1"
width 10.
group.long 0x3c++0x3
    line.long 0x00 "SDMA_LOCK,SDMA LOCK"
        bitfld.long 0x00 0. " LOCK ,The LOCK bit is used to restrict access to update SDMA script memory through ROM channel zero scripts and through the OnCE interface under ARM platform control." "0,1"
        textline "         "
        bitfld.long 0x00 1. " SRESET_LOCK_CLR ,The SRESET_LOCK_CLR bit determine if the LOCK bit is cleared on a software reset triggered by writing to the RESET register." "0,1"
width 9.
group.long 0x40++0x3
    line.long 0x00 "ONCE_ENB,OnCE Enable"
        bitfld.long 0x00 0. " ENB ,The OnCE Enable register selects the OnCE control source: When cleared (0), the OnCE registers are accessed through the JTAG interface; when set (1), the OnCE registers may be accessed by the ARM platform through the addresses described, as follows." "0,1"
width 10.
group.long 0x44++0x3
    line.long 0x00 "ONCE_DATA,OnCE Data Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Data register of the OnCE JTAG controller."
width 11.
group.long 0x48++0x3
    line.long 0x00 "ONCE_INSTR,OnCE Instruction Register"
        hexmask.long.word 0x00 0.--16. 1. " INSTR ,Instruction register of the OnCE JTAG controller."
width 10.
rgroup.long 0x4c++0x3
    line.long 0x00 "ONCE_STAT,OnCE Status Register"
        hexmask.long.byte 0x00 0.--3. 1. " ECDR ,Event Cell Debug Request."
        textline "         "
        bitfld.long 0x00 7. " MST ,This flag is raised when the OnCE is controlled from the ARM platform peripheral interface." "0,1"
        textline "         "
        bitfld.long 0x00 8. " SWB ,This flag is raised when the SDMA has entered debug mode after a software breakpoint." "0,1"
        textline "         "
        bitfld.long 0x00 9. " ODR ,This flag is raised when the SDMA has entered debug mode after a OnCE debug request." "0,1"
        textline "         "
        bitfld.long 0x00 10. " EDR ,This flag is raised when the SDMA has entered debug mode after an external debug request." "0,1"
        textline "         "
        bitfld.long 0x00 11. " RCV ,After each write access to the real time buffer (RTB), the RCV bit is set." "0,1"
        textline "         "
        hexmask.long.byte 0x00 12.--16. 1. " PST ,The Processor Status bits reflect the state of the SDMA RISC engine."
width 9.
group.long 0x50++0x3
    line.long 0x00 "ONCE_CMD,OnCE Command Register"
        hexmask.long.byte 0x00 0.--4. 1. " CMD ,Writing to this register will cause the OnCE to execute the command that is written."
width 12.
group.long 0x58++0x3
    line.long 0x00 "ILLINSTADDR,Illegal Instruction Trap Address"
        hexmask.long.word 0x00 0.--14. 1. " ILLINSTADDR ,The Illegal Instruction Trap Address is the address where the SDMA jumps when an illegal instruction is executed."
width 9.
group.long 0x5c++0x3
    line.long 0x00 "CHN0ADDR,Channel 0 Boot Address"
        hexmask.long.word 0x00 0.--14. 1. " CHN0ADDR ,This 14-bit register is used by the boot code of the SDMA."
        textline "        "
        bitfld.long 0x00 14. " SMSZ ,The bit 14 (Scratch Memory Size) determines if scratch memory must be available after every channel context." "0,1"
width 11.
rgroup.long 0x60++0x3
    line.long 0x00 "EVT_MIRROR,DMA Requests"
        hexmask.long.long 0x00 0.--32. 1. " EVENTS ,This register reflects the DMA requests received by the SDMA for events 31-0."
width 12.
rgroup.long 0x64++0x3
    line.long 0x00 "EVT_MIRROR2,DMA Requests 2"
        hexmask.long.word 0x00 0.--16. 1. " EVENTS ,This register reflects the DMA requests received by the SDMA for events 47-32."
width 12.
group.long 0x70++0x3
    line.long 0x00 "XTRIG_CONF1,Cross-Trigger Events Configuration Register 1"
        hexmask.long.byte 0x00 0.--6. 1. " NUM0 ,Contains the number of the DMA request or channel that triggers the pulse on the cross-trigger event line number i ."
        textline "           "
        bitfld.long 0x00 6. " CNF0 ,Configuration of the SDMA event line number i that is connected to the cross-trigger." "0,1"
        textline "           "
        hexmask.long.byte 0x00 8.--14. 1. " NUM1 ,Contains the number of the DMA request or channel that triggers the pulse on the cross-trigger event line number i ."
        textline "           "
        bitfld.long 0x00 14. " CNF1 ,Configuration of the SDMA event line number i that is connected to the cross-trigger." "0,1"
        textline "           "
        hexmask.long.byte 0x00 16.--22. 1. " NUM2 ,Contains the number of the DMA request or channel that triggers the pulse on the cross-trigger event line number i ."
        textline "           "
        bitfld.long 0x00 22. " CNF2 ,Configuration of the SDMA event line number i that is connected to the cross-trigger." "0,1"
        textline "           "
        hexmask.long.byte 0x00 24.--30. 1. " NUM3 ,Contains the number of the DMA request or channel that triggers the pulse on the cross-trigger event line number i ."
        textline "           "
        bitfld.long 0x00 30. " CNF3 ,Configuration of the SDMA event line number i that is connected to the cross-trigger." "0,1"
width 12.
group.long 0x74++0x3
    line.long 0x00 "XTRIG_CONF2,Cross-Trigger Events Configuration Register 2"
        hexmask.long.byte 0x00 0.--6. 1. " NUM4 ,Contains the number of the DMA request or channel that triggers the pulse on the cross-trigger event line number i ."
        textline "           "
        bitfld.long 0x00 6. " CNF4 ,Configuration of the SDMA event line number i that is connected to the cross-trigger." "0,1"
        textline "           "
        hexmask.long.byte 0x00 8.--14. 1. " NUM5 ,Contains the number of the DMA request or channel that triggers the pulse on the cross-trigger event line number i ."
        textline "           "
        bitfld.long 0x00 14. " CNF5 ,Configuration of the SDMA event line number i that is connected to the cross-trigger." "0,1"
        textline "           "
        hexmask.long.byte 0x00 16.--22. 1. " NUM6 ,Contains the number of the DMA request or channel that triggers the pulse on the cross-trigger event line number i ."
        textline "           "
        bitfld.long 0x00 22. " CNF6 ,Configuration of the SDMA event line number i that is connected to the cross-trigger." "0,1"
        textline "           "
        hexmask.long.byte 0x00 24.--30. 1. " NUM7 ,Contains the number of the DMA request or channel that triggers the pulse on the cross-trigger event line number i ."
        textline "           "
        bitfld.long 0x00 30. " CNF7 ,Configuration of the SDMA event line number i that is connected to the cross-trigger." "0,1"
width 13.
group.long 0x100++0x3
    line.long 0x00 "SDMA_CHNPRI0,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 13.
group.long 0x104++0x3
    line.long 0x00 "SDMA_CHNPRI1,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 13.
group.long 0x108++0x3
    line.long 0x00 "SDMA_CHNPRI2,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 13.
group.long 0x10c++0x3
    line.long 0x00 "SDMA_CHNPRI3,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 13.
group.long 0x110++0x3
    line.long 0x00 "SDMA_CHNPRI4,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 13.
group.long 0x114++0x3
    line.long 0x00 "SDMA_CHNPRI5,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 13.
group.long 0x118++0x3
    line.long 0x00 "SDMA_CHNPRI6,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 13.
group.long 0x11c++0x3
    line.long 0x00 "SDMA_CHNPRI7,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 13.
group.long 0x120++0x3
    line.long 0x00 "SDMA_CHNPRI8,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 13.
group.long 0x124++0x3
    line.long 0x00 "SDMA_CHNPRI9,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x128++0x3
    line.long 0x00 "SDMA_CHNPRI10,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x12c++0x3
    line.long 0x00 "SDMA_CHNPRI11,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x130++0x3
    line.long 0x00 "SDMA_CHNPRI12,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x134++0x3
    line.long 0x00 "SDMA_CHNPRI13,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x138++0x3
    line.long 0x00 "SDMA_CHNPRI14,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x13c++0x3
    line.long 0x00 "SDMA_CHNPRI15,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x140++0x3
    line.long 0x00 "SDMA_CHNPRI16,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x144++0x3
    line.long 0x00 "SDMA_CHNPRI17,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x148++0x3
    line.long 0x00 "SDMA_CHNPRI18,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x14c++0x3
    line.long 0x00 "SDMA_CHNPRI19,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x150++0x3
    line.long 0x00 "SDMA_CHNPRI20,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x154++0x3
    line.long 0x00 "SDMA_CHNPRI21,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x158++0x3
    line.long 0x00 "SDMA_CHNPRI22,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x15c++0x3
    line.long 0x00 "SDMA_CHNPRI23,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x160++0x3
    line.long 0x00 "SDMA_CHNPRI24,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x164++0x3
    line.long 0x00 "SDMA_CHNPRI25,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x168++0x3
    line.long 0x00 "SDMA_CHNPRI26,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x16c++0x3
    line.long 0x00 "SDMA_CHNPRI27,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x170++0x3
    line.long 0x00 "SDMA_CHNPRI28,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x174++0x3
    line.long 0x00 "SDMA_CHNPRI29,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x178++0x3
    line.long 0x00 "SDMA_CHNPRI30,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x17c++0x3
    line.long 0x00 "SDMA_CHNPRI31,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 9.
group.long 0x200++0x3
    line.long 0x00 "CHNENBL0,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 9.
group.long 0x204++0x3
    line.long 0x00 "CHNENBL1,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 9.
group.long 0x208++0x3
    line.long 0x00 "CHNENBL2,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 9.
group.long 0x20c++0x3
    line.long 0x00 "CHNENBL3,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 9.
group.long 0x210++0x3
    line.long 0x00 "CHNENBL4,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 9.
group.long 0x214++0x3
    line.long 0x00 "CHNENBL5,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 9.
group.long 0x218++0x3
    line.long 0x00 "CHNENBL6,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 9.
group.long 0x21c++0x3
    line.long 0x00 "CHNENBL7,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 9.
group.long 0x220++0x3
    line.long 0x00 "CHNENBL8,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 9.
group.long 0x224++0x3
    line.long 0x00 "CHNENBL9,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x228++0x3
    line.long 0x00 "CHNENBL10,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x22c++0x3
    line.long 0x00 "CHNENBL11,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x230++0x3
    line.long 0x00 "CHNENBL12,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x234++0x3
    line.long 0x00 "CHNENBL13,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x238++0x3
    line.long 0x00 "CHNENBL14,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x23c++0x3
    line.long 0x00 "CHNENBL15,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x240++0x3
    line.long 0x00 "CHNENBL16,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x244++0x3
    line.long 0x00 "CHNENBL17,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x248++0x3
    line.long 0x00 "CHNENBL18,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x24c++0x3
    line.long 0x00 "CHNENBL19,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x250++0x3
    line.long 0x00 "CHNENBL20,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x254++0x3
    line.long 0x00 "CHNENBL21,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x258++0x3
    line.long 0x00 "CHNENBL22,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x25c++0x3
    line.long 0x00 "CHNENBL23,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x260++0x3
    line.long 0x00 "CHNENBL24,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x264++0x3
    line.long 0x00 "CHNENBL25,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x268++0x3
    line.long 0x00 "CHNENBL26,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x26c++0x3
    line.long 0x00 "CHNENBL27,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x270++0x3
    line.long 0x00 "CHNENBL28,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x274++0x3
    line.long 0x00 "CHNENBL29,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x278++0x3
    line.long 0x00 "CHNENBL30,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x27c++0x3
    line.long 0x00 "CHNENBL31,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x280++0x3
    line.long 0x00 "CHNENBL32,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x284++0x3
    line.long 0x00 "CHNENBL33,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x288++0x3
    line.long 0x00 "CHNENBL34,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x28c++0x3
    line.long 0x00 "CHNENBL35,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x290++0x3
    line.long 0x00 "CHNENBL36,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x294++0x3
    line.long 0x00 "CHNENBL37,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x298++0x3
    line.long 0x00 "CHNENBL38,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x29c++0x3
    line.long 0x00 "CHNENBL39,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x2a0++0x3
    line.long 0x00 "CHNENBL40,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x2a4++0x3
    line.long 0x00 "CHNENBL41,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x2a8++0x3
    line.long 0x00 "CHNENBL42,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x2ac++0x3
    line.long 0x00 "CHNENBL43,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x2b0++0x3
    line.long 0x00 "CHNENBL44,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x2b4++0x3
    line.long 0x00 "CHNENBL45,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x2b8++0x3
    line.long 0x00 "CHNENBL46,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x2bc++0x3
    line.long 0x00 "CHNENBL47,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."


tree.end



;--------------------------------------------------------------------------------
; SDMABP
;--------------------------------------------------------------------------------
tree "SDMABP"
    base ad:0x020ec000

width 7.
group.long 0x0++0x3
    line.long 0x00 "DC0PTR,Channel 0 Pointer"
        hexmask.long.long 0x00 0.--32. 1. " DC0PTR ,Channel 0 Pointer contains the 32-bit address, in BP memory, of the array of channel control blocks starting with the one for channel 0 (the control channel)."
width 5.
group.long 0x4++0x3
    line.long 0x00 "INTR,Channel Interrupts"
        hexmask.long.long 0x00 0.--32. 1. " DI ,The BP Interrupts register contains the 32 DI[i] bits."
width 10.
group.long 0x8++0x3
    line.long 0x00 "STOP_STAT,Channel Stop/Channel Status"
        hexmask.long.long 0x00 0.--32. 1. " DE ,This 32-bit register gives access to the BP (DSP) Enable bits, DE."
width 7.
rgroup.long 0xc++0x3
    line.long 0x00 "DSTART,Channel Start"
        hexmask.long.long 0x00 0.--32. 1. " DSTART_DE ,The DSTART_DE registers are 32 bits wide with one bit for every channel."
width 7.
rgroup.long 0x28++0x3
    line.long 0x00 "EVTERR,DMA Request Error Register"
        hexmask.long.long 0x00 0.--32. 1. " CHNERR ,This register is used by the SDMA to warn the BP when an incoming DMA request was detected; it then triggers a channel that is already pending or being serviced, which may mean there is an overflow of data for that channel."
width 9.
group.long 0x2c++0x3
    line.long 0x00 "INTRMASK,Channel DSP Interrupt Mask"
        hexmask.long.long 0x00 0.--32. 1. " DIMASK ,The Interrupt Mask Register contains 32 interrupt generation mask bits."
width 10.
rgroup.long 0x34++0x3
    line.long 0x00 "EVTERRDBG,DMA Request Error Register"
        hexmask.long.long 0x00 0.--32. 1. " CHNERR ,This register is the same as EVTERR except reading it does not clear its contents."


tree.end



;--------------------------------------------------------------------------------
; SDMACORE
;--------------------------------------------------------------------------------
tree "SDMACORE"
    base ad:0x020ec000

width 7.
rgroup.long 0x0++0x3
    line.long 0x00 "MC0PTR,ARM platform Channel 0 Pointer"
        hexmask.long.long 0x00 0.--32. 1. " MC0PTR ,Contains the address-in the ARM platform memory space-of the initial SDMA context and scripts that are loaded by the SDMA boot script running on channel 0."
width 6.
rgroup.long 0x2++0x3
    line.long 0x00 "CCPTR,Current Channel Pointer"
        hexmask.long.word 0x00 0.--16. 1. " CCPTR ,Contains the start address of the context data for the current channel: Its value is CONTEXT_BASE + 24* CCR or CONTEXT_BASE + 32* CCR where CONTEXT_BASE = 0x0800."
width 4.
rgroup.long 0x3++0x3
    line.long 0x00 "CCR,Current Channel Register"
        hexmask.long.byte 0x00 0.--5. 1. " CCR ,Contains the number of the current running channel whose context is installed."
width 4.
rgroup.long 0x4++0x3
    line.long 0x00 "NCR,Highest Pending Channel Register"
        hexmask.long.byte 0x00 0.--5. 1. " NCR ,Contains the number of the pending channel that the scheduler has selected to run next."
width 7.
rgroup.long 0x5++0x3
    line.long 0x00 "EVENTS,External DMA Requests Mirror"
        hexmask.long.long 0x00 0.--32. 1. " EVENTS ,Reflects the status of the SDMA's external DMA requests."
width 6.
rgroup.long 0x6++0x3
    line.long 0x00 "CCPRI,Current Channel Priority"
        hexmask.long.byte 0x00 0.--3. 1. " CCPRI ,Contains the 3-bit priority of the channel whose context is installed."
width 6.
rgroup.long 0x7++0x3
    line.long 0x00 "NCPRI,Next Channel Priority"
        hexmask.long.byte 0x00 0.--3. 1. " NCPRI ,Contains the 3-bit priority of the channel the scheduler has selected to run next."
width 7.
group.long 0x9++0x3
    line.long 0x00 "ECOUNT,OnCE Event Cell Counter"
        hexmask.long.word 0x00 0.--16. 1. " ECOUNT ,The event cell counter contains the number of times minus one that an event detection must occur before generating a debug request."
width 5.
group.long 0xa++0x3
    line.long 0x00 "ECTL,OnCE Event Cell Control Register"
        hexmask.long.byte 0x00 0.--2. 1. " ATS ,The access type select bits define the memory access type required on the SDMA memory bus."
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " AATC ,The Address A Trigger Condition (AATC) controls the operations performed by address comparator A."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ABTC ,The Address B Trigger Condition (ABTC) controls the operations performed by address comparator B."
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " ATC ,The address trigger condition bits select how the two address conditions (addressA and addressB) are combined to define the global address matching condition."
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " DTC ,The data trigger condition bits define when data is considered matching after comparison with the data register of the event detection unit."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ECTC ,The event cell trigger condition bits select the combination of address and data matching conditions that generate the final address/data condition."
        textline "    "
        bitfld.long 0x00 12. " CNT ,Event Counter Enable." "0,1"
        textline "    "
        bitfld.long 0x00 13. " EN ,Event Cell Enable." "0,1"
width 4.
group.long 0xb++0x3
    line.long 0x00 "EAA,OnCE Event Address Register A"
        hexmask.long.word 0x00 0.--16. 1. " EAA ,Event Cell Address Register A computes an address A condition."
width 4.
group.long 0xc++0x3
    line.long 0x00 "EAB,OnCE Event Cell Address Register B"
        hexmask.long.word 0x00 0.--16. 1. " EAB ,Event Cell Address Register B computes an address B condition."
width 4.
group.long 0xd++0x3
    line.long 0x00 "EAM,OnCE Event Cell Address Mask"
        hexmask.long.word 0x00 0.--16. 1. " EAM ,The Event Cell Address Mask contains a user-defined address mask value."
width 3.
group.long 0xe++0x3
    line.long 0x00 "ED,OnCE Event Cell Data Register"
        hexmask.long.long 0x00 0.--32. 1. " ED ,The event cell data register contains a user defined data value."
width 4.
group.long 0xf++0x3
    line.long 0x00 "EDM,OnCE Event Cell Data Mask"
        hexmask.long.long 0x00 0.--32. 1. " EDM ,The event cell data mask register contains the user-defined data mask value."
width 4.
group.long 0x18++0x3
    line.long 0x00 "RTB,OnCE Real-Time Buffer"
        hexmask.long.long 0x00 0.--32. 1. " RTB ,The Real Time Buffer register stores and retrieves run time information without putting the SDMA in debug mode."
width 3.
rgroup.long 0x19++0x3
    line.long 0x00 "TB,OnCE Trace Buffer"
        hexmask.long.word 0x00 0.--14. 1. " CHFADDR ,The change of flow address is the address where the change of flow is taken when executing a change of flow instruction."
        textline "  "
        hexmask.long.word 0x00 14.--28. 1. " TADDR ,The target address is the address taken after the execution of the change of flow instruction."
        textline "  "
        bitfld.long 0x00 28. " TBF ,The Trace Buffer Flag is set when the buffer contains the addresses of a valid change of flow." "0,1"
width 6.
rgroup.long 0x1a++0x3
    line.long 0x00 "OSTAT,OnCE Status"
        hexmask.long.byte 0x00 0.--3. 1. " ECDR ,Event Cell Debug Request."
        textline "     "
        bitfld.long 0x00 7. " MST ,This flag is raised when the OnCE is controlled from the ARM platform peripheral interface." "0,1"
        textline "     "
        bitfld.long 0x00 8. " SWB ,This flag is raised when the SDMA has entered debug mode after a software breakpoint." "0,1"
        textline "     "
        bitfld.long 0x00 9. " ODR ,This flag is raised when the SDMA has entered debug mode after a OnCE debug request." "0,1"
        textline "     "
        bitfld.long 0x00 10. " EDR ,This flag is raised when the SDMA has entered debug mode after an external debug request." "0,1"
        textline "     "
        bitfld.long 0x00 11. " RCV ,After each write access to the real time buffer (RTB), the RCV bit is set." "0,1"
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " PST ,The Processor Status bits reflect the state of the SDMA RISC engine."
width 10.
rgroup.long 0x1c++0x3
    line.long 0x00 "MCHN0ADDR,Channel 0 Boot Address"
        hexmask.long.word 0x00 0.--14. 1. " CHN0ADDR ,Contains the address of the channel 0 routine programmed by the ARM platform; it is loaded into a general register at the very start of the boot and the SDMA jumps to the address it contains."
        textline "         "
        bitfld.long 0x00 14. " SMSZ ,The bit 14 (Scratch Memory Size) determines if scratch memory must be available after every channel context." "0,1"
width 11.
rgroup.long 0x1d++0x3
    line.long 0x00 "ENDIANNESS,ENDIAN Status Register"
        bitfld.long 0x00 0. " APEND ,APEND indicates the endian mode of the Peripheral and Burst DMA interfaces." "0,1"
width 10.
rgroup.long 0x1e++0x3
    line.long 0x00 "SDMA_LOCK,Lock Status Register"
        bitfld.long 0x00 0. " LOCK ,The LOCK bit reports the value of the LOCK bit in the SDMA_LOCK status register." "0,1"
width 8.
rgroup.long 0x1f++0x3
    line.long 0x00 "EVENTS2,External DMA Requests Mirror #2"
        hexmask.long.word 0x00 0.--16. 1. " EVENTS ,Reflects the status of the SDMA's external DMA requests."


tree.end



;--------------------------------------------------------------------------------
; SJC
;--------------------------------------------------------------------------------
tree "SJC"
    base ad:0x00000000

width 7.
rgroup.long 0x0++0x3
    line.long 0x00 "GPUSR1,General Purpose Unsecured Status Register 1"
        bitfld.long 0x00 0. " A_DBG ,ARM core debug status bit Bit 0 is the ARM core DBGACK (debug acknowledge) DBGACK can be overwritten in the ARM core DCR to force a particular DBGACK value." "0,1"
        textline "      "
        bitfld.long 0x00 1. " A_WFI ,ARM core wait-for interrupt bit Bit 1 is the ARM core standbywfi (stand by wait-for interrupt)." "0,1"
        textline "      "
        hexmask.long.byte 0x00 2.--5. 1. " S_STAT ,3 LSBits of SDMA core statusH."
        textline "      "
        bitfld.long 0x00 8. " PLL_LOCK ,PLL_LOCK A Combined PLL-Lock flag indicator, for all the PLL's." "0,1"
width 7.
rgroup.long 0x1++0x3
    line.long 0x00 "GPUSR2,General Purpose Unsecured Status Register 2"
        hexmask.long.byte 0x00 0.--4. 1. " STBYWFI ,STBYWFI[3:0] These bits provide status of ""Standby Wait-For-Interrupt"" state of all ARM cores."
        textline "      "
        hexmask.long.byte 0x00 4.--8. 1. " S_STAT ,S_STAT[3:0] SDMA debug status bits: debug_core_state[3:0]"
        textline "      "
        hexmask.long.byte 0x00 8.--12. 1. " STBYWFE ,STBYWFE[3:0] Reflecting the ""Standby Wait For Event"" signals of all cores."
width 7.
rgroup.long 0x2++0x3
    line.long 0x00 "GPUSR3,General Purpose Unsecured Status Register 3"
        bitfld.long 0x00 0. " IPG_WAIT ,IPG_WAIT CCM's ""ipg_wait"" signal indication" "0,1"
        textline "      "
        bitfld.long 0x00 1. " IPG_STOP ,IPG_STOP CCM's ""ipg_stop"" signal indication" "0,1"
        textline "      "
        bitfld.long 0x00 2. " SYS_WAIT ,System In wait Indication on System in wait mode (from CCM)." "0,1"
width 6.
rgroup.long 0x3++0x3
    line.long 0x00 "GPSSR,General Purpose Secured Status Register"
        hexmask.long.long 0x00 0.--32. 1. " GPSSR ,General Purpose Secured Status Register Register is used for testing and debug."
width 4.
group.long 0x4++0x3
    line.long 0x00 "DCR,Debug Control Register"
        bitfld.long 0x00 0. " DE_TO_ARM ,ARM platform debug request input propagation This bit controls the propagation of debug request to ARM platform (""dbgreq""), when the JTAG state machine is put in ""ENTER_DEBUG"" IR instruction." "0,1"
        textline "   "
        bitfld.long 0x00 1. " DE_TO_SDMA ,SDMA debug request input propagation This bit controls the propagation of debug request to SDMA, when the JTAG state machine is put in ""ENTER_DEBUG"" IR instruction.." "0,1"
        textline "   "
        bitfld.long 0x00 3. " DEBUG_OBS ,Debug observability This bit controls the propagation of the ""system debug"" input to SJC For i.MX 6x, the SJC's ""system_debug"" input is tied to logic HIGH value, therefore, set of ""debug_obs"" bit, will result in unconditional assertion of DE_B pad." "0,1"
        textline "   "
        bitfld.long 0x00 5. " DIRECT_SDMA_REQ_EN ,Debug enable of the sdma debug request This bit controls the propagation of debug request DE_B to the sdma." "0,1"
        textline "   "
        bitfld.long 0x00 6. " DIRECT_ARM_REQ_EN ,Pass Debug Enable event from DE_B pin to ARM platform debug request signal(s)." "0,1"
width 4.
rgroup.long 0x5++0x3
    line.long 0x00 "SSR,Security Status Register"
        bitfld.long 0x00 0. " KTF ,Kill Trace Enable fuse value" "0,1"
        textline "   "
        bitfld.long 0x00 1. " KTA ,Kill Trace is active" "0,1"
        textline "   "
        bitfld.long 0x00 2. " SWF ,Software JTAG enable fuse Status of the no SW disable JTAG fuse" "0,1"
        textline "   "
        bitfld.long 0x00 3. " SWE ,SW enable SW JTAG enable status" "0,1"
        textline "   "
        bitfld.long 0x00 4. " EBF ,External Boot fuse Status of the external boot disable fuse" "0,1"
        textline "   "
        bitfld.long 0x00 5. " EBG ,External boot granted External boot enabled, requested and granted" "0,1"
        textline "   "
        bitfld.long 0x00 8. " FT ,Fuse type Fuse type bit - e-fuse or laser fuse" "0,1"
        textline "   "
        hexmask.long.byte 0x00 9.--11. 1. " SJM ,SJC Secure mode Secure JTAG mode, as set by external fuses."
        textline "   "
        hexmask.long.byte 0x00 11.--13. 1. " RSSTAT ,Response status Response status bits"
        textline "   "
        bitfld.long 0x00 14. " BOOTIND ,Boot Indication Inverted Internal Boot indication, i.e inverse of SRC: ""src_int_boot"" signal" "0,1"
width 6.
group.long 0x7++0x3
    line.long 0x00 "GPCCR,General Purpose Clocks Control Register"
        bitfld.long 0x00 0. " SCLKR ,SDMA Clock ON Register - This bit forces the clock on of the SDMA" "0,1"
        textline "     "
        bitfld.long 0x00 1. " ACLKOFFDIS ,Disable/prevent ARM platform clock/power shutdown" "0,1"


tree.end



;--------------------------------------------------------------------------------
; SNVS
;--------------------------------------------------------------------------------
tree "SNVS"
    base ad:0x020cc000

width 5.
group.long 0x0++0x3
    line.long 0x00 "HPLR,SNVS _HP Lock Register"
        bitfld.long 0x00 0. " ZMK_WSL ,Zeroizable Master Key Write Soft Lock When set, prevents any writes (software and hardware) to the ZMK registers and MASTER_KEY_SEL, ZMK_HWP, ZMK_VAL, and ZMK_ECC_EN fields of the LPMKCR." "0,1"
        textline "    "
        bitfld.long 0x00 1. " ZMK_RSL ,Zeroizable Master Key Read Soft Lock When set, prevents any software reads to the ZMK Registers and ZMK_ECC_VALUE field of the LPMKCR." "0,1"
        textline "    "
        bitfld.long 0x00 2. " SRTC_SL ,Secure Real Time Counter Soft Lock When set, prevents any writes to the SRTC Registers, SRTC_ENV, and SRTC_INV_EN bits." "0,1"
        textline "    "
        bitfld.long 0x00 3. " LPCALB_SL ,LP Calibration Soft Lock When set, prevents any writes to the LP Calibration Value (LPCALB_VAL) and LP Calibration Enable (LPCALB_EN)." "0,1"
        textline "    "
        bitfld.long 0x00 4. " MC_SL ,Monotonic Counter Soft Lock When set, prevents any writes (increments) to the MC Registers and MC_ENV bit." "0,1"
        textline "    "
        bitfld.long 0x00 5. " GPR_SL ,General Purpose Register Soft Lock When set, prevents any writes to the GPR." "0,1"
        textline "    "
        bitfld.long 0x00 6. " LPSVCR_SL ,LP Security Violation Control Register Soft Lock When set, prevents any writes to the LPSVCR." "0,1"
        textline "    "
        bitfld.long 0x00 7. " LPTGFCR_SL ,LP Tamper Glitch Filter Configuration Register Soft Lock When set, prevents any writes to the LPTGFCR." "0,1"
        textline "    "
        bitfld.long 0x00 8. " LPTDCR_SL ,LP Tamper Detectors Configuration Register Soft Lock When set, prevents any writes to the LPTDCR." "0,1"
        textline "    "
        bitfld.long 0x00 9. " MKS_SL ,Master Key Select Soft Lock When set, prevents any writes to the MASTER_KEY_SEL field of the LPMKCR." "0,1"
        textline "    "
        bitfld.long 0x00 16. " HPSVCR_L ,HP Security Violation Control Register Lock When set, prevents any writes to the HPSVCR." "0,1"
        textline "    "
        bitfld.long 0x00 17. " HPSICR_L ,HP Security Interrupt Control Register Lock When set, prevents any writes to the HPSICR." "0,1"
        textline "    "
        bitfld.long 0x00 18. " HAC_L ,High Assurance Configuration Lock When set, prevents any writes to HPHACIVR, HPHACR, and HAC_EN bit of HPCOMR." "0,1"
width 7.
group.long 0x4++0x3
    line.long 0x00 "HPCOMR,SNVS _HP Command Register"
        bitfld.long 0x00 0. " SSM_ST ,SSM State Transition Transition state of the system security monitor." "0,1"
        textline "      "
        bitfld.long 0x00 1. " SSM_ST_DIS ,SSM Secure to Trusted State Transition Disable When set, disables the SSM transition from secure to trusted state." "0,1"
        textline "      "
        bitfld.long 0x00 2. " SSM_SFNS_DIS ,SSM Soft Fail to Non-Secure State Transition Disable When set, it disables the SSM transition from soft fail to non-secure state." "0,1"
        textline "      "
        bitfld.long 0x00 4. " LP_SWR ,LP Software Reset When set, it resets the SNVS _LP section." "0,1"
        textline "      "
        bitfld.long 0x00 5. " LP_SWR_DIS ,LP Software Reset Disable When set, disables the LP software reset." "0,1"
        textline "      "
        bitfld.long 0x00 8. " SW_SV ,Software Security Violation When set, the system security monitor treats this bit as a non-fatal security violation." "0,1"
        textline "      "
        bitfld.long 0x00 9. " SW_FSV ,Software Fatal Security Violation When set, the system security monitor treats this bit as a fatal security violation." "0,1"
        textline "      "
        bitfld.long 0x00 10. " SW_LPSV ,LP Software Security Violation When set, SNVS _LP treats this bit as a security violation." "0,1"
        textline "      "
        bitfld.long 0x00 12. " PROG_ZMK ,Program Zeroizable Master Key This bit activates ZMK hardware programming mechanism." "0,1"
        textline "      "
        bitfld.long 0x00 13. " MKS_EN ,Master Key Select Enable When not set, the one time programmable (OTP) master key is selected by default." "0,1"
        textline "      "
        bitfld.long 0x00 16. " HAC_EN ,High Assurance Configuration Enable This bit controls the SSM transition from the soft fail to the hard fail state." "0,1"
        textline "      "
        bitfld.long 0x00 17. " HAC_LOAD ,High Assurance Counter Load When set, it loads the High Assurance Counter Register with the value of the High Assurance Counter Load Register." "0,1"
        textline "      "
        bitfld.long 0x00 18. " HAC_CLEAR ,High Assurance Counter Clear When set, it clears the High Assurance Counter Register." "0,1"
        textline "      "
        bitfld.long 0x00 19. " HAC_STOP ,High Assurance Counter Stop This bit can be set only when SSM is in soft fail state." "0,1"
        textline "      "
        bitfld.long 0x00 31. " NPSWA_EN ,Non-Privileged Software Access Enable When set, allows non-privileged software to access all SNVS registers, including those that are privileged software read/write access only." "0,1"
width 5.
group.long 0x8++0x3
    line.long 0x00 "HPCR,SNVS_HP Control Register"
        bitfld.long 0x00 0. " RTC_EN ,HP Real Time Counter Enable" "0,1"
        textline "    "
        bitfld.long 0x00 1. " HPTA_EN ,HP Time Alarm Enable When set, the time alarm interrupt is generated if the value in the HP Time Alarm Registers is equal to the value of the HP Real Time Counter." "0,1"
        textline "    "
        bitfld.long 0x00 3. " PI_EN ,HP Periodic Interrupt Enable The periodic interrupt can be generated only if the HP Real Time Counter is enabled." "0,1"
        textline "    "
        hexmask.long.byte 0x00 4.--8. 1. " PI_FREQ ,Periodic Interrupt Frequency Defines frequency of the periodic interrupt."
        textline "    "
        bitfld.long 0x00 8. " HPCALB_EN ,HP Real Time Counter Calibration Enabled Indicates that the time calibration mechanism is enabled." "0,1"
        textline "    "
        hexmask.long.byte 0x00 10.--15. 1. " HPCALB_VAL ,HP Calibration Value Defines signed calibration value for the HP Real Time Counter."
        textline "    "
        bitfld.long 0x00 16. " HP_TS ,HP Time Synchronize When set, this updates the HP Time Counter with the LP Time Counter value." "0,1"
width 7.
group.long 0xc++0x3
    line.long 0x00 "HPSICR,SNVS _HP Security Interrupt Control Register"
        bitfld.long 0x00 0. " SVI_EN0 ,Security Violation Interrupt 0 Enable This bit enables generation of the security interrupt to the host processor upon security violation detection on input port 0." "0,1"
        textline "      "
        bitfld.long 0x00 1. " SVI_EN1 ,Security Violation Interrupt 1 Enable This bit enables generation of the security interrupt to the host processor upon security violation detection on input port 1." "0,1"
        textline "      "
        bitfld.long 0x00 2. " SVI_EN2 ,Security Violation Interrupt 2 Enable This bit enables generation of the security interrupt to the host processor upon security violation detection on input port 2." "0,1"
        textline "      "
        bitfld.long 0x00 3. " SVI_EN3 ,Security Violation Interrupt 3 Enable This bit enables generation of the security interrupt to the host processor upon security violation detection on input port 3." "0,1"
        textline "      "
        bitfld.long 0x00 4. " SVI_EN4 ,Security Violation Interrupt 4 Enable This bit enables generation of the security interrupt to the host processor upon security violation detection on input port 4." "0,1"
        textline "      "
        bitfld.long 0x00 5. " SVI_EN5 ,Security Violation Interrupt 5 Enable This bit enables generation of the security interrupt to the host processor upon security violation detection on input port 5." "0,1"
        textline "      "
        bitfld.long 0x00 31. " LPSVI_EN ,LP Security Violation Interrupt Enable This bit enables generating of the security interrupt to the host processor upon security violation signal from the LP section." "0,1"
width 7.
group.long 0x10++0x3
    line.long 0x00 "HPSVCR,SNVS _HP Security Violation Control Register"
        bitfld.long 0x00 0. " SV_CFG0 ,Security Violation Input 0 Configuration This field configures the security violation input 0." "0,1"
        textline "      "
        bitfld.long 0x00 1. " SV_CFG1 ,Security Violation Input 1 Configuration This field configures the Security Violation Input 1." "0,1"
        textline "      "
        bitfld.long 0x00 2. " SV_CFG2 ,Security Violation Input 2 Configuration This field configures the security violation input 2." "0,1"
        textline "      "
        bitfld.long 0x00 3. " SV_CFG3 ,Security Violation Input 3 Configuration This field configures the security violation input 3." "0,1"
        textline "      "
        bitfld.long 0x00 4. " SV_CFG4 ,Security Violation Input 4 Configuration This field configures the security violation Input 4." "0,1"
        textline "      "
        hexmask.long.byte 0x00 5.--7. 1. " SV_CFG5 ,Security Violation Input 5 Configuration This field configures the Security Violation Input 5."
        textline "      "
        hexmask.long.byte 0x00 30.--32. 1. " LPSV_CFG ,LP Security Violation Configuration This field configures the LP security violation source."
width 5.
group.long 0x14++0x3
    line.long 0x00 "HPSR,SNVS _HP Status Register"
        bitfld.long 0x00 0. " HPTA ,HP Time Alarm Indicates that the HP Time Alarm has occurred since this bit was last cleared." "0,1"
        textline "    "
        bitfld.long 0x00 1. " PI ,Periodic Interrupt Indicates that periodic interrupt has occurred since this bit was last cleared." "0,1"
        textline "    "
        bitfld.long 0x00 4. " LPDIS ,Low Power Disable If 1, the SNVS low power section has been disabled by means of an input signal to the SNVS ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 8.--12. 1. " SSM_ST ,System Security Monitor State This field contains the encoded state of the SSM's state machine."
        textline "    "
        hexmask.long.byte 0x00 12.--15. 1. " SYS_SECURITY_CFG ,This field reflects the value of the sys_security_cfg input signal, which is defined as follows:"
        textline "    "
        bitfld.long 0x00 15. " SYS_SECURE_BOOT ,This bit reflects the value of the sys_secure_boot input signal to SNVS ." "0,1"
        textline "    "
        hexmask.long.word 0x00 16.--25. 1. " OTPMK_SYNDROME ,One Time Programmable Master Key Syndrome Value The eight lower bits of this value indicate error location in case of a single-bit error."
        textline "    "
        bitfld.long 0x00 27. " OTPMK_ZERO ,One Time Programmable Master Key is Equal to Zero." "0,1"
        textline "    "
        bitfld.long 0x00 31. " ZMK_ZERO ,Zeroizable Master Key is Equal to Zero." "0,1"
width 7.
group.long 0x18++0x3
    line.long 0x00 "HPSVSR,SNVS _HP Security Violation Status Register"
        bitfld.long 0x00 0. " SEC_VIO0 ,Security violation on input 0 is detected." "0,1"
        textline "      "
        bitfld.long 0x00 1. " SEC_VIO1 ,Security violation on input 1 is detected." "0,1"
        textline "      "
        bitfld.long 0x00 2. " SEC_VIO2 ,Security violation on input 2 is detected." "0,1"
        textline "      "
        bitfld.long 0x00 3. " SEC_VIO3 ,Security violation on input 3 is detected." "0,1"
        textline "      "
        bitfld.long 0x00 4. " SEC_VIO4 ,Security violation on input 4 is detected." "0,1"
        textline "      "
        bitfld.long 0x00 5. " SEC_VIO5 ,Security volation on input 5 is detected." "0,1"
        textline "      "
        hexmask.long.word 0x00 16.--25. 1. " ZMK_SYNDROME ,Zeroizable Master Key Syndrome Value The ZMK syndrome indicates error location and parity similar to the OTPMK syndrome ."
        textline "      "
        bitfld.long 0x00 27. " ZMK_ECC_FAIL ,Zeroizable Master Key Error Correcting Code Check Failure When set, this bit triggers a bad key violation to the SSM and a security violation to the SNVS _LP section, which clears security sensitive data." "0,1"
width 9.
group.long 0x1c++0x3
    line.long 0x00 "HPHACIVR,SNVS _HP High Assurance Counter IV Register"
        hexmask.long.long 0x00 0.--32. 1. " HAC_COUNTER_IV ,High Assurance Counter Initial Value This register is used to set the starting count value to the high assurance counter."
width 7.
group.long 0x20++0x3
    line.long 0x00 "HPHACR,SNVS _HP High Assurance Counter Register"
        hexmask.long.long 0x00 0.--32. 1. " HAC_COUNTER ,High Assurance Counter When the HAC_EN bit is set and the SSM is in the soft fail state, this counter starts to count down with the system clock."
width 8.
group.long 0x24++0x3
    line.long 0x00 "HPRTCMR,SNVS_HP Real Time Counter MSB Register"
        hexmask.long.word 0x00 0.--15. 1. " RTC ,HP Real Time Counter Most significant 15 bits."
width 8.
group.long 0x28++0x3
    line.long 0x00 "HPRTCLR,SNVS_HP Real Time Counter LSB Register"
        hexmask.long.long 0x00 0.--32. 1. " RTC ,HP Real Time Counter Least significant 32 bits."
width 7.
group.long 0x2c++0x3
    line.long 0x00 "HPTAMR,SNVS_HP Time Alarm MSB Register"
        hexmask.long.word 0x00 0.--15. 1. " HPTA ,HP Time Alarm Most significant 15 bits."
width 7.
group.long 0x30++0x3
    line.long 0x00 "HPTALR,SNVS_HP Time Alarm LSB Register"
        hexmask.long.long 0x00 0.--32. 1. " HPTA ,HP Time Alarm Least significant bits."
width 5.
group.long 0x34++0x3
    line.long 0x00 "LPLR,SNVS _LP Lock Register"
        bitfld.long 0x00 0. " ZMK_WHL ,Zeroizable Master Key Write Hard Lock When set, prevents any writes (software and hardware) to the ZMK registers and ZMK_HWP, ZMK_VAL, and ZMK_ECC_EN fields of the LPMKCR." "0,1"
        textline "    "
        bitfld.long 0x00 1. " ZMK_RHL ,Zeroizable Master Key Read Hard Lock When set, prevents any software reads to the ZMK registers and ZMK_ECC_VALUE field of the LPMKCR." "0,1"
        textline "    "
        bitfld.long 0x00 2. " SRTC_HL ,Secure Real Time Counter Hard Lock When set, prevents any writes to the SRTC registers, SRTC_ENV, and SRTC_INV_EN bits." "0,1"
        textline "    "
        bitfld.long 0x00 3. " LPCALB_HL ,LP Calibration Hard Lock When set, prevents any writes to the LP Calibration Value (LPCALB_VAL) and LP Calibration Enable (LPCALB_EN)." "0,1"
        textline "    "
        bitfld.long 0x00 4. " MC_HL ,Monotonic Counter Hard Lock When set, prevents any writes (increments) to the MC Registers and MC_ENV bit." "0,1"
        textline "    "
        bitfld.long 0x00 5. " GPR_HL ,General Purpose Register Hard Lock When set, prevents any writes to the GPR." "0,1"
        textline "    "
        bitfld.long 0x00 6. " LPSVCR_HL ,LP Security Violation Control Register Hard Lock When set, prevents any writes to the LPSVCR." "0,1"
        textline "    "
        bitfld.long 0x00 7. " LPTGFCR_HL ,LP Tamper Glitch Filter Configuration Register Hard Lock When set, prevents any writes to the LPTGFCR." "0,1"
        textline "    "
        bitfld.long 0x00 8. " LPTDCR_HL ,LP Tamper Detectors Configuration Register Hard Lock When set, prevents any writes to the LPTDCR." "0,1"
        textline "    "
        bitfld.long 0x00 9. " MKS_HL ,Master Key Select Hard Lock When set, prevents any writes to the MASTER_KEY_SEL field of the LP Master Key Control Register." "0,1"
width 5.
group.long 0x38++0x3
    line.long 0x00 "LPCR,SNVS_LP Control Register"
        bitfld.long 0x00 0. " SRTC_ENV ,Secure Real Time Counter Enable and Valid When set, the SRTC becomes operational." "0,1"
        textline "    "
        bitfld.long 0x00 1. " LPTA_EN ,LP Time Alarm Enable When set, the SNVS functional interrupt is asserted if the LP Time Alarm Register is equal to the 32 MSBs of the secure real time counter." "0,1"
        textline "    "
        bitfld.long 0x00 2. " MC_ENV ,Monotonic Counter Enable and Valid When set, the MC can be incremented (by write transaction to the LPSMCMR or LPSMCLR)." "0,1"
        textline "    "
        bitfld.long 0x00 3. " LPWUI_EN ,LP Wake-Up Interrupt Enable This interrupt line should be connected to the external pin and is intended to inform the external chip about an SNVS _LP event (tamper event, MC rollover, SRTC rollover, or time alarm )." "0,1"
        textline "    "
        bitfld.long 0x00 4. " SRTC_INV_EN ,Secure Real Time Counter Invalidation Enable When set, the SRTC is invalidated (SRTC_ENV bit is cleared) in the case of security violation." "0,1"
        textline "    "
        bitfld.long 0x00 5. " DP_EN ,Dumb PMIC Enabled" "0,1"
        textline "    "
        bitfld.long 0x00 6. " TOP ,Turn of System Power Asserting this bit causes a signal to be sent to the Power Management IC to turn off the system power." "0,1"
        textline "    "
        bitfld.long 0x00 8. " LPCALB_EN ,LP Calibration Enable When set, enables the SRTC calibration mechanism." "0,1"
        textline "    "
        hexmask.long.byte 0x00 10.--15. 1. " LPCALB_VAL ,LP Calibration Value Defines signed calibration value for SRTC."
width 7.
group.long 0x3c++0x3
    line.long 0x00 "LPMKCR,SNVS_LP Master Key Control Register"
        hexmask.long.byte 0x00 0.--2. 1. " MASTER_KEY_SEL ,Master Key Select These bits select the SNVS Master Key output when Master Key Select bits are enabled by MKS_EN bit in the HPCOMR ."
        textline "      "
        bitfld.long 0x00 2. " ZMK_HWP ,Zeroizable Master Key hardware Programming mode When set, only the hardware key programming mechanism can set the ZMK and software cannot read it." "0,1"
        textline "      "
        bitfld.long 0x00 3. " ZMK_VAL ,Zeroizable Master Key Valid When set, the ZMK value can be selected by the master key control block for use by cryptographic modules." "0,1"
        textline "      "
        bitfld.long 0x00 4. " ZMK_ECC_EN ,Zeroizable Master Key Error Correcting Code Check Enable Writing one to this field automatically calculates and sets the ZMK ECC value in the ZMK_ECC_VALUE field of this register." "0,1"
        textline "      "
        hexmask.long.word 0x00 7.--16. 1. " ZMK_ECC_VALUE ,Zeroizable Master Key Error Correcting Code Value This field is automatically calculated and set when one is written into ZMK_ECC_EN bit of this register."
width 7.
group.long 0x40++0x3
    line.long 0x00 "LPSVCR,SNVS_LP Security Violation Control Register"
        bitfld.long 0x00 0. " SV_EN0 ,Security Violation 0 Enable This bit enables security violation input 0." "0,1"
        textline "      "
        bitfld.long 0x00 1. " SV_EN1 ,Security Violation 1 Enable This bit enables security violation input 1." "0,1"
        textline "      "
        bitfld.long 0x00 2. " SV_EN2 ,Security Violation 2 Enable This bit enables security violation input 2." "0,1"
        textline "      "
        bitfld.long 0x00 3. " SV_EN3 ,Security Violation 3 Enable This bit enables security violation input 3." "0,1"
        textline "      "
        bitfld.long 0x00 4. " SV_EN4 ,Security Violation 4 Enable This bit enables security violation input 4." "0,1"
        textline "      "
        bitfld.long 0x00 5. " SV_EN5 ,Security Violation 5 Enable This bit enables security violation input 5." "0,1"
width 8.
group.long 0x44++0x3
    line.long 0x00 "LPTGFCR,SNVS_LP Tamper Glitch Filters Configuration Register"
        hexmask.long.byte 0x00 16.--21. 1. " ETGF1 ,External Tamper Glitch Filter 1 Configures the length of the digital glitch filter for the external tamper 1 pin between 128 and 8064 SRTC clock cycles."
        textline "       "
        bitfld.long 0x00 23. " ETGF1_EN ,External Tamper Glitch Filter 1 Enable When set, enables the external tamper glitch filter 1." "0,1"
width 7.
group.long 0x48++0x3
    line.long 0x00 "LPTDCR,SNVS_LP Tamper Detectors Configuration Register"
        bitfld.long 0x00 1. " SRTCR_EN ,SRTC Rollover Enable When set, an SRTC rollover event generates an LP security violation." "0,1"
        textline "      "
        bitfld.long 0x00 2. " MCR_EN ,MC Rollover Enable When set, an MC Rollover event generates an LP security violation." "0,1"
        textline "      "
        bitfld.long 0x00 9. " ET1_EN ,External Tampering 1 Enable When set, external tampering 1 detection generates an LP security violation." "0,1"
        textline "      "
        bitfld.long 0x00 14. " PFD_OBSERV ,System Power Fail Detector (PFD) Observability Flop The asynchronous reset input of this flop is connected directly to the inverted output of the PFD analog circuitry (external to the SNVS block)." "0,1"
        textline "      "
        bitfld.long 0x00 15. " POR_OBSERV ,Power On Reset (POR) Observability Flop The asynchronous reset input of this flop is connected directly to the output of the POR analog circuitry (external to the SNVS block)." "0,1"
width 5.
group.long 0x4c++0x3
    line.long 0x00 "LPSR,SNVS _LP Status Register"
        bitfld.long 0x00 0. " LPTA ,LP Time Alarm." "0,1"
        textline "    "
        bitfld.long 0x00 1. " SRTCR ,Secure Real Time Counter Rollover." "0,1"
        textline "    "
        bitfld.long 0x00 2. " MCR ,Monotonic Counter Rollover." "0,1"
        textline "    "
        bitfld.long 0x00 3. " PGD ,Power Supply Glitch Detected." "0,1"
        textline "    "
        bitfld.long 0x00 9. " ET1D ,External Tampering 1 Detected." "0,1"
        textline "    "
        bitfld.long 0x00 16. " ESVD ,External Security Violation Detected Indicates that a security violation is detected on one of the HP security violation ports." "0,1"
        textline "    "
        bitfld.long 0x00 17. " EO ,Emergency Off This bit is set when a power off is requested." "0,1"
        textline "    "
        bitfld.long 0x00 18. " SPO ,Set Power Off This bit is set when power off was requested by a button press, but the button was not pressed for 5 seconds." "0,1"
        textline "    "
        bitfld.long 0x00 20. " SED ,Scan Exit Detected" "0,1"
        textline "    "
        bitfld.long 0x00 30. " LPNS ,LP Section is Non-Secured Indicates that LP section was provisioned/programmed in the non-secure state." "0,1"
        textline "    "
        bitfld.long 0x00 31. " LPS ,LP Section is Secured Indicates that the LP section is provisioned/programmed in the secure or trusted state." "0,1"
width 9.
group.long 0x50++0x3
    line.long 0x00 "LPSRTCMR,SNVS_LP Secure Real Time Counter MSB Register"
        hexmask.long.word 0x00 0.--15. 1. " SRTC ,LP Secure Real Time Counter most significant 15 bits This register can be programmed only when SRTC is not active and not locked, meaning the SRTC_ENV, SRTC_SL, and SRTC_HL bits are not set."
width 9.
group.long 0x54++0x3
    line.long 0x00 "LPSRTCLR,SNVS_LP Secure Real Time Counter LSB Register"
        hexmask.long.long 0x00 0.--32. 1. " SRTC ,LP Secure Real Time Counter least significant 32 bits This register can be programmed only when SRTC is not active and not locked, meaning the SRTC_ENV, SRTC_SL, and SRTC_HL bits are not set."
width 6.
group.long 0x58++0x3
    line.long 0x00 "LPTAR,SNVS_LP Time Alarm Register"
        hexmask.long.long 0x00 0.--32. 1. " LPTA ,LP Time Alarm This register can be programmed only when the LP time alarm is disabled (LPTA_EN bit is not set)."
width 8.
group.long 0x5c++0x3
    line.long 0x00 "LPSMCMR,SNVS_LP Secure Monotonic Counter MSB Register"
        hexmask.long.word 0x00 0.--16. 1. " MON_COUNTER ,Monotonic Counter Most Significant 16 Bits The MC is incremented by one when: A write transaction to the LPSMCMR or LPSMCLR register is detected."
        textline "       "
        hexmask.long.word 0x00 16.--32. 1. " MC_ERA_BITS ,Monotonic Counter Era Bits These bits are inputs to the module and typically connect to fuses."
width 8.
group.long 0x60++0x3
    line.long 0x00 "LPSMCLR,SNVS_LP Secure Monotonic Counter LSB Register"
        hexmask.long.long 0x00 0.--32. 1. " MON_COUNTER ,Monotonic Counter bits The MC is incremented by one when: A write transaction to the LPSMCMR or LPSMCLR Register is detected."
width 7.
group.long 0x64++0x3
    line.long 0x00 "LPPGDR,SNVS _LP Power Glitch Detector Register"
        hexmask.long.long 0x00 0.--32. 1. " PGD ,Power Glitch Detector Value"
width 6.
group.long 0x68++0x3
    line.long 0x00 "LPGPR,SNVS_LP General Purpose Register"
        hexmask.long.long 0x00 0.--32. 1. " GPR ,General Purpose Register When GPR_SL or GPR_HL bit is set, the register cannot be programmed."
width 8.
group.long 0x6c++0x3
    line.long 0x00 "LPZMKR0,SNVS_LP Zeroizable Master Key Register n"
        hexmask.long.long 0x00 0.--32. 1. " ZMK ,Zeroizable Master Key Each of these registers contains part of the 256-bit ZMK value: LPZMKR0 - ZMK[ 31-0 ] LPZMKR1 - ZMK[ 63-32 ] LPZMKR2 - ZMK[ 95-64 ] LPZMKR3 - ZMK[ 127-96 ] LPZMKR4 - ZMK[ 159-128 ] LPZMKR5 - ZMK[ 191-160 ] LPZMKR6 - ZMK[ 223-192 ] LPZMKR7 - ZMK[ 255-224 ]"
width 8.
group.long 0x70++0x3
    line.long 0x00 "LPZMKR1,SNVS_LP Zeroizable Master Key Register n"
        hexmask.long.long 0x00 0.--32. 1. " ZMK ,Zeroizable Master Key Each of these registers contains part of the 256-bit ZMK value: LPZMKR0 - ZMK[ 31-0 ] LPZMKR1 - ZMK[ 63-32 ] LPZMKR2 - ZMK[ 95-64 ] LPZMKR3 - ZMK[ 127-96 ] LPZMKR4 - ZMK[ 159-128 ] LPZMKR5 - ZMK[ 191-160 ] LPZMKR6 - ZMK[ 223-192 ] LPZMKR7 - ZMK[ 255-224 ]"
width 8.
group.long 0x74++0x3
    line.long 0x00 "LPZMKR2,SNVS_LP Zeroizable Master Key Register n"
        hexmask.long.long 0x00 0.--32. 1. " ZMK ,Zeroizable Master Key Each of these registers contains part of the 256-bit ZMK value: LPZMKR0 - ZMK[ 31-0 ] LPZMKR1 - ZMK[ 63-32 ] LPZMKR2 - ZMK[ 95-64 ] LPZMKR3 - ZMK[ 127-96 ] LPZMKR4 - ZMK[ 159-128 ] LPZMKR5 - ZMK[ 191-160 ] LPZMKR6 - ZMK[ 223-192 ] LPZMKR7 - ZMK[ 255-224 ]"
width 8.
group.long 0x78++0x3
    line.long 0x00 "LPZMKR3,SNVS_LP Zeroizable Master Key Register n"
        hexmask.long.long 0x00 0.--32. 1. " ZMK ,Zeroizable Master Key Each of these registers contains part of the 256-bit ZMK value: LPZMKR0 - ZMK[ 31-0 ] LPZMKR1 - ZMK[ 63-32 ] LPZMKR2 - ZMK[ 95-64 ] LPZMKR3 - ZMK[ 127-96 ] LPZMKR4 - ZMK[ 159-128 ] LPZMKR5 - ZMK[ 191-160 ] LPZMKR6 - ZMK[ 223-192 ] LPZMKR7 - ZMK[ 255-224 ]"
width 8.
group.long 0x7c++0x3
    line.long 0x00 "LPZMKR4,SNVS_LP Zeroizable Master Key Register n"
        hexmask.long.long 0x00 0.--32. 1. " ZMK ,Zeroizable Master Key Each of these registers contains part of the 256-bit ZMK value: LPZMKR0 - ZMK[ 31-0 ] LPZMKR1 - ZMK[ 63-32 ] LPZMKR2 - ZMK[ 95-64 ] LPZMKR3 - ZMK[ 127-96 ] LPZMKR4 - ZMK[ 159-128 ] LPZMKR5 - ZMK[ 191-160 ] LPZMKR6 - ZMK[ 223-192 ] LPZMKR7 - ZMK[ 255-224 ]"
width 8.
group.long 0x80++0x3
    line.long 0x00 "LPZMKR5,SNVS_LP Zeroizable Master Key Register n"
        hexmask.long.long 0x00 0.--32. 1. " ZMK ,Zeroizable Master Key Each of these registers contains part of the 256-bit ZMK value: LPZMKR0 - ZMK[ 31-0 ] LPZMKR1 - ZMK[ 63-32 ] LPZMKR2 - ZMK[ 95-64 ] LPZMKR3 - ZMK[ 127-96 ] LPZMKR4 - ZMK[ 159-128 ] LPZMKR5 - ZMK[ 191-160 ] LPZMKR6 - ZMK[ 223-192 ] LPZMKR7 - ZMK[ 255-224 ]"
width 8.
group.long 0x84++0x3
    line.long 0x00 "LPZMKR6,SNVS_LP Zeroizable Master Key Register n"
        hexmask.long.long 0x00 0.--32. 1. " ZMK ,Zeroizable Master Key Each of these registers contains part of the 256-bit ZMK value: LPZMKR0 - ZMK[ 31-0 ] LPZMKR1 - ZMK[ 63-32 ] LPZMKR2 - ZMK[ 95-64 ] LPZMKR3 - ZMK[ 127-96 ] LPZMKR4 - ZMK[ 159-128 ] LPZMKR5 - ZMK[ 191-160 ] LPZMKR6 - ZMK[ 223-192 ] LPZMKR7 - ZMK[ 255-224 ]"
width 8.
group.long 0x88++0x3
    line.long 0x00 "LPZMKR7,SNVS_LP Zeroizable Master Key Register n"
        hexmask.long.long 0x00 0.--32. 1. " ZMK ,Zeroizable Master Key Each of these registers contains part of the 256-bit ZMK value: LPZMKR0 - ZMK[ 31-0 ] LPZMKR1 - ZMK[ 63-32 ] LPZMKR2 - ZMK[ 95-64 ] LPZMKR3 - ZMK[ 127-96 ] LPZMKR4 - ZMK[ 159-128 ] LPZMKR5 - ZMK[ 191-160 ] LPZMKR6 - ZMK[ 223-192 ] LPZMKR7 - ZMK[ 255-224 ]"
width 8.
rgroup.long 0xbf8++0x3
    line.long 0x00 "HPVIDR1,SNVS _HP Version ID Register 1"
        hexmask.long.byte 0x00 0.--8. 1. " MINOR_REV ,SNVS block minor version number"
        textline "       "
        hexmask.long.byte 0x00 8.--16. 1. " MAJOR_REV ,SNVS block major version number"
        textline "       "
        hexmask.long.word 0x00 16.--32. 1. " IP_ID ,SNVS block ID"
width 8.
rgroup.long 0xbfc++0x3
    line.long 0x00 "HPVIDR2,SNVS _HP Version ID Register 2"
        hexmask.long.byte 0x00 0.--8. 1. " CONFIG_OPT ,SNVS Configuration Option"
        textline "       "
        hexmask.long.byte 0x00 8.--16. 1. " ECO_REV ,SNVS ECO Revision"
        textline "       "
        hexmask.long.byte 0x00 16.--24. 1. " INTG_OPT ,SNVS Integration Option"


tree.end



;--------------------------------------------------------------------------------
; SPBA
;--------------------------------------------------------------------------------
tree "SPBA"
    base ad:0x0203c000

width 5.
group.long 0x0++0x3
    line.long 0x00 "PRR0,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 5.
group.long 0x4++0x3
    line.long 0x00 "PRR1,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 5.
group.long 0x8++0x3
    line.long 0x00 "PRR2,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 5.
group.long 0xc++0x3
    line.long 0x00 "PRR3,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 5.
group.long 0x10++0x3
    line.long 0x00 "PRR4,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 5.
group.long 0x14++0x3
    line.long 0x00 "PRR5,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 5.
group.long 0x18++0x3
    line.long 0x00 "PRR6,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 5.
group.long 0x1c++0x3
    line.long 0x00 "PRR7,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 5.
group.long 0x20++0x3
    line.long 0x00 "PRR8,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 5.
group.long 0x24++0x3
    line.long 0x00 "PRR9,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x28++0x3
    line.long 0x00 "PRR10,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x2c++0x3
    line.long 0x00 "PRR11,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x30++0x3
    line.long 0x00 "PRR12,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x34++0x3
    line.long 0x00 "PRR13,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x38++0x3
    line.long 0x00 "PRR14,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x3c++0x3
    line.long 0x00 "PRR15,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x40++0x3
    line.long 0x00 "PRR16,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x44++0x3
    line.long 0x00 "PRR17,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x48++0x3
    line.long 0x00 "PRR18,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x4c++0x3
    line.long 0x00 "PRR19,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x50++0x3
    line.long 0x00 "PRR20,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x54++0x3
    line.long 0x00 "PRR21,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x58++0x3
    line.long 0x00 "PRR22,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x5c++0x3
    line.long 0x00 "PRR23,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x60++0x3
    line.long 0x00 "PRR24,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x64++0x3
    line.long 0x00 "PRR25,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x68++0x3
    line.long 0x00 "PRR26,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x6c++0x3
    line.long 0x00 "PRR27,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x70++0x3
    line.long 0x00 "PRR28,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x74++0x3
    line.long 0x00 "PRR29,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x78++0x3
    line.long 0x00 "PRR30,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x7c++0x3
    line.long 0x00 "PRR31,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."


tree.end



;--------------------------------------------------------------------------------
; SPDC
;--------------------------------------------------------------------------------
tree "SPDC"
    base ad:0x020e8000

width 13.
group.long 0x0++0x3
    line.long 0x00 "DISP_TRIGGER,Display Trigger"
        bitfld.long 0x00 0. " DISP_TRIG ,EPD screen update trigger When set to ""1"" it will trigger TCON start to display image on panel." "0,1"
        textline "            "
        hexmask.long.byte 0x00 1.--4. 1. " EPD_MODE ,EPD update mode setting 0x0 MODE_0 - It will be displayed with mode 0 waveform 0x1 MODE_1 - It will be displayed with mode 1 waveform 0x2 MODE_2 - It will be displayed with mode 2 waveform 0x3 MODE_3 - It will be displayed with mode 3 waveform 0x4 MODE_4 - It will be displayed with mode 4 waveform (High Speed Handwriting Mode) 0x5 MODE_5 - It will be displayed with mode 5 waveform 0x7 MODE_7 - It will be displayed with mode 7 waveform"
        textline "            "
        bitfld.long 0x00 4. " FLASH_SET ,Judge EPD screen update will be flashed or not in mode 7 0x0 NO_FLASH - It will not be flashed screen update in mode 7 0x1 FLASH - It will be flashed screen update in mode 7" "0,1"
width 11.
group.long 0x4++0x3
    line.long 0x00 "UPDATE_X_Y,Display Coordinate"
        hexmask.long.word 0x00 0.--12. 1. " COORDINATE_Y ,Vertical coordinate of update region (minimum: 1) If image have rotated counterclockwise 90 Y should be 4n + 1 format where n is integer"
        textline "          "
        hexmask.long.word 0x00 16.--28. 1. " COORDINATE_X ,Horizontal coordinate of update region (minimum: 1) X should be 4n + 1 format where n is integer"
width 11.
group.long 0x8++0x3
    line.long 0x00 "UPDATE_W_H,Display Area Size"
        hexmask.long.word 0x00 0.--12. 1. " HEIGHT ,Height of update region If image have rotated counterclockwise 90 L should be 4n format where n is integer"
        textline "          "
        hexmask.long.word 0x00 16.--28. 1. " WIDTH ,Width of update region W should be 4n format where n is integer"
width 16.
group.long 0xc++0x3
    line.long 0x00 "LUT_PARA_UPDATE,LUT Parameter Update"
        hexmask.long.byte 0x00 0.--8. 1. " LUT_PARAMETER_UPDATED_VALUE ,The value of update LUT parameter"
        textline "               "
        hexmask.long.byte 0x00 8.--16. 1. " LUT_PARAMETER_UPDATED_ADDR ,The address of updated LUT parameter"
width 8.
group.long 0x10++0x3
    line.long 0x00 "OPERATE,Display Normal Operation"
        bitfld.long 0x00 0. " DISP_REFRESH ,Display refresh When set to ""1"" it will trigger TCON start to refresh panel screen base on DDR image data (current frame memory) with mode 0 waveform." "0,1"
        textline "       "
        bitfld.long 0x00 1. " DEEP_REFRESH ,Deep refresh (combine display reset and display refresh function) When set to ""1"" it will trigger TCON start to reset panel screen and automatic refresh panel screen base on DDR image data (current frame memory) with mode 0 waveform." "0,1"
        textline "       "
        bitfld.long 0x00 2. " DISP_RESET ,Display reset When set to ""1"" it will trigger TCON start to reset panel screen and automatic update next/current/previous frame memories according to flash LUT setting gray level." "0,1"
        textline "       "
        bitfld.long 0x00 31. " SW_TCON_RESET ,Software TCON register reset When set to ""1"" it will trigger TCON start to reset all internal registers in TCON." "0,1"
width 15.
group.long 0x14++0x3
    line.long 0x00 "PANEL_INIT_SET,SPDC Initial Setting"
        bitfld.long 0x00 0. " YOE_POL ,Set the YOE signal's polarity of gate driver IC 0x0 LOW_ENABLE -Gate pulse outputs low enable." "0,1"
        textline "              "
        bitfld.long 0x00 1. " DUAL_GATE ,Set to enable the panel type of dual gate driver 0x0 SINGLE_GATE -Single gate driver (support gate driver K7900)." "0,1"
        textline "              "
        hexmask.long.byte 0x00 2.--7. 1. " RESOLUTION ,Set the panel resolution GRAY_MODE - Please reference the Table 45-12 RGBW_MODE -Please reference the Table 45-13"
        textline "              "
        bitfld.long 0x00 7. " UD ,Select gate driver IC scanning direction up or down." "0,1"
        textline "              "
        bitfld.long 0x00 8. " RL ,Select source driver IC scanning direction right or left." "0,1"
        textline "              "
        bitfld.long 0x00 9. " DATA_FILTER_N ,Automatic filter input image pixel data base on the display mode 0x0 ENABLE_AUTO_DATA_FILTER -Filter input data 16-step gray to 4-step gray data for mode 2 and mode 3." "0,1"
        textline "              "
        bitfld.long 0x00 10. " POWER_READY ,Driver IC power ready signal 0x0 POWER_NOT_READY - The TCON will be hold wait for driver IC power turn on finish 0x1 POWER_READY - The TCON will into IDLE state and user cloud send the display trigger" "0,1"
        textline "              "
        bitfld.long 0x00 11. " RGBW_MODE_EN ,RGBW color mode enable 0x0 DISABLE_RGBW_MODE -It will enable TCON into gray mode 0x1 ENABLE_ RGBW_MODE - It will enable TCON into RGBW mode" "0,1"
        textline "              "
        bitfld.long 0x00 13. " HBURST_LEN_EN ,HBURST length enable 0x0 DISABLE_HBURST - AHB2AXI gasket ignores the HBURST_LEN[3:0]." "0,1"
width 15.
group.long 0x18++0x3
    line.long 0x00 "TEMPER_SETTING,Environment Temperature"
        hexmask.long.word 0x00 0.--9. 1. " TEMPERATURE ,Update TCON temperature information Temperature Information is used to indicate the temperature of operating environment."
width 9.
group.long 0x1c++0x3
    line.long 0x00 "NEXT_BUF,Next Frame Memory Address"
        hexmask.long.long 0x00 0.--32. 1. " NEXT_FRAME_MEMORY_ADDR ,Update next frame memory address of DDR memory The next frame memory address should be word-align value, it means EPD TCON wills automatic truncate two bits of LSB."
width 12.
group.long 0x20++0x3
    line.long 0x00 "CURRENT_BUF,Current Frame Memory Address"
        hexmask.long.long 0x00 0.--32. 1. " CURRENT_FRAME_MEMORY_ADDR ,Update current frame memory address of DDR memory The current frame memory address should be word-align value, it means EPD TCON wills automatic truncate two bits of LSB."
width 14.
group.long 0x24++0x3
    line.long 0x00 "PREVIOUS_BUFF,Previous Frame Memory Address"
        hexmask.long.long 0x00 0.--32. 1. " PREVIOUS_FRAME_MEMORY_ADDR ,Update previous frame memory address of DDR memory The previous frame memory address should be word-align value, it means EPD TCON wills automatic truncate two bits of LSB."
width 13.
group.long 0x28++0x3
    line.long 0x00 "FRM_CNT_BUFF,Counter Frame Memory Address"
        hexmask.long.long 0x00 0.--32. 1. " COUNTER_FRAME_MEMORY_ADDR ,Update counter frame memory address of DDR memory The counter frame memory address should be word-align value, it means EPD TCON wills automatic truncate two bits of LSB."
width 9.
group.long 0x2c++0x3
    line.long 0x00 "LUT_BUFF,LUT Memory Address"
        hexmask.long.long 0x00 0.--32. 1. " LUT_MEMORY_ADDR ,Update LUT memory address of DDR memory The LUT memory address should be word-align value, it means EPD TCON wills automatic truncate two bits of LSB."
width 7.
group.long 0x30++0x3
    line.long 0x00 "INT_EN,Interrupt Enable"
        bitfld.long 0x00 0. " UPDATE_FINISH_INT_EN ,Screen update finish interrupt signal mask 0x0 DISABLE_UPDATE_FINISH_INTERRUPT - Disable Frame Update Finish Interrupt 0x1 ENABLE_UPDATE_FINISH_INTERRUPT - Enable Frame Update Finish Interrupt" "0,1"
        textline "      "
        bitfld.long 0x00 1. " TCON_INIT_FINISH_INT_EN ,TCON initialization finish interrupt signal mask 0x0 DISABLE_TCON_INIT_FINISH_INTERRUPT - Disable TCON Initialization Finish Interrupt 0x1 ENABLE_TCON_INIT_FINISH_INTERRUPT - Enable TCON Initialization Interrupt" "0,1"
        textline "      "
        bitfld.long 0x00 2. " LUT_DOWNLOAD_FINISH_INT_EN ,LUT initial download finish interrupt signal mask 0x0 DISABLE_LUT_DOWNLOAD_FINISH_INTERRUPT - Disable LUT initial Download Finish Interrupt 0x1 ENABLE_LUT_DOWNLOAD_FINISH_INTERRUPT - Enable LUT initial Download Finish Interrupt" "0,1"
        textline "      "
        bitfld.long 0x00 3. " TCON_ERROR_INT_EN ,Error interrupt signal mask 0x0 DISABLE_ERRPR_INTERRUPT - Disable Error Interrupt 0x1 ENABLE_ERRPR_INTERRUPT - Enable Error Interrupt" "0,1"
width 11.
group.long 0x34++0x3
    line.long 0x00 "INT_ST_CLR,Interrupt Status & Clear"
        bitfld.long 0x00 0. " UPDATE_FINISH_INT_CLR ,Screen update finish interrupt signal clear When set to ""1"" it will trigger TCON start to clear screen update finish interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 1. " TCON_INIT_FINISH_INT_CLR ,TCON initialization finish interrupt signal clear When set to ""1"" it will trigger TCON start to clear TCON initialization finish interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 2. " LUT_DOWNLOAD_FINISH_INT_CLR ,LUT initial download finish interrupt signal clear When set to ""1"" it will trigger TCON start to clear LUT download finish interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 3. " TCON_ERROR_INT_CLR ,Error interrupt signal clear When set to ""1"" it will trigger TCON start to clear error interrupt." "0,1"
width 7.
rgroup.long 0x3c++0x3
    line.long 0x00 "STATUS,SPDC Operation Status"
        bitfld.long 0x00 0. " EPD_TCON_BUSY_N ,EPD TCON busy status 0x0 BUSY_STATUS - Panel is under updating 0x1 NOT_BUSY_STATUS - Panel update finished" "0,1"
        textline "      "
        bitfld.long 0x00 3. " LUT_CHECKSUM ,LUT checksum status 0x0 CHECKSUM_FAIL - LUT checksum fail 0x1 CHECKSUM_SUCCESS - LUT checksum pass" "0,1"
        textline "      "
        hexmask.long.byte 0x00 4.--8. 1. " EPD_TCON_STATUS ,EPD TCON IP status 0x0 RST_STATUS - EPD TCON during reset phase 0x1 WAIT_FOR_CHECKSUM_AND_POWER_READY_STATUS - EPD TCON is hold for waiting checksum pass and driver IC power ready 0x2 CHECKSUM_FAIL_BUT_POWER_READY_STATUS - EPD TCON checksum fail but driver IC power ready."
width 15.
rgroup.long 0x40++0x3
    line.long 0x00 "PANEL_TYPE_VER,Panel Type Related Information"
        hexmask.long.word 0x00 0.--16. 1. " PRODUCT_AND_DRIVER_ID ,Product ID and driver ID, they are stand for different type of panel 0x0 A060SE02 - Panel type (AUO-K7900) 0x1 A090XE01 - Panel type (AUO-K7900) Others need to be defined"
        textline "              "
        hexmask.long.byte 0x00 16.--24. 1. " LUT_VERSION ,LUT version, it stands for different version of driving waveform 0x0101 V308 - Driving waveform type 0x0102 V312 - Driving waveform type Others need to be defined"
        textline "              "
        hexmask.long.byte 0x00 24.--32. 1. " EPD_PANEL_TYPE ,EPD panel type, it stands for different material type of film."
width 9.
rgroup.long 0x44++0x3
    line.long 0x00 "TCON_VER,SPDC IP Version"
        hexmask.long.byte 0x00 0.--8. 1. " EPD_TCON_VERSION ,EPD TCON version, it stands for different version of EPD TCON."
width 12.
group.long 0x48++0x3
    line.long 0x00 "SW_GATE_CLK,All Clock Gating Enable"
        bitfld.long 0x00 0. " GATING_ALL_CLK_EN ,All clocks gating enable 0x0 ENABLE_ALL_CLOCKS - All clocks free run 0x1 GATING_ALL_CLOCKS - Gating all clocks for low power" "0,1"


tree.end



;--------------------------------------------------------------------------------
; SPDIF
;--------------------------------------------------------------------------------
tree "SPDIF"
    base ad:0x02004000

width 4.
group.long 0x0++0x3
    line.long 0x00 "SCR,SPDIF Configuration Register"
        hexmask.long.byte 0x00 0.--2. 1. " USRC_SEL ,"
        textline "   "
        hexmask.long.byte 0x00 2.--5. 1. " TXSEL ,"
        textline "   "
        bitfld.long 0x00 5. " VALCTRL ," "0,1"
        textline "   "
        bitfld.long 0x00 8. " DMA_TX_EN ,DMA Transmit Request Enable (Tx FIFO empty)" "0,1"
        textline "   "
        bitfld.long 0x00 9. " DMA_RX_EN ,DMA Receive Request Enable (RX FIFO full)" "0,1"
        textline "   "
        hexmask.long.byte 0x00 10.--12. 1. " TXFIFO_CTRL ,"
        textline "   "
        bitfld.long 0x00 12. " SOFT_RESET ,When write 1 to this bit, it will cause SPDIF software reset." "0,1"
        textline "   "
        bitfld.long 0x00 13. " LOW_POWER ,When write 1 to this bit, it will cause SPDIF enter low-power mode." "0,1"
        textline "   "
        hexmask.long.byte 0x00 15.--17. 1. " TXFIFOEMPTY_SEL ,"
        textline "   "
        bitfld.long 0x00 17. " TXAUTOSYNC ," "0,1"
        textline "   "
        bitfld.long 0x00 18. " RXAUTOSYNC ," "0,1"
        textline "   "
        hexmask.long.byte 0x00 19.--21. 1. " RXFIFOFULL_SEL ,"
        textline "   "
        bitfld.long 0x00 21. " RXFIFO_RST ," "0,1"
        textline "   "
        bitfld.long 0x00 22. " RXFIFO_OFF_ON ," "0,1"
        textline "   "
        bitfld.long 0x00 23. " RXFIFO_CTRL ," "0,1"
        textline "   "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 5.
group.long 0x4++0x3
    line.long 0x00 "SRCD,CDText Control Register"
        bitfld.long 0x00 1. " USYNCMODE ," "0,1"
        textline "    "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 5.
group.long 0x8++0x3
    line.long 0x00 "SRPC,PhaseConfig Register"
        hexmask.long.byte 0x00 3.--6. 1. " GAINSEL ,Gain selection:"
        textline "    "
        bitfld.long 0x00 6. " LOCK ,LOCK bit to show that the internal DPLL is locked, read only" "0,1"
        textline "    "
        hexmask.long.byte 0x00 7.--11. 1. " CLKSRC_SEL ,Clock source selection, all other settings not shown are reserved:"
        textline "    "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 4.
group.long 0xc++0x3
    line.long 0x00 "SIE,InterruptEn Register"
        bitfld.long 0x00 0. " RXFIFOFUL ,SPDIF Rx FIFO full, can't be cleared with reg." "0,1"
        textline "   "
        bitfld.long 0x00 1. " TXEM ,SPDIF Tx FIFO empty, can't be cleared with reg." "0,1"
        textline "   "
        bitfld.long 0x00 2. " LOCKLOSS ,SPDIF receiver loss of lock" "0,1"
        textline "   "
        bitfld.long 0x00 3. " RXFIFORESYN ,Rx FIFO resync" "0,1"
        textline "   "
        bitfld.long 0x00 4. " RXFIFOUNOV ,Rx FIFO underrun/overrun" "0,1"
        textline "   "
        bitfld.long 0x00 5. " UQERR ,U/Q Channel framing error" "0,1"
        textline "   "
        bitfld.long 0x00 6. " UQSYNC ,U/Q Channel sync found" "0,1"
        textline "   "
        bitfld.long 0x00 7. " QRXOV ,Q Channel receive register overrun" "0,1"
        textline "   "
        bitfld.long 0x00 8. " QRXFUL ,Q Channel receive register full, can't be cleared with reg." "0,1"
        textline "   "
        bitfld.long 0x00 9. " URXOV ,U Channel receive register overrun" "0,1"
        textline "   "
        bitfld.long 0x00 10. " URXFUL ,U Channel receive register full, can't be cleared with reg." "0,1"
        textline "   "
        bitfld.long 0x00 14. " BITERR ,SPDIF receiver found parity bit error" "0,1"
        textline "   "
        bitfld.long 0x00 15. " SYMERR ,SPDIF receiver found illegal symbol" "0,1"
        textline "   "
        bitfld.long 0x00 16. " VALNOGOOD ,SPDIF validity flag no good" "0,1"
        textline "   "
        bitfld.long 0x00 17. " CNEW ,SPDIF receive change in value of control channel" "0,1"
        textline "   "
        bitfld.long 0x00 18. " TXRESYN ,SPDIF Tx FIFO resync" "0,1"
        textline "   "
        bitfld.long 0x00 19. " TXUNOV ,SPDIF Tx FIFO under/overrun" "0,1"
        textline "   "
        bitfld.long 0x00 20. " LOCK ,SPDIF receiver's DPLL is locked" "0,1"
        textline "   "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 4.
rgroup.long 0x10++0x3
    line.long 0x00 "SIS,InterruptStat Register"
        bitfld.long 0x00 0. " RXFIFOFUL ,SPDIF Rx FIFO full, can't be cleared with reg." "0,1"
        textline "   "
        bitfld.long 0x00 1. " TXEM ,SPDIF Tx FIFO empty, can't be cleared with reg." "0,1"
        textline "   "
        bitfld.long 0x00 2. " LOCKLOSS ,SPDIF receiver loss of lock" "0,1"
        textline "   "
        bitfld.long 0x00 3. " RXFIFORESYN ,Rx FIFO resync" "0,1"
        textline "   "
        bitfld.long 0x00 4. " RXFIFOUNOV ,Rx FIFO underrun/overrun" "0,1"
        textline "   "
        bitfld.long 0x00 5. " UQERR ,U/Q Channel framing error" "0,1"
        textline "   "
        bitfld.long 0x00 6. " UQSYNC ,U/Q Channel sync found" "0,1"
        textline "   "
        bitfld.long 0x00 7. " QRXOV ,Q Channel receive register overrun" "0,1"
        textline "   "
        bitfld.long 0x00 8. " QRXFUL ,Q Channel receive register full, can't be cleared with reg." "0,1"
        textline "   "
        bitfld.long 0x00 9. " URXOV ,U Channel receive register overrun" "0,1"
        textline "   "
        bitfld.long 0x00 10. " URXFUL ,U Channel receive register full, can't be cleared with reg." "0,1"
        textline "   "
        bitfld.long 0x00 14. " BITERR ,SPDIF receiver found parity bit error" "0,1"
        textline "   "
        bitfld.long 0x00 15. " SYMERR ,SPDIF receiver found illegal symbol" "0,1"
        textline "   "
        bitfld.long 0x00 16. " VALNOGOOD ,SPDIF validity flag no good" "0,1"
        textline "   "
        bitfld.long 0x00 17. " CNEW ,SPDIF receive change in value of control channel" "0,1"
        textline "   "
        bitfld.long 0x00 18. " TXRESYN ,SPDIF Tx FIFO resync" "0,1"
        textline "   "
        bitfld.long 0x00 19. " TXUNOV ,SPDIF Tx FIFO under/overrun" "0,1"
        textline "   "
        bitfld.long 0x00 20. " LOCK ,SPDIF receiver's DPLL is locked" "0,1"
        textline "   "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 4.
wgroup.long 0x10++0x3
    line.long 0x00 "SIC,InterruptClear Register"
        bitfld.long 0x00 2. " LOCKLOSS ,SPDIF receiver loss of lock" "0,1"
        textline "   "
        bitfld.long 0x00 3. " RXFIFORESYN ,Rx FIFO resync" "0,1"
        textline "   "
        bitfld.long 0x00 4. " RXFIFOUNOV ,Rx FIFO underrun/overrun" "0,1"
        textline "   "
        bitfld.long 0x00 5. " UQERR ,U/Q Channel framing error" "0,1"
        textline "   "
        bitfld.long 0x00 6. " UQSYNC ,U/Q Channel sync found" "0,1"
        textline "   "
        bitfld.long 0x00 7. " QRXOV ,Q Channel receive register overrun" "0,1"
        textline "   "
        bitfld.long 0x00 9. " URXOV ,U Channel receive register overrun" "0,1"
        textline "   "
        bitfld.long 0x00 14. " BITERR ,SPDIF receiver found parity bit error" "0,1"
        textline "   "
        bitfld.long 0x00 15. " SYMERR ,SPDIF receiver found illegal symbol" "0,1"
        textline "   "
        bitfld.long 0x00 16. " VALNOGOOD ,SPDIF validity flag no good" "0,1"
        textline "   "
        bitfld.long 0x00 17. " CNEW ,SPDIF receive change in value of control channel" "0,1"
        textline "   "
        bitfld.long 0x00 18. " TXRESYN ,SPDIF Tx FIFO resync" "0,1"
        textline "   "
        bitfld.long 0x00 19. " TXUNOV ,SPDIF Tx FIFO under/overrun" "0,1"
        textline "   "
        bitfld.long 0x00 20. " LOCK ,SPDIF receiver's DPLL is locked" "0,1"
        textline "   "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 4.
rgroup.long 0x14++0x3
    line.long 0x00 "SRL,SPDIFRxLeft Register"
        hexmask.long.long 0x00 0.--24. 1. " RXDATALEFT ,Processor receive SPDIF data left"
        textline "   "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 4.
rgroup.long 0x18++0x3
    line.long 0x00 "SRR,SPDIFRxRight Register"
        hexmask.long.long 0x00 0.--24. 1. " RXDATARIGHT ,Processor receive SPDIF data right"
        textline "   "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 6.
rgroup.long 0x1c++0x3
    line.long 0x00 "SRCSH,SPDIFRxCChannel_h Register"
        hexmask.long.long 0x00 0.--24. 1. " RXCCHANNEL_H ,SPDIF receive C channel register, contains first 24 bits of C channel without interpretation"
        textline "     "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 6.
rgroup.long 0x20++0x3
    line.long 0x00 "SRCSL,SPDIFRxCChannel_l Register"
        hexmask.long.long 0x00 0.--24. 1. " RXCCHANNEL_L ,SPDIF receive C channel register, contains next 24 bits of C channel without interpretation"
        textline "     "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 4.
rgroup.long 0x24++0x3
    line.long 0x00 "SRU,UchannelRx Register"
        hexmask.long.long 0x00 0.--24. 1. " RXUCHANNEL ,SPDIF receive U channel register, contains next 3 U channel bytes"
        textline "   "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,This is a 24-bit register the upper byte is unimplemented."
width 4.
rgroup.long 0x28++0x3
    line.long 0x00 "SRQ,QchannelRx Register"
        hexmask.long.long 0x00 0.--24. 1. " RXQCHANNEL ,SPDIF receive Q channel register, contains next 3 Q channel bytes"
        textline "   "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 4.
wgroup.long 0x2c++0x3
    line.long 0x00 "STL,SPDIFTxLeft Register"
        hexmask.long.long 0x00 0.--24. 1. " TXDATALEFT ,SPDIF transmit left channel data."
        textline "   "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,This is a 24-bit register the upper byte is unimplemented."
width 4.
wgroup.long 0x30++0x3
    line.long 0x00 "STR,SPDIFTxRight Register"
        hexmask.long.long 0x00 0.--24. 1. " TXDATARIGHT ,SPDIF transmit right channel data."
        textline "   "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,This is a 24-bit register the upper byte is unimplemented."
width 7.
group.long 0x34++0x3
    line.long 0x00 "STCSCH,SPDIFTxCChannelCons_h Register"
        hexmask.long.long 0x00 0.--24. 1. " TXCCHANNELCONS_H ,SPDIF transmit Cons."
        textline "      "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 7.
group.long 0x38++0x3
    line.long 0x00 "STCSCL,SPDIFTxCChannelCons_l Register"
        hexmask.long.long 0x00 0.--24. 1. " TXCCHANNELCONS_L ,SPDIF transmit Cons."
        textline "      "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 5.
rgroup.long 0x44++0x3
    line.long 0x00 "SRFM,FreqMeas Register"
        hexmask.long.long 0x00 0.--24. 1. " FREQMEAS ,Frequency measurement data"
        textline "    "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 4.
group.long 0x50++0x3
    line.long 0x00 "STC,SPDIFTxClk Register"
        hexmask.long.byte 0x00 0.--7. 1. " TXCLK_DF ,Divider factor (1-128)"
        textline "   "
        bitfld.long 0x00 7. " TX_ALL_CLK_EN ,Spdif transfer clock enable.When data is going to be transfered, this bit should be set to1." "0,1"
        textline "   "
        hexmask.long.byte 0x00 8.--11. 1. " TXCLK_SOURCE ,"
        textline "   "
        hexmask.long.word 0x00 11.--20. 1. " SYSCLK_DF ,system clock divider factor, 2~512."
        textline "   "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"


tree.end



;--------------------------------------------------------------------------------
; SRC
;--------------------------------------------------------------------------------
tree "SRC"
    base ad:0x020d8000

width 4.
group.long 0x0++0x3
    line.long 0x00 "SCR,SRC Control Register"
        bitfld.long 0x00 0. " WARM_RESET_ENABLE ,WARM reset enable bit." "0,1"
        textline "   "
        bitfld.long 0x00 1. " SW_GPU_RST ,Software reset for gpu this is a self clearing bit." "0,1"
        textline "   "
        bitfld.long 0x00 2. " SW_VPU_RST ,Software reset for vpu this is a self clearing bit." "0,1"
        textline "   "
        bitfld.long 0x00 4. " SW_OPEN_VG_RST ,Software reset for open_vg This is a self clearing bit." "0,1"
        textline "   "
        hexmask.long.byte 0x00 5.--7. 1. " WARM_RST_BYPASS_COUNT ,Defines the ckil cycles to count before bypassing the MMDC acknowledge for WARM reset."
        textline "   "
        hexmask.long.byte 0x00 7.--11. 1. " MASK_WDOG_RST ,Mask wdog_rst_b source."
        textline "   "
        bitfld.long 0x00 11. " EIM_RST ,EIM reset is needed in order to reconfigure the eim chip select." "0,1"
        textline "   "
        bitfld.long 0x00 13. " CORE0_RST ,Software reset for core0 only." "0,1"
        textline "   "
        bitfld.long 0x00 17. " CORE0_DBG_RST ,Software reset for core0 debug only." "0,1"
        textline "   "
        bitfld.long 0x00 21. " CORES_DBG_RST ,Software reset for debug of arm platform only." "0,1"
        textline "   "
        bitfld.long 0x00 25. " DBG_RST_MSK_PG ,Do not assert debug resets after power gating event of cpu" "0,1"
width 6.
rgroup.long 0x4++0x3
    line.long 0x00 "SBMR1,SRC Boot Mode Register 1"
        hexmask.long.byte 0x00 0.--8. 1. " BOOT_CFG1 ,Please refer to fuse map."
        textline "     "
        hexmask.long.byte 0x00 8.--16. 1. " BOOT_CFG2 ,Please refer to fuse map."
        textline "     "
        hexmask.long.byte 0x00 16.--24. 1. " BOOT_CFG3 ,Please refer to fuse map."
        textline "     "
        hexmask.long.byte 0x00 24.--32. 1. " BOOT_CFG4 ,Please refer to fuse map."
width 5.
group.long 0x8++0x3
    line.long 0x00 "SRSR,SRC Reset Status Register"
        bitfld.long 0x00 0. " IPP_RESET_B ,Indicates whether reset was the result of ipp_reset_b pin (Power-up sequence)" "0,1"
        textline "    "
        bitfld.long 0x00 2. " CSU_RESET_B ,Indicates whether the reset was the result of the csu_reset_b input." "0,1"
        textline "    "
        bitfld.long 0x00 3. " IPP_USER_RESET_B ,Indicates whether the reset was the result of the ipp_user_reset_b qualified reset." "0,1"
        textline "    "
        bitfld.long 0x00 4. " WDOG_RST_B ,IC Watchdog Time-out reset." "0,1"
        textline "    "
        bitfld.long 0x00 5. " JTAG_RST_B ,HIGH - Z JTAG reset." "0,1"
        textline "    "
        bitfld.long 0x00 6. " JTAG_SW_RST ,JTAG SW reset." "0,1"
        textline "    "
        bitfld.long 0x00 16. " WARM_BOOT ,WARM boot indication shows that WARM boot was initiated by software." "0,1"
width 5.
rgroup.long 0x14++0x3
    line.long 0x00 "SISR,SRC Interrupt Status Register"
        bitfld.long 0x00 0. " GPU_PASSED_RESET ,Interrupt generated to indicate that gpu passed software reset and is ready to be used" "0,1"
        textline "    "
        bitfld.long 0x00 1. " VPU_PASSED_RESET ,Interrupt generated to indicate that vpu passed software reset and is ready to be used" "0,1"
        textline "    "
        bitfld.long 0x00 3. " OPEN_VG_PASSED_RESET ,Interrupt generated to indicate that open_vg passed software reset and is ready to be used" "0,1"
        textline "    "
        bitfld.long 0x00 5. " CORE0_WDOG_RST_REQ ,WDOG reset request from CPU core0." "0,1"
width 5.
group.long 0x18++0x3
    line.long 0x00 "SIMR,SRC Interrupt Mask Register"
        bitfld.long 0x00 0. " MASK_GPU_PASSED_RESET ,mask interrupt generation due to gpu passed reset" "0,1"
        textline "    "
        bitfld.long 0x00 1. " MASK_VPU_PASSED_RESET ,mask interrupt generation due to vpu passed reset" "0,1"
        textline "    "
        bitfld.long 0x00 3. " MASK_OPEN_VG_PASSED_RESET ,mask interrupt generation due to open_vg passed reset" "0,1"
width 6.
rgroup.long 0x1c++0x3
    line.long 0x00 "SBMR2,SRC Boot Mode Register 2"
        hexmask.long.byte 0x00 0.--2. 1. " SEC_CONFIG ,Please refer to fuse map."
        textline "     "
        bitfld.long 0x00 3. " DIR_BT_DIS ,Please refer to fuse map." "0,1"
        textline "     "
        bitfld.long 0x00 4. " BT_FUSE_SEL ,BT_FUSE_SEL (connected to gpio bt_fuse_sel)" "0,1"
        textline "     "
        hexmask.long.byte 0x00 24.--26. 1. " BMOD ,Please refer to fuse map."
        textline "     "
        hexmask.long.byte 0x00 27.--30. 1. " TEST_MODE ,Please refer to fuse map."
width 5.
group.long 0x20++0x3
    line.long 0x00 "GPR1,SRC General Purpose Register 1"
width 5.
group.long 0x24++0x3
    line.long 0x00 "GPR2,SRC General Purpose Register 2"
width 5.
group.long 0x28++0x3
    line.long 0x00 "GPR3,SRC General Purpose Register 3"
width 5.
group.long 0x2c++0x3
    line.long 0x00 "GPR4,SRC General Purpose Register 4"
width 5.
group.long 0x30++0x3
    line.long 0x00 "GPR5,SRC General Purpose Register 5"
width 5.
group.long 0x34++0x3
    line.long 0x00 "GPR6,SRC General Purpose Register 6"
width 5.
group.long 0x38++0x3
    line.long 0x00 "GPR7,SRC General Purpose Register 7"
width 5.
group.long 0x3c++0x3
    line.long 0x00 "GPR8,SRC General Purpose Register 8"
width 5.
group.long 0x40++0x3
    line.long 0x00 "GPR9,SRC General Purpose Register 9"
width 6.
group.long 0x44++0x3
    line.long 0x00 "GPR10,SRC General Purpose Register 10"


tree.end



;--------------------------------------------------------------------------------
; SSI
;--------------------------------------------------------------------------------
tree.open "SSI"
    tree "SSI1"
        base ad:0x02028000

width 5.
group.long 0x0++0x3
    line.long 0x00 "STX0,SSI Transmit Data Register n"
        hexmask.long.long 0x00 0.--32. 1. " STXN ,SSI Transmit Data."
width 5.
group.long 0x4++0x3
    line.long 0x00 "STX1,SSI Transmit Data Register n"
        hexmask.long.long 0x00 0.--32. 1. " STXN ,SSI Transmit Data."
width 5.
rgroup.long 0x8++0x3
    line.long 0x00 "SRX0,SSI Receive Data Register n"
        hexmask.long.long 0x00 0.--32. 1. " SRXN ,SSI Receive Data."
width 5.
rgroup.long 0xc++0x3
    line.long 0x00 "SRX1,SSI Receive Data Register n"
        hexmask.long.long 0x00 0.--32. 1. " SRXN ,SSI Receive Data."
width 4.
group.long 0x10++0x3
    line.long 0x00 "SCR,SSI Control Register"
        bitfld.long 0x00 0. " SSIEN ,SSIEN - SSI Enable This bit is used to enable/disable the SSI." "0,1"
        textline "   "
        bitfld.long 0x00 1. " TE ,Transmit Enable." "0,1"
        textline "   "
        bitfld.long 0x00 2. " RE ,Receive Enable." "0,1"
        textline "   "
        bitfld.long 0x00 3. " NET ,Network Mode." "0,1"
        textline "   "
        bitfld.long 0x00 4. " SYN ,Synchronous Mode." "0,1"
        textline "   "
        hexmask.long.byte 0x00 5.--7. 1. " I2S_MODE ,I2S Mode Select."
        textline "   "
        bitfld.long 0x00 7. " SYS_CLK_EN ,Network Clock (Oversampling Clock) Enable." "0,1"
        textline "   "
        bitfld.long 0x00 8. " TCH_EN ,Two-Channel Operation Enable." "0,1"
        textline "   "
        bitfld.long 0x00 9. " CLK_IST ,Clock Idle State." "0,1"
        textline "   "
        bitfld.long 0x00 10. " TFR_CLK_DIS ,Transmit Frame Clock Disable." "0,1"
        textline "   "
        bitfld.long 0x00 11. " RFR_CLK_DIS ,Receive Frame Clock Disable." "0,1"
        textline "   "
        bitfld.long 0x00 12. " SYNC_TX_FS ,SYNC_FS_TX bit provides a safe window for TE to be visible to the internal circuit which is just after FS occurrence." "0,1"
width 5.
group.long 0x14++0x3
    line.long 0x00 "SISR,SSI Interrupt Status Register"
        bitfld.long 0x00 0. " TFE0 ,Transmit FIFO Empty 0." "0,1"
        textline "    "
        bitfld.long 0x00 1. " TFE1 ,Transmit FIFO Empty 1." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RFF0 ,Receive FIFO Full 0." "0,1"
        textline "    "
        bitfld.long 0x00 3. " RFF1 ,Receive FIFO Full 1." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RLS ,Receive Last Time Slot." "0,1"
        textline "    "
        bitfld.long 0x00 5. " TLS ,Transmit Last Time Slot." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RFS ,Receive Frame Sync." "0,1"
        textline "    "
        bitfld.long 0x00 7. " TFS ,Transmit Frame Sync." "0,1"
        textline "    "
        bitfld.long 0x00 8. " TUE0 ,Transmitter Underrun Error 0." "0,1"
        textline "    "
        bitfld.long 0x00 9. " TUE1 ,Transmitter Underrun Error 1." "0,1"
        textline "    "
        bitfld.long 0x00 10. " ROE0 ,Receiver Overrun Error 0." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ROE1 ,Receiver Overrun Error 1." "0,1"
        textline "    "
        bitfld.long 0x00 12. " TDE0 ,Transmit Data Register Empty 0." "0,1"
        textline "    "
        bitfld.long 0x00 13. " TDE1 ,Transmit Data Register Empty 1." "0,1"
        textline "    "
        bitfld.long 0x00 14. " RDR0 ,Receive Data Ready 0." "0,1"
        textline "    "
        bitfld.long 0x00 15. " RDR1 ,Receive Data Ready 1." "0,1"
        textline "    "
        bitfld.long 0x00 16. " RXT ,Receive Tag Updated." "0,1"
        textline "    "
        bitfld.long 0x00 17. " CMDDU ,Command Data Register Updated." "0,1"
        textline "    "
        bitfld.long 0x00 18. " CMDAU ,Command Address Register Updated." "0,1"
        textline "    "
        bitfld.long 0x00 23. " TFRC ,Transmit Frame Complete." "0,1"
        textline "    "
        bitfld.long 0x00 24. " RFRC ,Receive Frame Complete." "0,1"
width 5.
group.long 0x18++0x3
    line.long 0x00 "SIER,SSI Interrupt Enable Register"
        bitfld.long 0x00 0. " TFE0IE ,Transmit FIFO Empty 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 1. " TFE1IE ,Transmit FIFO Empty 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RFF0IE ,Receive FIFO Full 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 3. " RFF1IE ,Receive FIFO Full 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RLSIE ,Receive Last Time Slot Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 5. " TLSIE ,Transmit Last Time Slot Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RFSIE ,Receive Frame Sync Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 7. " TFSIE ,Transmit Frame Sync Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 8. " TUE0IE ,Transmitter Underrun Error 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 9. " TUE1IE ,Transmitter Underrun Error 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 10. " ROE0IE ,Receiver Overrun Error 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ROE1IE ,Receiver Overrun Error 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 12. " TDE0IE ,Transmit Data Register Empty 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 13. " TDE1IE ,Transmit Data Register Empty 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 14. " RDR0IE ,Receive Data Ready 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 15. " RDR1IE ,Receive Data Ready 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 16. " RXTIE ,Receive Tag Updated Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 17. " CMDDUIE ,Command Data Register Updated Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 18. " CMDAUIE ,Command Address Register Updated Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 19. " TIE ,Transmit Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 20. " TDMAE ,Transmit DMA Enable." "0,1"
        textline "    "
        bitfld.long 0x00 21. " RIE ,Receive Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 22. " RDMAE ,Receive DMA Enable." "0,1"
        textline "    "
        bitfld.long 0x00 23. " TFRCIE ,Transmit Frame Complete Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 24. " RFRCIE ,Receive Frame Complete Interrupt Enable." "0,1"
width 5.
group.long 0x1c++0x3
    line.long 0x00 "STCR,SSI Transmit Configuration Register"
        bitfld.long 0x00 0. " TEFS ,Transmit Early Frame Sync." "0,1"
        textline "    "
        bitfld.long 0x00 1. " TFSL ,Transmit Frame Sync Length." "0,1"
        textline "    "
        bitfld.long 0x00 2. " TFSI ,Transmit Frame Sync Invert." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TSCKP ,Transmit Clock Polarity." "0,1"
        textline "    "
        bitfld.long 0x00 4. " TSHFD ,Transmit Shift Direction." "0,1"
        textline "    "
        bitfld.long 0x00 5. " TXDIR ,Transmit Clock Direction." "0,1"
        textline "    "
        bitfld.long 0x00 6. " TFDIR ,Transmit Frame Direction." "0,1"
        textline "    "
        bitfld.long 0x00 7. " TFEN0 ,Transmit FIFO Enable 0." "0,1"
        textline "    "
        bitfld.long 0x00 8. " TFEN1 ,Transmit FIFO Enable 1." "0,1"
        textline "    "
        bitfld.long 0x00 9. " TXBIT0 ,Transmit Bit 0." "0,1"
width 5.
group.long 0x20++0x3
    line.long 0x00 "SRCR,SSI Receive Configuration Register"
        bitfld.long 0x00 0. " REFS ,Receive Early Frame Sync." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RFSL ,Receive Frame Sync Length." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RFSI ,Receive Frame Sync Invert." "0,1"
        textline "    "
        bitfld.long 0x00 3. " RSCKP ,Receive Clock Polarity." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RSHFD ,Receive Shift Direction." "0,1"
        textline "    "
        bitfld.long 0x00 5. " RXDIR ,Receive Clock Direction." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RFDIR ,Receive Frame Direction." "0,1"
        textline "    "
        bitfld.long 0x00 7. " RFEN0 ,Receive FIFO Enable 0." "0,1"
        textline "    "
        bitfld.long 0x00 8. " RFEN1 ,Receive FIFO Enable 1." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RXBIT0 ,Receive Bit 0." "0,1"
        textline "    "
        bitfld.long 0x00 10. " RXEXT ,Receive Data Extension." "0,1"
width 6.
group.long 0x24++0x3
    line.long 0x00 "STCCR,SSI Transmit Clock Control Register"
        hexmask.long.byte 0x00 0.--8. 1. " PM7_PM0 ,Prescaler Modulus Select."
        textline "     "
        hexmask.long.byte 0x00 8.--13. 1. " DC4_DC0 ,Frame Rate Divider Control."
        textline "     "
        hexmask.long.byte 0x00 13.--17. 1. " WL3_WL0 ,Word Length Control."
        textline "     "
        bitfld.long 0x00 17. " PSR ,Prescaler Range." "0,1"
        textline "     "
        bitfld.long 0x00 18. " DIV2 ,Divide By 2." "0,1"
width 6.
group.long 0x28++0x3
    line.long 0x00 "SRCCR,SSI Receive Clock Control Register"
        hexmask.long.byte 0x00 0.--8. 1. " PM7_PM0 ,Prescaler Modulus Select."
        textline "     "
        hexmask.long.byte 0x00 8.--13. 1. " DC4_DC0 ,Frame Rate Divider Control."
        textline "     "
        hexmask.long.byte 0x00 13.--17. 1. " WL3_WL0 ,Word Length Control."
        textline "     "
        bitfld.long 0x00 17. " PSR ,Prescaler Range." "0,1"
        textline "     "
        bitfld.long 0x00 18. " DIV2 ,Divide By 2." "0,1"
width 6.
group.long 0x2c++0x3
    line.long 0x00 "SFCSR,SSI FIFO Control/Status Register"
        hexmask.long.byte 0x00 0.--4. 1. " TFWM0 ,Transmit FIFO Empty WaterMark 0."
        textline "     "
        hexmask.long.byte 0x00 4.--8. 1. " RFWM0 ,Receive FIFO Full WaterMark 0."
        textline "     "
        hexmask.long.byte 0x00 8.--12. 1. " TFCNT0 ,Transmit FIFO Counter 0."
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " RFCNT0 ,Receive FIFO Counter 0."
        textline "     "
        hexmask.long.byte 0x00 16.--20. 1. " TFWM1 ,Transmit FIFO Empty WaterMark 1."
        textline "     "
        hexmask.long.byte 0x00 20.--24. 1. " RFWM1 ,Receive FIFO Full WaterMark 1."
        textline "     "
        hexmask.long.byte 0x00 24.--28. 1. " TFCNT1 ,Transmit FIFO Counter1."
        textline "     "
        hexmask.long.byte 0x00 28.--32. 1. " RFCNT1 ,Receive FIFO Counter1."
width 6.
group.long 0x38++0x3
    line.long 0x00 "SACNT,SSI AC97 Control Register"
        bitfld.long 0x00 0. " AC97EN ,AC97 Mode Enable." "0,1"
        textline "     "
        bitfld.long 0x00 1. " FV ,Fixed/Variable Operation." "0,1"
        textline "     "
        bitfld.long 0x00 2. " TIF ,Tag in FIFO." "0,1"
        textline "     "
        bitfld.long 0x00 3. " RD ,Read Command." "0,1"
        textline "     "
        bitfld.long 0x00 4. " WR ,Write Command." "0,1"
        textline "     "
        hexmask.long.byte 0x00 5.--11. 1. " FRDIV ,Frame Rate Divider."
width 7.
group.long 0x3c++0x3
    line.long 0x00 "SACADD,SSI AC97 Command Address Register"
        hexmask.long.long 0x00 0.--19. 1. " SACADD ,AC97 Command Address."
width 7.
group.long 0x40++0x3
    line.long 0x00 "SACDAT,SSI AC97 Command Data Register"
        hexmask.long.long 0x00 0.--20. 1. " SACDAT ,AC97 Command Data."
width 6.
group.long 0x44++0x3
    line.long 0x00 "SATAG,SSI AC97 Tag Register"
        hexmask.long.word 0x00 0.--16. 1. " SATAG ,AC97 Tag Value."
width 6.
group.long 0x48++0x3
    line.long 0x00 "STMSK,SSI Transmit Time Slot Mask Register"
        hexmask.long.long 0x00 0.--32. 1. " STMSK ,Transmit Mask."
width 6.
group.long 0x4c++0x3
    line.long 0x00 "SRMSK,SSI Receive Time Slot Mask Register"
        hexmask.long.long 0x00 0.--32. 1. " SRMSK ,Receive Mask."
width 7.
rgroup.long 0x50++0x3
    line.long 0x00 "SACCST,SSI AC97 Channel Status Register"
        hexmask.long.word 0x00 0.--10. 1. " SACCST ,AC97 Channel Status."
width 7.
wgroup.long 0x54++0x3
    line.long 0x00 "SACCEN,SSI AC97 Channel Enable Register"
        hexmask.long.word 0x00 0.--10. 1. " SACCEN ,AC97 Channel Enable."
width 8.
wgroup.long 0x58++0x3
    line.long 0x00 "SACCDIS,SSI AC97 Channel Disable Register"
        hexmask.long.word 0x00 0.--10. 1. " SACCDIS ,AC97 Channel Disable."


    tree.end
    tree "SSI2"
        base ad:0x0202c000

width 5.
group.long 0x0++0x3
    line.long 0x00 "STX0,SSI Transmit Data Register n"
        hexmask.long.long 0x00 0.--32. 1. " STXN ,SSI Transmit Data."
width 5.
group.long 0x4++0x3
    line.long 0x00 "STX1,SSI Transmit Data Register n"
        hexmask.long.long 0x00 0.--32. 1. " STXN ,SSI Transmit Data."
width 5.
rgroup.long 0x8++0x3
    line.long 0x00 "SRX0,SSI Receive Data Register n"
        hexmask.long.long 0x00 0.--32. 1. " SRXN ,SSI Receive Data."
width 5.
rgroup.long 0xc++0x3
    line.long 0x00 "SRX1,SSI Receive Data Register n"
        hexmask.long.long 0x00 0.--32. 1. " SRXN ,SSI Receive Data."
width 4.
group.long 0x10++0x3
    line.long 0x00 "SCR,SSI Control Register"
        bitfld.long 0x00 0. " SSIEN ,SSIEN - SSI Enable This bit is used to enable/disable the SSI." "0,1"
        textline "   "
        bitfld.long 0x00 1. " TE ,Transmit Enable." "0,1"
        textline "   "
        bitfld.long 0x00 2. " RE ,Receive Enable." "0,1"
        textline "   "
        bitfld.long 0x00 3. " NET ,Network Mode." "0,1"
        textline "   "
        bitfld.long 0x00 4. " SYN ,Synchronous Mode." "0,1"
        textline "   "
        hexmask.long.byte 0x00 5.--7. 1. " I2S_MODE ,I2S Mode Select."
        textline "   "
        bitfld.long 0x00 7. " SYS_CLK_EN ,Network Clock (Oversampling Clock) Enable." "0,1"
        textline "   "
        bitfld.long 0x00 8. " TCH_EN ,Two-Channel Operation Enable." "0,1"
        textline "   "
        bitfld.long 0x00 9. " CLK_IST ,Clock Idle State." "0,1"
        textline "   "
        bitfld.long 0x00 10. " TFR_CLK_DIS ,Transmit Frame Clock Disable." "0,1"
        textline "   "
        bitfld.long 0x00 11. " RFR_CLK_DIS ,Receive Frame Clock Disable." "0,1"
        textline "   "
        bitfld.long 0x00 12. " SYNC_TX_FS ,SYNC_FS_TX bit provides a safe window for TE to be visible to the internal circuit which is just after FS occurrence." "0,1"
width 5.
group.long 0x14++0x3
    line.long 0x00 "SISR,SSI Interrupt Status Register"
        bitfld.long 0x00 0. " TFE0 ,Transmit FIFO Empty 0." "0,1"
        textline "    "
        bitfld.long 0x00 1. " TFE1 ,Transmit FIFO Empty 1." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RFF0 ,Receive FIFO Full 0." "0,1"
        textline "    "
        bitfld.long 0x00 3. " RFF1 ,Receive FIFO Full 1." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RLS ,Receive Last Time Slot." "0,1"
        textline "    "
        bitfld.long 0x00 5. " TLS ,Transmit Last Time Slot." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RFS ,Receive Frame Sync." "0,1"
        textline "    "
        bitfld.long 0x00 7. " TFS ,Transmit Frame Sync." "0,1"
        textline "    "
        bitfld.long 0x00 8. " TUE0 ,Transmitter Underrun Error 0." "0,1"
        textline "    "
        bitfld.long 0x00 9. " TUE1 ,Transmitter Underrun Error 1." "0,1"
        textline "    "
        bitfld.long 0x00 10. " ROE0 ,Receiver Overrun Error 0." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ROE1 ,Receiver Overrun Error 1." "0,1"
        textline "    "
        bitfld.long 0x00 12. " TDE0 ,Transmit Data Register Empty 0." "0,1"
        textline "    "
        bitfld.long 0x00 13. " TDE1 ,Transmit Data Register Empty 1." "0,1"
        textline "    "
        bitfld.long 0x00 14. " RDR0 ,Receive Data Ready 0." "0,1"
        textline "    "
        bitfld.long 0x00 15. " RDR1 ,Receive Data Ready 1." "0,1"
        textline "    "
        bitfld.long 0x00 16. " RXT ,Receive Tag Updated." "0,1"
        textline "    "
        bitfld.long 0x00 17. " CMDDU ,Command Data Register Updated." "0,1"
        textline "    "
        bitfld.long 0x00 18. " CMDAU ,Command Address Register Updated." "0,1"
        textline "    "
        bitfld.long 0x00 23. " TFRC ,Transmit Frame Complete." "0,1"
        textline "    "
        bitfld.long 0x00 24. " RFRC ,Receive Frame Complete." "0,1"
width 5.
group.long 0x18++0x3
    line.long 0x00 "SIER,SSI Interrupt Enable Register"
        bitfld.long 0x00 0. " TFE0IE ,Transmit FIFO Empty 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 1. " TFE1IE ,Transmit FIFO Empty 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RFF0IE ,Receive FIFO Full 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 3. " RFF1IE ,Receive FIFO Full 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RLSIE ,Receive Last Time Slot Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 5. " TLSIE ,Transmit Last Time Slot Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RFSIE ,Receive Frame Sync Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 7. " TFSIE ,Transmit Frame Sync Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 8. " TUE0IE ,Transmitter Underrun Error 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 9. " TUE1IE ,Transmitter Underrun Error 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 10. " ROE0IE ,Receiver Overrun Error 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ROE1IE ,Receiver Overrun Error 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 12. " TDE0IE ,Transmit Data Register Empty 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 13. " TDE1IE ,Transmit Data Register Empty 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 14. " RDR0IE ,Receive Data Ready 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 15. " RDR1IE ,Receive Data Ready 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 16. " RXTIE ,Receive Tag Updated Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 17. " CMDDUIE ,Command Data Register Updated Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 18. " CMDAUIE ,Command Address Register Updated Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 19. " TIE ,Transmit Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 20. " TDMAE ,Transmit DMA Enable." "0,1"
        textline "    "
        bitfld.long 0x00 21. " RIE ,Receive Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 22. " RDMAE ,Receive DMA Enable." "0,1"
        textline "    "
        bitfld.long 0x00 23. " TFRCIE ,Transmit Frame Complete Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 24. " RFRCIE ,Receive Frame Complete Interrupt Enable." "0,1"
width 5.
group.long 0x1c++0x3
    line.long 0x00 "STCR,SSI Transmit Configuration Register"
        bitfld.long 0x00 0. " TEFS ,Transmit Early Frame Sync." "0,1"
        textline "    "
        bitfld.long 0x00 1. " TFSL ,Transmit Frame Sync Length." "0,1"
        textline "    "
        bitfld.long 0x00 2. " TFSI ,Transmit Frame Sync Invert." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TSCKP ,Transmit Clock Polarity." "0,1"
        textline "    "
        bitfld.long 0x00 4. " TSHFD ,Transmit Shift Direction." "0,1"
        textline "    "
        bitfld.long 0x00 5. " TXDIR ,Transmit Clock Direction." "0,1"
        textline "    "
        bitfld.long 0x00 6. " TFDIR ,Transmit Frame Direction." "0,1"
        textline "    "
        bitfld.long 0x00 7. " TFEN0 ,Transmit FIFO Enable 0." "0,1"
        textline "    "
        bitfld.long 0x00 8. " TFEN1 ,Transmit FIFO Enable 1." "0,1"
        textline "    "
        bitfld.long 0x00 9. " TXBIT0 ,Transmit Bit 0." "0,1"
width 5.
group.long 0x20++0x3
    line.long 0x00 "SRCR,SSI Receive Configuration Register"
        bitfld.long 0x00 0. " REFS ,Receive Early Frame Sync." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RFSL ,Receive Frame Sync Length." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RFSI ,Receive Frame Sync Invert." "0,1"
        textline "    "
        bitfld.long 0x00 3. " RSCKP ,Receive Clock Polarity." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RSHFD ,Receive Shift Direction." "0,1"
        textline "    "
        bitfld.long 0x00 5. " RXDIR ,Receive Clock Direction." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RFDIR ,Receive Frame Direction." "0,1"
        textline "    "
        bitfld.long 0x00 7. " RFEN0 ,Receive FIFO Enable 0." "0,1"
        textline "    "
        bitfld.long 0x00 8. " RFEN1 ,Receive FIFO Enable 1." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RXBIT0 ,Receive Bit 0." "0,1"
        textline "    "
        bitfld.long 0x00 10. " RXEXT ,Receive Data Extension." "0,1"
width 6.
group.long 0x24++0x3
    line.long 0x00 "STCCR,SSI Transmit Clock Control Register"
        hexmask.long.byte 0x00 0.--8. 1. " PM7_PM0 ,Prescaler Modulus Select."
        textline "     "
        hexmask.long.byte 0x00 8.--13. 1. " DC4_DC0 ,Frame Rate Divider Control."
        textline "     "
        hexmask.long.byte 0x00 13.--17. 1. " WL3_WL0 ,Word Length Control."
        textline "     "
        bitfld.long 0x00 17. " PSR ,Prescaler Range." "0,1"
        textline "     "
        bitfld.long 0x00 18. " DIV2 ,Divide By 2." "0,1"
width 6.
group.long 0x28++0x3
    line.long 0x00 "SRCCR,SSI Receive Clock Control Register"
        hexmask.long.byte 0x00 0.--8. 1. " PM7_PM0 ,Prescaler Modulus Select."
        textline "     "
        hexmask.long.byte 0x00 8.--13. 1. " DC4_DC0 ,Frame Rate Divider Control."
        textline "     "
        hexmask.long.byte 0x00 13.--17. 1. " WL3_WL0 ,Word Length Control."
        textline "     "
        bitfld.long 0x00 17. " PSR ,Prescaler Range." "0,1"
        textline "     "
        bitfld.long 0x00 18. " DIV2 ,Divide By 2." "0,1"
width 6.
group.long 0x2c++0x3
    line.long 0x00 "SFCSR,SSI FIFO Control/Status Register"
        hexmask.long.byte 0x00 0.--4. 1. " TFWM0 ,Transmit FIFO Empty WaterMark 0."
        textline "     "
        hexmask.long.byte 0x00 4.--8. 1. " RFWM0 ,Receive FIFO Full WaterMark 0."
        textline "     "
        hexmask.long.byte 0x00 8.--12. 1. " TFCNT0 ,Transmit FIFO Counter 0."
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " RFCNT0 ,Receive FIFO Counter 0."
        textline "     "
        hexmask.long.byte 0x00 16.--20. 1. " TFWM1 ,Transmit FIFO Empty WaterMark 1."
        textline "     "
        hexmask.long.byte 0x00 20.--24. 1. " RFWM1 ,Receive FIFO Full WaterMark 1."
        textline "     "
        hexmask.long.byte 0x00 24.--28. 1. " TFCNT1 ,Transmit FIFO Counter1."
        textline "     "
        hexmask.long.byte 0x00 28.--32. 1. " RFCNT1 ,Receive FIFO Counter1."
width 6.
group.long 0x38++0x3
    line.long 0x00 "SACNT,SSI AC97 Control Register"
        bitfld.long 0x00 0. " AC97EN ,AC97 Mode Enable." "0,1"
        textline "     "
        bitfld.long 0x00 1. " FV ,Fixed/Variable Operation." "0,1"
        textline "     "
        bitfld.long 0x00 2. " TIF ,Tag in FIFO." "0,1"
        textline "     "
        bitfld.long 0x00 3. " RD ,Read Command." "0,1"
        textline "     "
        bitfld.long 0x00 4. " WR ,Write Command." "0,1"
        textline "     "
        hexmask.long.byte 0x00 5.--11. 1. " FRDIV ,Frame Rate Divider."
width 7.
group.long 0x3c++0x3
    line.long 0x00 "SACADD,SSI AC97 Command Address Register"
        hexmask.long.long 0x00 0.--19. 1. " SACADD ,AC97 Command Address."
width 7.
group.long 0x40++0x3
    line.long 0x00 "SACDAT,SSI AC97 Command Data Register"
        hexmask.long.long 0x00 0.--20. 1. " SACDAT ,AC97 Command Data."
width 6.
group.long 0x44++0x3
    line.long 0x00 "SATAG,SSI AC97 Tag Register"
        hexmask.long.word 0x00 0.--16. 1. " SATAG ,AC97 Tag Value."
width 6.
group.long 0x48++0x3
    line.long 0x00 "STMSK,SSI Transmit Time Slot Mask Register"
        hexmask.long.long 0x00 0.--32. 1. " STMSK ,Transmit Mask."
width 6.
group.long 0x4c++0x3
    line.long 0x00 "SRMSK,SSI Receive Time Slot Mask Register"
        hexmask.long.long 0x00 0.--32. 1. " SRMSK ,Receive Mask."
width 7.
rgroup.long 0x50++0x3
    line.long 0x00 "SACCST,SSI AC97 Channel Status Register"
        hexmask.long.word 0x00 0.--10. 1. " SACCST ,AC97 Channel Status."
width 7.
wgroup.long 0x54++0x3
    line.long 0x00 "SACCEN,SSI AC97 Channel Enable Register"
        hexmask.long.word 0x00 0.--10. 1. " SACCEN ,AC97 Channel Enable."
width 8.
wgroup.long 0x58++0x3
    line.long 0x00 "SACCDIS,SSI AC97 Channel Disable Register"
        hexmask.long.word 0x00 0.--10. 1. " SACCDIS ,AC97 Channel Disable."


    tree.end
    tree "SSI3"
        base ad:0x02030000

width 5.
group.long 0x0++0x3
    line.long 0x00 "STX0,SSI Transmit Data Register n"
        hexmask.long.long 0x00 0.--32. 1. " STXN ,SSI Transmit Data."
width 5.
group.long 0x4++0x3
    line.long 0x00 "STX1,SSI Transmit Data Register n"
        hexmask.long.long 0x00 0.--32. 1. " STXN ,SSI Transmit Data."
width 5.
rgroup.long 0x8++0x3
    line.long 0x00 "SRX0,SSI Receive Data Register n"
        hexmask.long.long 0x00 0.--32. 1. " SRXN ,SSI Receive Data."
width 5.
rgroup.long 0xc++0x3
    line.long 0x00 "SRX1,SSI Receive Data Register n"
        hexmask.long.long 0x00 0.--32. 1. " SRXN ,SSI Receive Data."
width 4.
group.long 0x10++0x3
    line.long 0x00 "SCR,SSI Control Register"
        bitfld.long 0x00 0. " SSIEN ,SSIEN - SSI Enable This bit is used to enable/disable the SSI." "0,1"
        textline "   "
        bitfld.long 0x00 1. " TE ,Transmit Enable." "0,1"
        textline "   "
        bitfld.long 0x00 2. " RE ,Receive Enable." "0,1"
        textline "   "
        bitfld.long 0x00 3. " NET ,Network Mode." "0,1"
        textline "   "
        bitfld.long 0x00 4. " SYN ,Synchronous Mode." "0,1"
        textline "   "
        hexmask.long.byte 0x00 5.--7. 1. " I2S_MODE ,I2S Mode Select."
        textline "   "
        bitfld.long 0x00 7. " SYS_CLK_EN ,Network Clock (Oversampling Clock) Enable." "0,1"
        textline "   "
        bitfld.long 0x00 8. " TCH_EN ,Two-Channel Operation Enable." "0,1"
        textline "   "
        bitfld.long 0x00 9. " CLK_IST ,Clock Idle State." "0,1"
        textline "   "
        bitfld.long 0x00 10. " TFR_CLK_DIS ,Transmit Frame Clock Disable." "0,1"
        textline "   "
        bitfld.long 0x00 11. " RFR_CLK_DIS ,Receive Frame Clock Disable." "0,1"
        textline "   "
        bitfld.long 0x00 12. " SYNC_TX_FS ,SYNC_FS_TX bit provides a safe window for TE to be visible to the internal circuit which is just after FS occurrence." "0,1"
width 5.
group.long 0x14++0x3
    line.long 0x00 "SISR,SSI Interrupt Status Register"
        bitfld.long 0x00 0. " TFE0 ,Transmit FIFO Empty 0." "0,1"
        textline "    "
        bitfld.long 0x00 1. " TFE1 ,Transmit FIFO Empty 1." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RFF0 ,Receive FIFO Full 0." "0,1"
        textline "    "
        bitfld.long 0x00 3. " RFF1 ,Receive FIFO Full 1." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RLS ,Receive Last Time Slot." "0,1"
        textline "    "
        bitfld.long 0x00 5. " TLS ,Transmit Last Time Slot." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RFS ,Receive Frame Sync." "0,1"
        textline "    "
        bitfld.long 0x00 7. " TFS ,Transmit Frame Sync." "0,1"
        textline "    "
        bitfld.long 0x00 8. " TUE0 ,Transmitter Underrun Error 0." "0,1"
        textline "    "
        bitfld.long 0x00 9. " TUE1 ,Transmitter Underrun Error 1." "0,1"
        textline "    "
        bitfld.long 0x00 10. " ROE0 ,Receiver Overrun Error 0." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ROE1 ,Receiver Overrun Error 1." "0,1"
        textline "    "
        bitfld.long 0x00 12. " TDE0 ,Transmit Data Register Empty 0." "0,1"
        textline "    "
        bitfld.long 0x00 13. " TDE1 ,Transmit Data Register Empty 1." "0,1"
        textline "    "
        bitfld.long 0x00 14. " RDR0 ,Receive Data Ready 0." "0,1"
        textline "    "
        bitfld.long 0x00 15. " RDR1 ,Receive Data Ready 1." "0,1"
        textline "    "
        bitfld.long 0x00 16. " RXT ,Receive Tag Updated." "0,1"
        textline "    "
        bitfld.long 0x00 17. " CMDDU ,Command Data Register Updated." "0,1"
        textline "    "
        bitfld.long 0x00 18. " CMDAU ,Command Address Register Updated." "0,1"
        textline "    "
        bitfld.long 0x00 23. " TFRC ,Transmit Frame Complete." "0,1"
        textline "    "
        bitfld.long 0x00 24. " RFRC ,Receive Frame Complete." "0,1"
width 5.
group.long 0x18++0x3
    line.long 0x00 "SIER,SSI Interrupt Enable Register"
        bitfld.long 0x00 0. " TFE0IE ,Transmit FIFO Empty 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 1. " TFE1IE ,Transmit FIFO Empty 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RFF0IE ,Receive FIFO Full 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 3. " RFF1IE ,Receive FIFO Full 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RLSIE ,Receive Last Time Slot Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 5. " TLSIE ,Transmit Last Time Slot Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RFSIE ,Receive Frame Sync Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 7. " TFSIE ,Transmit Frame Sync Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 8. " TUE0IE ,Transmitter Underrun Error 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 9. " TUE1IE ,Transmitter Underrun Error 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 10. " ROE0IE ,Receiver Overrun Error 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ROE1IE ,Receiver Overrun Error 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 12. " TDE0IE ,Transmit Data Register Empty 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 13. " TDE1IE ,Transmit Data Register Empty 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 14. " RDR0IE ,Receive Data Ready 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 15. " RDR1IE ,Receive Data Ready 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 16. " RXTIE ,Receive Tag Updated Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 17. " CMDDUIE ,Command Data Register Updated Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 18. " CMDAUIE ,Command Address Register Updated Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 19. " TIE ,Transmit Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 20. " TDMAE ,Transmit DMA Enable." "0,1"
        textline "    "
        bitfld.long 0x00 21. " RIE ,Receive Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 22. " RDMAE ,Receive DMA Enable." "0,1"
        textline "    "
        bitfld.long 0x00 23. " TFRCIE ,Transmit Frame Complete Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 24. " RFRCIE ,Receive Frame Complete Interrupt Enable." "0,1"
width 5.
group.long 0x1c++0x3
    line.long 0x00 "STCR,SSI Transmit Configuration Register"
        bitfld.long 0x00 0. " TEFS ,Transmit Early Frame Sync." "0,1"
        textline "    "
        bitfld.long 0x00 1. " TFSL ,Transmit Frame Sync Length." "0,1"
        textline "    "
        bitfld.long 0x00 2. " TFSI ,Transmit Frame Sync Invert." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TSCKP ,Transmit Clock Polarity." "0,1"
        textline "    "
        bitfld.long 0x00 4. " TSHFD ,Transmit Shift Direction." "0,1"
        textline "    "
        bitfld.long 0x00 5. " TXDIR ,Transmit Clock Direction." "0,1"
        textline "    "
        bitfld.long 0x00 6. " TFDIR ,Transmit Frame Direction." "0,1"
        textline "    "
        bitfld.long 0x00 7. " TFEN0 ,Transmit FIFO Enable 0." "0,1"
        textline "    "
        bitfld.long 0x00 8. " TFEN1 ,Transmit FIFO Enable 1." "0,1"
        textline "    "
        bitfld.long 0x00 9. " TXBIT0 ,Transmit Bit 0." "0,1"
width 5.
group.long 0x20++0x3
    line.long 0x00 "SRCR,SSI Receive Configuration Register"
        bitfld.long 0x00 0. " REFS ,Receive Early Frame Sync." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RFSL ,Receive Frame Sync Length." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RFSI ,Receive Frame Sync Invert." "0,1"
        textline "    "
        bitfld.long 0x00 3. " RSCKP ,Receive Clock Polarity." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RSHFD ,Receive Shift Direction." "0,1"
        textline "    "
        bitfld.long 0x00 5. " RXDIR ,Receive Clock Direction." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RFDIR ,Receive Frame Direction." "0,1"
        textline "    "
        bitfld.long 0x00 7. " RFEN0 ,Receive FIFO Enable 0." "0,1"
        textline "    "
        bitfld.long 0x00 8. " RFEN1 ,Receive FIFO Enable 1." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RXBIT0 ,Receive Bit 0." "0,1"
        textline "    "
        bitfld.long 0x00 10. " RXEXT ,Receive Data Extension." "0,1"
width 6.
group.long 0x24++0x3
    line.long 0x00 "STCCR,SSI Transmit Clock Control Register"
        hexmask.long.byte 0x00 0.--8. 1. " PM7_PM0 ,Prescaler Modulus Select."
        textline "     "
        hexmask.long.byte 0x00 8.--13. 1. " DC4_DC0 ,Frame Rate Divider Control."
        textline "     "
        hexmask.long.byte 0x00 13.--17. 1. " WL3_WL0 ,Word Length Control."
        textline "     "
        bitfld.long 0x00 17. " PSR ,Prescaler Range." "0,1"
        textline "     "
        bitfld.long 0x00 18. " DIV2 ,Divide By 2." "0,1"
width 6.
group.long 0x28++0x3
    line.long 0x00 "SRCCR,SSI Receive Clock Control Register"
        hexmask.long.byte 0x00 0.--8. 1. " PM7_PM0 ,Prescaler Modulus Select."
        textline "     "
        hexmask.long.byte 0x00 8.--13. 1. " DC4_DC0 ,Frame Rate Divider Control."
        textline "     "
        hexmask.long.byte 0x00 13.--17. 1. " WL3_WL0 ,Word Length Control."
        textline "     "
        bitfld.long 0x00 17. " PSR ,Prescaler Range." "0,1"
        textline "     "
        bitfld.long 0x00 18. " DIV2 ,Divide By 2." "0,1"
width 6.
group.long 0x2c++0x3
    line.long 0x00 "SFCSR,SSI FIFO Control/Status Register"
        hexmask.long.byte 0x00 0.--4. 1. " TFWM0 ,Transmit FIFO Empty WaterMark 0."
        textline "     "
        hexmask.long.byte 0x00 4.--8. 1. " RFWM0 ,Receive FIFO Full WaterMark 0."
        textline "     "
        hexmask.long.byte 0x00 8.--12. 1. " TFCNT0 ,Transmit FIFO Counter 0."
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " RFCNT0 ,Receive FIFO Counter 0."
        textline "     "
        hexmask.long.byte 0x00 16.--20. 1. " TFWM1 ,Transmit FIFO Empty WaterMark 1."
        textline "     "
        hexmask.long.byte 0x00 20.--24. 1. " RFWM1 ,Receive FIFO Full WaterMark 1."
        textline "     "
        hexmask.long.byte 0x00 24.--28. 1. " TFCNT1 ,Transmit FIFO Counter1."
        textline "     "
        hexmask.long.byte 0x00 28.--32. 1. " RFCNT1 ,Receive FIFO Counter1."
width 6.
group.long 0x38++0x3
    line.long 0x00 "SACNT,SSI AC97 Control Register"
        bitfld.long 0x00 0. " AC97EN ,AC97 Mode Enable." "0,1"
        textline "     "
        bitfld.long 0x00 1. " FV ,Fixed/Variable Operation." "0,1"
        textline "     "
        bitfld.long 0x00 2. " TIF ,Tag in FIFO." "0,1"
        textline "     "
        bitfld.long 0x00 3. " RD ,Read Command." "0,1"
        textline "     "
        bitfld.long 0x00 4. " WR ,Write Command." "0,1"
        textline "     "
        hexmask.long.byte 0x00 5.--11. 1. " FRDIV ,Frame Rate Divider."
width 7.
group.long 0x3c++0x3
    line.long 0x00 "SACADD,SSI AC97 Command Address Register"
        hexmask.long.long 0x00 0.--19. 1. " SACADD ,AC97 Command Address."
width 7.
group.long 0x40++0x3
    line.long 0x00 "SACDAT,SSI AC97 Command Data Register"
        hexmask.long.long 0x00 0.--20. 1. " SACDAT ,AC97 Command Data."
width 6.
group.long 0x44++0x3
    line.long 0x00 "SATAG,SSI AC97 Tag Register"
        hexmask.long.word 0x00 0.--16. 1. " SATAG ,AC97 Tag Value."
width 6.
group.long 0x48++0x3
    line.long 0x00 "STMSK,SSI Transmit Time Slot Mask Register"
        hexmask.long.long 0x00 0.--32. 1. " STMSK ,Transmit Mask."
width 6.
group.long 0x4c++0x3
    line.long 0x00 "SRMSK,SSI Receive Time Slot Mask Register"
        hexmask.long.long 0x00 0.--32. 1. " SRMSK ,Receive Mask."
width 7.
rgroup.long 0x50++0x3
    line.long 0x00 "SACCST,SSI AC97 Channel Status Register"
        hexmask.long.word 0x00 0.--10. 1. " SACCST ,AC97 Channel Status."
width 7.
wgroup.long 0x54++0x3
    line.long 0x00 "SACCEN,SSI AC97 Channel Enable Register"
        hexmask.long.word 0x00 0.--10. 1. " SACCEN ,AC97 Channel Enable."
width 8.
wgroup.long 0x58++0x3
    line.long 0x00 "SACCDIS,SSI AC97 Channel Disable Register"
        hexmask.long.word 0x00 0.--10. 1. " SACCDIS ,AC97 Channel Disable."


    tree.end

tree.end



;--------------------------------------------------------------------------------
; TEMPMON
;--------------------------------------------------------------------------------
tree "TEMPMON"
    base ad:0x020c8000

width 11.
group.long 0x180++0x3
    line.long 0x00 "TEMPSENSE0,Tempsensor Control Register 0"
        bitfld.long 0x00 0. " POWER_DOWN ,This bit powers down the temperature sensor." "0,1"
        textline "          "
        bitfld.long 0x00 1. " MEASURE_TEMP ,Starts the measurement process." "0,1"
        textline "          "
        bitfld.long 0x00 2. " FINISHED ,Indicates that the latest temp is valid." "0,1"
        textline "          "
        hexmask.long.word 0x00 8.--20. 1. " TEMP_CNT ,This bit field contains the last measured temperature count."
        textline "          "
        hexmask.long.word 0x00 20.--32. 1. " ALARM_VALUE ,This bit field contains the temperature count (raw sensor output) that will generate an alarm interrupt."
width 11.
group.long 0x190++0x3
    line.long 0x00 "TEMPSENSE1,Tempsensor Control Register 1"
        hexmask.long.word 0x00 0.--16. 1. " MEASURE_FREQ ,This bits determines how many RTC clocks to wait before automatically repeating a temperature measurement."


tree.end



;--------------------------------------------------------------------------------
; UART
;--------------------------------------------------------------------------------
tree.open "UART"
    tree "UART1"
        base ad:0x02020000

width 5.
rgroup.long 0x0++0x3
    line.long 0x00 "URXD,UART Receiver Register"
        hexmask.long.byte 0x00 0.--8. 1. " RX_DATA ,Received Data ."
        textline "    "
        bitfld.long 0x00 10. " PRERR ,In RS-485 mode, it holds the ninth data bit (bit [8]) of received 9-bit RS-485 data In RS232/IrDA mode, it is the Parity Error flag ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " BRK ,BREAK Detect." "0,1"
        textline "    "
        bitfld.long 0x00 12. " FRMERR ,Frame Error." "0,1"
        textline "    "
        bitfld.long 0x00 13. " OVRRUN ,Receiver Overrun." "0,1"
        textline "    "
        bitfld.long 0x00 14. " ERR ,Error Detect." "0,1"
        textline "    "
        bitfld.long 0x00 15. " CHARRDY ,Character Ready." "0,1"
width 5.
wgroup.long 0x40++0x3
    line.long 0x00 "UTXD,UART Transmitter Register"
        hexmask.long.byte 0x00 0.--8. 1. " TX_DATA ,Transmit Data ."
width 5.
group.long 0x80++0x3
    line.long 0x00 "UCR1,UART Control Register 1"
        bitfld.long 0x00 0. " UARTEN ,UART Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " DOZE ,DOZE ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " ATDMAEN ,Aging DMA Timer Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TXDMAEN ,Transmitter Ready DMA Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " SNDBRK ,Send BREAK ." "0,1"
        textline "    "
        bitfld.long 0x00 5. " RTSDEN ,RTS Delta Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " TXMPTYEN ,Transmitter Empty Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 7. " IREN ,Infrared Interface Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " RXDMAEN ,Receive Ready DMA Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RRDYEN ,Receiver Ready Interrupt Enable ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICD ,Idle Condition Detect ."
        textline "    "
        bitfld.long 0x00 12. " IDEN ,Idle Condition Detected Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 13. " TRDYEN ,Transmitter Ready Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " ADBR ,Automatic Detection of Baud Rate ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ADEN ,Automatic Baud Rate Detection Interrupt Enable ." "0,1"
width 5.
group.long 0x84++0x3
    line.long 0x00 "UCR2,UART Control Register 2"
        bitfld.long 0x00 0. " SRST ,Software Reset ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RXEN ,Receiver Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " TXEN ,Transmitter Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " ATEN ,Aging Timer Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RTSEN ,Request to Send Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 5. " WS ,Word Size ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " STPB ,Stop ." "0,1"
        textline "    "
        bitfld.long 0x00 7. " PROE ,Parity Odd/Even ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " PREN ,Parity Enable ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 9.--11. 1. " RTEC ,Request to Send Edge Control ."
        textline "    "
        bitfld.long 0x00 11. " ESCEN ,Escape Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 12. " CTS ,Clear to Send ." "0,1"
        textline "    "
        bitfld.long 0x00 13. " CTSC ,CTS Pin Control ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " IRTS ,Ignore RTS Pin ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ESCI ,Escape Sequence Interrupt Enable ." "0,1"
width 5.
group.long 0x88++0x3
    line.long 0x00 "UCR3,UART Control Register 3"
        bitfld.long 0x00 0. " ACIEN ,Autobaud Counter Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 1. " INVT ,Invert TXD output in RS-232/RS-485 mode, set TXD active level in IrDA mode." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RXDMUXSEL ,RXD Muxed Input Selected." "0,1"
        textline "    "
        bitfld.long 0x00 3. " DTRDEN ,Data Terminal Ready Delta Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " AWAKEN ,Asynchronous WAKE Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 5. " AIRINTEN ,Asynchronous IR WAKE Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RXDSEN ,Receive Status Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 7. " ADNIMP ,Autobaud Detection Not Improved-." "0,1"
        textline "    "
        bitfld.long 0x00 8. " RI ,Ring Indicator ." "0,1"
        textline "    "
        bitfld.long 0x00 9. " DCD ,Data Carrier Detect ." "0,1"
        textline "    "
        bitfld.long 0x00 10. " DSR ,Data Set Ready ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " FRAERREN ,Frame Error Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 12. " PARERREN ,Parity Error Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 13. " DTREN ,Data Terminal Ready Interrupt Enable ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " DPEC ,DTR/DSR Interrupt Edge Control ."
width 5.
group.long 0x8c++0x3
    line.long 0x00 "UCR4,UART Control Register 4"
        bitfld.long 0x00 0. " DREN ,Receive Data Ready Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " OREN ,Receiver Overrun Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " BKEN ,BREAK Condition Detected Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TCEN ,Transmit Complete Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " LPBYP ,Low Power Bypass ." "0,1"
        textline "    "
        bitfld.long 0x00 5. " IRSC ,IR Special Case ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " IDDMAEN ,DMA IDLE Condition Detected Interrupt Enable Enables/Disables the receive DMA request dma_req_rx for the IDLE interrupt (triggered with IDLE flag in USR2[12])." "0,1"
        textline "    "
        bitfld.long 0x00 7. " WKEN ,WAKE Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " ENIRI ,Serial Infrared Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 9. " INVR ,Invert RXD input in RS-232/RS-485 Mode, d etermine RXD input logic level being sampled in In IrDA mode." "0,1"
        textline "    "
        hexmask.long.byte 0x00 10.--16. 1. " CTSTL ,CTS Trigger Level ."
width 5.
group.long 0x90++0x3
    line.long 0x00 "UFCR,UART FIFO Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " RXTL ,Receiver Trigger Level ."
        textline "    "
        bitfld.long 0x00 6. " DCEDTE ,DCE/DTE mode select ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 7.--10. 1. " RFDIV ,Reference Frequency Divider."
        textline "    "
        hexmask.long.byte 0x00 10.--16. 1. " TXTL ,Transmitter Trigger Level ."
width 5.
group.long 0x94++0x3
    line.long 0x00 "USR1,UART Status Register 1"
        bitfld.long 0x00 3. " SAD ,RS-485 Slave Address Detected Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 4. " AWAKE ,Asynchronous WAKE Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 5. " AIRINT ,Asynchronous IR WAKE Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RXDS ,Receiver IDLE Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 7. " DTRD ,DTR Delta." "0,1"
        textline "    "
        bitfld.long 0x00 8. " AGTIM ,Ageing Timer Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RRDY ,Receiver Ready Interrupt / DMA Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 10. " FRAMERR ,Frame Error Interrupt Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ESCF ,Escape Sequence Interrupt Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 12. " RTSD ,RTS Delta." "0,1"
        textline "    "
        bitfld.long 0x00 13. " TRDY ,Transmitter Ready Interrupt / DMA Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " RTSS ,RTS Pin Status ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " PARITYERR ,Parity Error Interrupt Flag ." "0,1"
width 5.
group.long 0x98++0x3
    line.long 0x00 "USR2,UART Status Register 2"
        bitfld.long 0x00 0. " RDR ,Receive Data Ready -Indicates that at least 1 character is received and written to the RxFIFO." "0,1"
        textline "    "
        bitfld.long 0x00 1. " ORE ,Overrun Error ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " BRCD ,BREAK Condition Detected ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TXDC ,Transmitter Complete ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RTSF ,RTS Edge Triggered Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 5. " DCDIN ,Data Carrier Detect Input ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " DCDDELT ,Data Carrier Detect Delta ." "0,1"
        textline "    "
        bitfld.long 0x00 7. " WAKE ,Wake ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " IRINT ,Serial Infrared Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RIIN ,Ring Indicator Input ." "0,1"
        textline "    "
        bitfld.long 0x00 10. " RIDELT ,Ring Indicator Delta ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ACST ,Autobaud Counter Stopped ." "0,1"
        textline "    "
        bitfld.long 0x00 12. " IDLE ,Idle Condition ." "0,1"
        textline "    "
        bitfld.long 0x00 13. " DTRF ,DTR edge triggered interrupt flag ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " TXFE ,Transmit Buffer FIFO Empty ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ADET ,Automatic Baud Rate Detect Complete ." "0,1"
width 5.
group.long 0x9c++0x3
    line.long 0x00 "UESC,UART Escape Character Register"
        hexmask.long.byte 0x00 0.--8. 1. " ESC_CHAR ,UART Escape Character ."
width 5.
group.long 0xa0++0x3
    line.long 0x00 "UTIM,UART Escape Timer Register"
        hexmask.long.word 0x00 0.--12. 1. " TIM ,UART Escape Timer."
width 5.
group.long 0xa4++0x3
    line.long 0x00 "UBIR,UART BRM Incremental Register"
        hexmask.long.word 0x00 0.--16. 1. " INC ,Incremental Numerator."
width 5.
group.long 0xa8++0x3
    line.long 0x00 "UBMR,UART BRM Modulator Register"
        hexmask.long.word 0x00 0.--16. 1. " MOD ,Modulator Denominator."
width 5.
rgroup.long 0xac++0x3
    line.long 0x00 "UBRC,UART Baud Rate Count Register"
        hexmask.long.word 0x00 0.--16. 1. " BCNT ,Baud Rate Count Register."
width 6.
group.long 0xb0++0x3
    line.long 0x00 "ONEMS,UART One Millisecond Register"
        hexmask.long.long 0x00 0.--24. 1. " ONEMS ,One Millisecond Register."
width 4.
group.long 0xb4++0x3
    line.long 0x00 "UTS,UART Test Register"
        bitfld.long 0x00 0. " SOFTRST ,Software Reset." "0,1"
        textline "   "
        bitfld.long 0x00 3. " RXFULL ,RxFIFO FULL." "0,1"
        textline "   "
        bitfld.long 0x00 4. " TXFULL ,TxFIFO FULL." "0,1"
        textline "   "
        bitfld.long 0x00 5. " RXEMPTY ,RxFIFO Empty." "0,1"
        textline "   "
        bitfld.long 0x00 6. " TXEMPTY ,TxFIFO Empty." "0,1"
        textline "   "
        bitfld.long 0x00 9. " RXDBG ,RX_fifo_debug_mode." "0,1"
        textline "   "
        bitfld.long 0x00 10. " LOOPIR ,Loop TX and RX for IR Test (LOOPIR) ." "0,1"
        textline "   "
        bitfld.long 0x00 11. " DBGEN ,debug_enable ." "0,1"
        textline "   "
        bitfld.long 0x00 12. " LOOP ,Loop TX and RX for Test." "0,1"
        textline "   "
        bitfld.long 0x00 13. " FRCPERR ,Force Parity Error." "0,1"
width 5.
group.long 0xb8++0x3
    line.long 0x00 "UMCR,UART RS-485 Mode Control Register"
        bitfld.long 0x00 0. " MDEN ,9-bit data or Multidrop Mode (RS-485) Enable." "0,1"
        textline "    "
        bitfld.long 0x00 1. " SLAM ,RS-485 Slave Address Detect Mode Selection." "0,1"
        textline "    "
        bitfld.long 0x00 2. " TXB8 ,Transmit RS-485 bit 8 (the ninth bit or 9 th bit)." "0,1"
        textline "    "
        bitfld.long 0x00 3. " SADEN ,RS-485 Slave Address Detected Interrupt Enable." "0,1"
        textline "    "
        hexmask.long.byte 0x00 8.--16. 1. " SLADDR ,RS-485 Slave Address Character."


    tree.end
    tree "UART2"
        base ad:0x02024000

width 5.
rgroup.long 0x0++0x3
    line.long 0x00 "URXD,UART Receiver Register"
        hexmask.long.byte 0x00 0.--8. 1. " RX_DATA ,Received Data ."
        textline "    "
        bitfld.long 0x00 10. " PRERR ,In RS-485 mode, it holds the ninth data bit (bit [8]) of received 9-bit RS-485 data In RS232/IrDA mode, it is the Parity Error flag ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " BRK ,BREAK Detect." "0,1"
        textline "    "
        bitfld.long 0x00 12. " FRMERR ,Frame Error." "0,1"
        textline "    "
        bitfld.long 0x00 13. " OVRRUN ,Receiver Overrun." "0,1"
        textline "    "
        bitfld.long 0x00 14. " ERR ,Error Detect." "0,1"
        textline "    "
        bitfld.long 0x00 15. " CHARRDY ,Character Ready." "0,1"
width 5.
wgroup.long 0x40++0x3
    line.long 0x00 "UTXD,UART Transmitter Register"
        hexmask.long.byte 0x00 0.--8. 1. " TX_DATA ,Transmit Data ."
width 5.
group.long 0x80++0x3
    line.long 0x00 "UCR1,UART Control Register 1"
        bitfld.long 0x00 0. " UARTEN ,UART Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " DOZE ,DOZE ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " ATDMAEN ,Aging DMA Timer Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TXDMAEN ,Transmitter Ready DMA Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " SNDBRK ,Send BREAK ." "0,1"
        textline "    "
        bitfld.long 0x00 5. " RTSDEN ,RTS Delta Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " TXMPTYEN ,Transmitter Empty Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 7. " IREN ,Infrared Interface Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " RXDMAEN ,Receive Ready DMA Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RRDYEN ,Receiver Ready Interrupt Enable ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICD ,Idle Condition Detect ."
        textline "    "
        bitfld.long 0x00 12. " IDEN ,Idle Condition Detected Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 13. " TRDYEN ,Transmitter Ready Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " ADBR ,Automatic Detection of Baud Rate ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ADEN ,Automatic Baud Rate Detection Interrupt Enable ." "0,1"
width 5.
group.long 0x84++0x3
    line.long 0x00 "UCR2,UART Control Register 2"
        bitfld.long 0x00 0. " SRST ,Software Reset ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RXEN ,Receiver Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " TXEN ,Transmitter Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " ATEN ,Aging Timer Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RTSEN ,Request to Send Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 5. " WS ,Word Size ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " STPB ,Stop ." "0,1"
        textline "    "
        bitfld.long 0x00 7. " PROE ,Parity Odd/Even ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " PREN ,Parity Enable ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 9.--11. 1. " RTEC ,Request to Send Edge Control ."
        textline "    "
        bitfld.long 0x00 11. " ESCEN ,Escape Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 12. " CTS ,Clear to Send ." "0,1"
        textline "    "
        bitfld.long 0x00 13. " CTSC ,CTS Pin Control ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " IRTS ,Ignore RTS Pin ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ESCI ,Escape Sequence Interrupt Enable ." "0,1"
width 5.
group.long 0x88++0x3
    line.long 0x00 "UCR3,UART Control Register 3"
        bitfld.long 0x00 0. " ACIEN ,Autobaud Counter Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 1. " INVT ,Invert TXD output in RS-232/RS-485 mode, set TXD active level in IrDA mode." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RXDMUXSEL ,RXD Muxed Input Selected." "0,1"
        textline "    "
        bitfld.long 0x00 3. " DTRDEN ,Data Terminal Ready Delta Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " AWAKEN ,Asynchronous WAKE Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 5. " AIRINTEN ,Asynchronous IR WAKE Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RXDSEN ,Receive Status Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 7. " ADNIMP ,Autobaud Detection Not Improved-." "0,1"
        textline "    "
        bitfld.long 0x00 8. " RI ,Ring Indicator ." "0,1"
        textline "    "
        bitfld.long 0x00 9. " DCD ,Data Carrier Detect ." "0,1"
        textline "    "
        bitfld.long 0x00 10. " DSR ,Data Set Ready ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " FRAERREN ,Frame Error Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 12. " PARERREN ,Parity Error Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 13. " DTREN ,Data Terminal Ready Interrupt Enable ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " DPEC ,DTR/DSR Interrupt Edge Control ."
width 5.
group.long 0x8c++0x3
    line.long 0x00 "UCR4,UART Control Register 4"
        bitfld.long 0x00 0. " DREN ,Receive Data Ready Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " OREN ,Receiver Overrun Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " BKEN ,BREAK Condition Detected Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TCEN ,Transmit Complete Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " LPBYP ,Low Power Bypass ." "0,1"
        textline "    "
        bitfld.long 0x00 5. " IRSC ,IR Special Case ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " IDDMAEN ,DMA IDLE Condition Detected Interrupt Enable Enables/Disables the receive DMA request dma_req_rx for the IDLE interrupt (triggered with IDLE flag in USR2[12])." "0,1"
        textline "    "
        bitfld.long 0x00 7. " WKEN ,WAKE Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " ENIRI ,Serial Infrared Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 9. " INVR ,Invert RXD input in RS-232/RS-485 Mode, d etermine RXD input logic level being sampled in In IrDA mode." "0,1"
        textline "    "
        hexmask.long.byte 0x00 10.--16. 1. " CTSTL ,CTS Trigger Level ."
width 5.
group.long 0x90++0x3
    line.long 0x00 "UFCR,UART FIFO Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " RXTL ,Receiver Trigger Level ."
        textline "    "
        bitfld.long 0x00 6. " DCEDTE ,DCE/DTE mode select ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 7.--10. 1. " RFDIV ,Reference Frequency Divider."
        textline "    "
        hexmask.long.byte 0x00 10.--16. 1. " TXTL ,Transmitter Trigger Level ."
width 5.
group.long 0x94++0x3
    line.long 0x00 "USR1,UART Status Register 1"
        bitfld.long 0x00 3. " SAD ,RS-485 Slave Address Detected Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 4. " AWAKE ,Asynchronous WAKE Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 5. " AIRINT ,Asynchronous IR WAKE Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RXDS ,Receiver IDLE Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 7. " DTRD ,DTR Delta." "0,1"
        textline "    "
        bitfld.long 0x00 8. " AGTIM ,Ageing Timer Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RRDY ,Receiver Ready Interrupt / DMA Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 10. " FRAMERR ,Frame Error Interrupt Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ESCF ,Escape Sequence Interrupt Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 12. " RTSD ,RTS Delta." "0,1"
        textline "    "
        bitfld.long 0x00 13. " TRDY ,Transmitter Ready Interrupt / DMA Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " RTSS ,RTS Pin Status ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " PARITYERR ,Parity Error Interrupt Flag ." "0,1"
width 5.
group.long 0x98++0x3
    line.long 0x00 "USR2,UART Status Register 2"
        bitfld.long 0x00 0. " RDR ,Receive Data Ready -Indicates that at least 1 character is received and written to the RxFIFO." "0,1"
        textline "    "
        bitfld.long 0x00 1. " ORE ,Overrun Error ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " BRCD ,BREAK Condition Detected ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TXDC ,Transmitter Complete ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RTSF ,RTS Edge Triggered Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 5. " DCDIN ,Data Carrier Detect Input ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " DCDDELT ,Data Carrier Detect Delta ." "0,1"
        textline "    "
        bitfld.long 0x00 7. " WAKE ,Wake ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " IRINT ,Serial Infrared Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RIIN ,Ring Indicator Input ." "0,1"
        textline "    "
        bitfld.long 0x00 10. " RIDELT ,Ring Indicator Delta ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ACST ,Autobaud Counter Stopped ." "0,1"
        textline "    "
        bitfld.long 0x00 12. " IDLE ,Idle Condition ." "0,1"
        textline "    "
        bitfld.long 0x00 13. " DTRF ,DTR edge triggered interrupt flag ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " TXFE ,Transmit Buffer FIFO Empty ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ADET ,Automatic Baud Rate Detect Complete ." "0,1"
width 5.
group.long 0x9c++0x3
    line.long 0x00 "UESC,UART Escape Character Register"
        hexmask.long.byte 0x00 0.--8. 1. " ESC_CHAR ,UART Escape Character ."
width 5.
group.long 0xa0++0x3
    line.long 0x00 "UTIM,UART Escape Timer Register"
        hexmask.long.word 0x00 0.--12. 1. " TIM ,UART Escape Timer."
width 5.
group.long 0xa4++0x3
    line.long 0x00 "UBIR,UART BRM Incremental Register"
        hexmask.long.word 0x00 0.--16. 1. " INC ,Incremental Numerator."
width 5.
group.long 0xa8++0x3
    line.long 0x00 "UBMR,UART BRM Modulator Register"
        hexmask.long.word 0x00 0.--16. 1. " MOD ,Modulator Denominator."
width 5.
rgroup.long 0xac++0x3
    line.long 0x00 "UBRC,UART Baud Rate Count Register"
        hexmask.long.word 0x00 0.--16. 1. " BCNT ,Baud Rate Count Register."
width 6.
group.long 0xb0++0x3
    line.long 0x00 "ONEMS,UART One Millisecond Register"
        hexmask.long.long 0x00 0.--24. 1. " ONEMS ,One Millisecond Register."
width 4.
group.long 0xb4++0x3
    line.long 0x00 "UTS,UART Test Register"
        bitfld.long 0x00 0. " SOFTRST ,Software Reset." "0,1"
        textline "   "
        bitfld.long 0x00 3. " RXFULL ,RxFIFO FULL." "0,1"
        textline "   "
        bitfld.long 0x00 4. " TXFULL ,TxFIFO FULL." "0,1"
        textline "   "
        bitfld.long 0x00 5. " RXEMPTY ,RxFIFO Empty." "0,1"
        textline "   "
        bitfld.long 0x00 6. " TXEMPTY ,TxFIFO Empty." "0,1"
        textline "   "
        bitfld.long 0x00 9. " RXDBG ,RX_fifo_debug_mode." "0,1"
        textline "   "
        bitfld.long 0x00 10. " LOOPIR ,Loop TX and RX for IR Test (LOOPIR) ." "0,1"
        textline "   "
        bitfld.long 0x00 11. " DBGEN ,debug_enable ." "0,1"
        textline "   "
        bitfld.long 0x00 12. " LOOP ,Loop TX and RX for Test." "0,1"
        textline "   "
        bitfld.long 0x00 13. " FRCPERR ,Force Parity Error." "0,1"
width 5.
group.long 0xb8++0x3
    line.long 0x00 "UMCR,UART RS-485 Mode Control Register"
        bitfld.long 0x00 0. " MDEN ,9-bit data or Multidrop Mode (RS-485) Enable." "0,1"
        textline "    "
        bitfld.long 0x00 1. " SLAM ,RS-485 Slave Address Detect Mode Selection." "0,1"
        textline "    "
        bitfld.long 0x00 2. " TXB8 ,Transmit RS-485 bit 8 (the ninth bit or 9 th bit)." "0,1"
        textline "    "
        bitfld.long 0x00 3. " SADEN ,RS-485 Slave Address Detected Interrupt Enable." "0,1"
        textline "    "
        hexmask.long.byte 0x00 8.--16. 1. " SLADDR ,RS-485 Slave Address Character."


    tree.end
    tree "UART3"
        base ad:0x02034000

width 5.
rgroup.long 0x0++0x3
    line.long 0x00 "URXD,UART Receiver Register"
        hexmask.long.byte 0x00 0.--8. 1. " RX_DATA ,Received Data ."
        textline "    "
        bitfld.long 0x00 10. " PRERR ,In RS-485 mode, it holds the ninth data bit (bit [8]) of received 9-bit RS-485 data In RS232/IrDA mode, it is the Parity Error flag ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " BRK ,BREAK Detect." "0,1"
        textline "    "
        bitfld.long 0x00 12. " FRMERR ,Frame Error." "0,1"
        textline "    "
        bitfld.long 0x00 13. " OVRRUN ,Receiver Overrun." "0,1"
        textline "    "
        bitfld.long 0x00 14. " ERR ,Error Detect." "0,1"
        textline "    "
        bitfld.long 0x00 15. " CHARRDY ,Character Ready." "0,1"
width 5.
wgroup.long 0x40++0x3
    line.long 0x00 "UTXD,UART Transmitter Register"
        hexmask.long.byte 0x00 0.--8. 1. " TX_DATA ,Transmit Data ."
width 5.
group.long 0x80++0x3
    line.long 0x00 "UCR1,UART Control Register 1"
        bitfld.long 0x00 0. " UARTEN ,UART Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " DOZE ,DOZE ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " ATDMAEN ,Aging DMA Timer Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TXDMAEN ,Transmitter Ready DMA Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " SNDBRK ,Send BREAK ." "0,1"
        textline "    "
        bitfld.long 0x00 5. " RTSDEN ,RTS Delta Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " TXMPTYEN ,Transmitter Empty Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 7. " IREN ,Infrared Interface Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " RXDMAEN ,Receive Ready DMA Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RRDYEN ,Receiver Ready Interrupt Enable ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICD ,Idle Condition Detect ."
        textline "    "
        bitfld.long 0x00 12. " IDEN ,Idle Condition Detected Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 13. " TRDYEN ,Transmitter Ready Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " ADBR ,Automatic Detection of Baud Rate ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ADEN ,Automatic Baud Rate Detection Interrupt Enable ." "0,1"
width 5.
group.long 0x84++0x3
    line.long 0x00 "UCR2,UART Control Register 2"
        bitfld.long 0x00 0. " SRST ,Software Reset ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RXEN ,Receiver Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " TXEN ,Transmitter Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " ATEN ,Aging Timer Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RTSEN ,Request to Send Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 5. " WS ,Word Size ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " STPB ,Stop ." "0,1"
        textline "    "
        bitfld.long 0x00 7. " PROE ,Parity Odd/Even ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " PREN ,Parity Enable ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 9.--11. 1. " RTEC ,Request to Send Edge Control ."
        textline "    "
        bitfld.long 0x00 11. " ESCEN ,Escape Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 12. " CTS ,Clear to Send ." "0,1"
        textline "    "
        bitfld.long 0x00 13. " CTSC ,CTS Pin Control ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " IRTS ,Ignore RTS Pin ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ESCI ,Escape Sequence Interrupt Enable ." "0,1"
width 5.
group.long 0x88++0x3
    line.long 0x00 "UCR3,UART Control Register 3"
        bitfld.long 0x00 0. " ACIEN ,Autobaud Counter Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 1. " INVT ,Invert TXD output in RS-232/RS-485 mode, set TXD active level in IrDA mode." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RXDMUXSEL ,RXD Muxed Input Selected." "0,1"
        textline "    "
        bitfld.long 0x00 3. " DTRDEN ,Data Terminal Ready Delta Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " AWAKEN ,Asynchronous WAKE Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 5. " AIRINTEN ,Asynchronous IR WAKE Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RXDSEN ,Receive Status Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 7. " ADNIMP ,Autobaud Detection Not Improved-." "0,1"
        textline "    "
        bitfld.long 0x00 8. " RI ,Ring Indicator ." "0,1"
        textline "    "
        bitfld.long 0x00 9. " DCD ,Data Carrier Detect ." "0,1"
        textline "    "
        bitfld.long 0x00 10. " DSR ,Data Set Ready ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " FRAERREN ,Frame Error Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 12. " PARERREN ,Parity Error Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 13. " DTREN ,Data Terminal Ready Interrupt Enable ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " DPEC ,DTR/DSR Interrupt Edge Control ."
width 5.
group.long 0x8c++0x3
    line.long 0x00 "UCR4,UART Control Register 4"
        bitfld.long 0x00 0. " DREN ,Receive Data Ready Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " OREN ,Receiver Overrun Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " BKEN ,BREAK Condition Detected Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TCEN ,Transmit Complete Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " LPBYP ,Low Power Bypass ." "0,1"
        textline "    "
        bitfld.long 0x00 5. " IRSC ,IR Special Case ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " IDDMAEN ,DMA IDLE Condition Detected Interrupt Enable Enables/Disables the receive DMA request dma_req_rx for the IDLE interrupt (triggered with IDLE flag in USR2[12])." "0,1"
        textline "    "
        bitfld.long 0x00 7. " WKEN ,WAKE Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " ENIRI ,Serial Infrared Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 9. " INVR ,Invert RXD input in RS-232/RS-485 Mode, d etermine RXD input logic level being sampled in In IrDA mode." "0,1"
        textline "    "
        hexmask.long.byte 0x00 10.--16. 1. " CTSTL ,CTS Trigger Level ."
width 5.
group.long 0x90++0x3
    line.long 0x00 "UFCR,UART FIFO Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " RXTL ,Receiver Trigger Level ."
        textline "    "
        bitfld.long 0x00 6. " DCEDTE ,DCE/DTE mode select ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 7.--10. 1. " RFDIV ,Reference Frequency Divider."
        textline "    "
        hexmask.long.byte 0x00 10.--16. 1. " TXTL ,Transmitter Trigger Level ."
width 5.
group.long 0x94++0x3
    line.long 0x00 "USR1,UART Status Register 1"
        bitfld.long 0x00 3. " SAD ,RS-485 Slave Address Detected Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 4. " AWAKE ,Asynchronous WAKE Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 5. " AIRINT ,Asynchronous IR WAKE Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RXDS ,Receiver IDLE Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 7. " DTRD ,DTR Delta." "0,1"
        textline "    "
        bitfld.long 0x00 8. " AGTIM ,Ageing Timer Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RRDY ,Receiver Ready Interrupt / DMA Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 10. " FRAMERR ,Frame Error Interrupt Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ESCF ,Escape Sequence Interrupt Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 12. " RTSD ,RTS Delta." "0,1"
        textline "    "
        bitfld.long 0x00 13. " TRDY ,Transmitter Ready Interrupt / DMA Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " RTSS ,RTS Pin Status ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " PARITYERR ,Parity Error Interrupt Flag ." "0,1"
width 5.
group.long 0x98++0x3
    line.long 0x00 "USR2,UART Status Register 2"
        bitfld.long 0x00 0. " RDR ,Receive Data Ready -Indicates that at least 1 character is received and written to the RxFIFO." "0,1"
        textline "    "
        bitfld.long 0x00 1. " ORE ,Overrun Error ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " BRCD ,BREAK Condition Detected ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TXDC ,Transmitter Complete ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RTSF ,RTS Edge Triggered Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 5. " DCDIN ,Data Carrier Detect Input ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " DCDDELT ,Data Carrier Detect Delta ." "0,1"
        textline "    "
        bitfld.long 0x00 7. " WAKE ,Wake ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " IRINT ,Serial Infrared Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RIIN ,Ring Indicator Input ." "0,1"
        textline "    "
        bitfld.long 0x00 10. " RIDELT ,Ring Indicator Delta ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ACST ,Autobaud Counter Stopped ." "0,1"
        textline "    "
        bitfld.long 0x00 12. " IDLE ,Idle Condition ." "0,1"
        textline "    "
        bitfld.long 0x00 13. " DTRF ,DTR edge triggered interrupt flag ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " TXFE ,Transmit Buffer FIFO Empty ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ADET ,Automatic Baud Rate Detect Complete ." "0,1"
width 5.
group.long 0x9c++0x3
    line.long 0x00 "UESC,UART Escape Character Register"
        hexmask.long.byte 0x00 0.--8. 1. " ESC_CHAR ,UART Escape Character ."
width 5.
group.long 0xa0++0x3
    line.long 0x00 "UTIM,UART Escape Timer Register"
        hexmask.long.word 0x00 0.--12. 1. " TIM ,UART Escape Timer."
width 5.
group.long 0xa4++0x3
    line.long 0x00 "UBIR,UART BRM Incremental Register"
        hexmask.long.word 0x00 0.--16. 1. " INC ,Incremental Numerator."
width 5.
group.long 0xa8++0x3
    line.long 0x00 "UBMR,UART BRM Modulator Register"
        hexmask.long.word 0x00 0.--16. 1. " MOD ,Modulator Denominator."
width 5.
rgroup.long 0xac++0x3
    line.long 0x00 "UBRC,UART Baud Rate Count Register"
        hexmask.long.word 0x00 0.--16. 1. " BCNT ,Baud Rate Count Register."
width 6.
group.long 0xb0++0x3
    line.long 0x00 "ONEMS,UART One Millisecond Register"
        hexmask.long.long 0x00 0.--24. 1. " ONEMS ,One Millisecond Register."
width 4.
group.long 0xb4++0x3
    line.long 0x00 "UTS,UART Test Register"
        bitfld.long 0x00 0. " SOFTRST ,Software Reset." "0,1"
        textline "   "
        bitfld.long 0x00 3. " RXFULL ,RxFIFO FULL." "0,1"
        textline "   "
        bitfld.long 0x00 4. " TXFULL ,TxFIFO FULL." "0,1"
        textline "   "
        bitfld.long 0x00 5. " RXEMPTY ,RxFIFO Empty." "0,1"
        textline "   "
        bitfld.long 0x00 6. " TXEMPTY ,TxFIFO Empty." "0,1"
        textline "   "
        bitfld.long 0x00 9. " RXDBG ,RX_fifo_debug_mode." "0,1"
        textline "   "
        bitfld.long 0x00 10. " LOOPIR ,Loop TX and RX for IR Test (LOOPIR) ." "0,1"
        textline "   "
        bitfld.long 0x00 11. " DBGEN ,debug_enable ." "0,1"
        textline "   "
        bitfld.long 0x00 12. " LOOP ,Loop TX and RX for Test." "0,1"
        textline "   "
        bitfld.long 0x00 13. " FRCPERR ,Force Parity Error." "0,1"
width 5.
group.long 0xb8++0x3
    line.long 0x00 "UMCR,UART RS-485 Mode Control Register"
        bitfld.long 0x00 0. " MDEN ,9-bit data or Multidrop Mode (RS-485) Enable." "0,1"
        textline "    "
        bitfld.long 0x00 1. " SLAM ,RS-485 Slave Address Detect Mode Selection." "0,1"
        textline "    "
        bitfld.long 0x00 2. " TXB8 ,Transmit RS-485 bit 8 (the ninth bit or 9 th bit)." "0,1"
        textline "    "
        bitfld.long 0x00 3. " SADEN ,RS-485 Slave Address Detected Interrupt Enable." "0,1"
        textline "    "
        hexmask.long.byte 0x00 8.--16. 1. " SLADDR ,RS-485 Slave Address Character."


    tree.end
    tree "UART4"
        base ad:0x02038000

width 5.
rgroup.long 0x0++0x3
    line.long 0x00 "URXD,UART Receiver Register"
        hexmask.long.byte 0x00 0.--8. 1. " RX_DATA ,Received Data ."
        textline "    "
        bitfld.long 0x00 10. " PRERR ,In RS-485 mode, it holds the ninth data bit (bit [8]) of received 9-bit RS-485 data In RS232/IrDA mode, it is the Parity Error flag ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " BRK ,BREAK Detect." "0,1"
        textline "    "
        bitfld.long 0x00 12. " FRMERR ,Frame Error." "0,1"
        textline "    "
        bitfld.long 0x00 13. " OVRRUN ,Receiver Overrun." "0,1"
        textline "    "
        bitfld.long 0x00 14. " ERR ,Error Detect." "0,1"
        textline "    "
        bitfld.long 0x00 15. " CHARRDY ,Character Ready." "0,1"
width 5.
wgroup.long 0x40++0x3
    line.long 0x00 "UTXD,UART Transmitter Register"
        hexmask.long.byte 0x00 0.--8. 1. " TX_DATA ,Transmit Data ."
width 5.
group.long 0x80++0x3
    line.long 0x00 "UCR1,UART Control Register 1"
        bitfld.long 0x00 0. " UARTEN ,UART Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " DOZE ,DOZE ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " ATDMAEN ,Aging DMA Timer Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TXDMAEN ,Transmitter Ready DMA Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " SNDBRK ,Send BREAK ." "0,1"
        textline "    "
        bitfld.long 0x00 5. " RTSDEN ,RTS Delta Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " TXMPTYEN ,Transmitter Empty Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 7. " IREN ,Infrared Interface Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " RXDMAEN ,Receive Ready DMA Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RRDYEN ,Receiver Ready Interrupt Enable ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICD ,Idle Condition Detect ."
        textline "    "
        bitfld.long 0x00 12. " IDEN ,Idle Condition Detected Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 13. " TRDYEN ,Transmitter Ready Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " ADBR ,Automatic Detection of Baud Rate ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ADEN ,Automatic Baud Rate Detection Interrupt Enable ." "0,1"
width 5.
group.long 0x84++0x3
    line.long 0x00 "UCR2,UART Control Register 2"
        bitfld.long 0x00 0. " SRST ,Software Reset ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RXEN ,Receiver Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " TXEN ,Transmitter Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " ATEN ,Aging Timer Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RTSEN ,Request to Send Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 5. " WS ,Word Size ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " STPB ,Stop ." "0,1"
        textline "    "
        bitfld.long 0x00 7. " PROE ,Parity Odd/Even ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " PREN ,Parity Enable ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 9.--11. 1. " RTEC ,Request to Send Edge Control ."
        textline "    "
        bitfld.long 0x00 11. " ESCEN ,Escape Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 12. " CTS ,Clear to Send ." "0,1"
        textline "    "
        bitfld.long 0x00 13. " CTSC ,CTS Pin Control ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " IRTS ,Ignore RTS Pin ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ESCI ,Escape Sequence Interrupt Enable ." "0,1"
width 5.
group.long 0x88++0x3
    line.long 0x00 "UCR3,UART Control Register 3"
        bitfld.long 0x00 0. " ACIEN ,Autobaud Counter Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 1. " INVT ,Invert TXD output in RS-232/RS-485 mode, set TXD active level in IrDA mode." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RXDMUXSEL ,RXD Muxed Input Selected." "0,1"
        textline "    "
        bitfld.long 0x00 3. " DTRDEN ,Data Terminal Ready Delta Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " AWAKEN ,Asynchronous WAKE Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 5. " AIRINTEN ,Asynchronous IR WAKE Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RXDSEN ,Receive Status Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 7. " ADNIMP ,Autobaud Detection Not Improved-." "0,1"
        textline "    "
        bitfld.long 0x00 8. " RI ,Ring Indicator ." "0,1"
        textline "    "
        bitfld.long 0x00 9. " DCD ,Data Carrier Detect ." "0,1"
        textline "    "
        bitfld.long 0x00 10. " DSR ,Data Set Ready ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " FRAERREN ,Frame Error Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 12. " PARERREN ,Parity Error Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 13. " DTREN ,Data Terminal Ready Interrupt Enable ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " DPEC ,DTR/DSR Interrupt Edge Control ."
width 5.
group.long 0x8c++0x3
    line.long 0x00 "UCR4,UART Control Register 4"
        bitfld.long 0x00 0. " DREN ,Receive Data Ready Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " OREN ,Receiver Overrun Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " BKEN ,BREAK Condition Detected Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TCEN ,Transmit Complete Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " LPBYP ,Low Power Bypass ." "0,1"
        textline "    "
        bitfld.long 0x00 5. " IRSC ,IR Special Case ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " IDDMAEN ,DMA IDLE Condition Detected Interrupt Enable Enables/Disables the receive DMA request dma_req_rx for the IDLE interrupt (triggered with IDLE flag in USR2[12])." "0,1"
        textline "    "
        bitfld.long 0x00 7. " WKEN ,WAKE Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " ENIRI ,Serial Infrared Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 9. " INVR ,Invert RXD input in RS-232/RS-485 Mode, d etermine RXD input logic level being sampled in In IrDA mode." "0,1"
        textline "    "
        hexmask.long.byte 0x00 10.--16. 1. " CTSTL ,CTS Trigger Level ."
width 5.
group.long 0x90++0x3
    line.long 0x00 "UFCR,UART FIFO Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " RXTL ,Receiver Trigger Level ."
        textline "    "
        bitfld.long 0x00 6. " DCEDTE ,DCE/DTE mode select ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 7.--10. 1. " RFDIV ,Reference Frequency Divider."
        textline "    "
        hexmask.long.byte 0x00 10.--16. 1. " TXTL ,Transmitter Trigger Level ."
width 5.
group.long 0x94++0x3
    line.long 0x00 "USR1,UART Status Register 1"
        bitfld.long 0x00 3. " SAD ,RS-485 Slave Address Detected Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 4. " AWAKE ,Asynchronous WAKE Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 5. " AIRINT ,Asynchronous IR WAKE Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RXDS ,Receiver IDLE Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 7. " DTRD ,DTR Delta." "0,1"
        textline "    "
        bitfld.long 0x00 8. " AGTIM ,Ageing Timer Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RRDY ,Receiver Ready Interrupt / DMA Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 10. " FRAMERR ,Frame Error Interrupt Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ESCF ,Escape Sequence Interrupt Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 12. " RTSD ,RTS Delta." "0,1"
        textline "    "
        bitfld.long 0x00 13. " TRDY ,Transmitter Ready Interrupt / DMA Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " RTSS ,RTS Pin Status ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " PARITYERR ,Parity Error Interrupt Flag ." "0,1"
width 5.
group.long 0x98++0x3
    line.long 0x00 "USR2,UART Status Register 2"
        bitfld.long 0x00 0. " RDR ,Receive Data Ready -Indicates that at least 1 character is received and written to the RxFIFO." "0,1"
        textline "    "
        bitfld.long 0x00 1. " ORE ,Overrun Error ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " BRCD ,BREAK Condition Detected ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TXDC ,Transmitter Complete ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RTSF ,RTS Edge Triggered Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 5. " DCDIN ,Data Carrier Detect Input ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " DCDDELT ,Data Carrier Detect Delta ." "0,1"
        textline "    "
        bitfld.long 0x00 7. " WAKE ,Wake ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " IRINT ,Serial Infrared Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RIIN ,Ring Indicator Input ." "0,1"
        textline "    "
        bitfld.long 0x00 10. " RIDELT ,Ring Indicator Delta ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ACST ,Autobaud Counter Stopped ." "0,1"
        textline "    "
        bitfld.long 0x00 12. " IDLE ,Idle Condition ." "0,1"
        textline "    "
        bitfld.long 0x00 13. " DTRF ,DTR edge triggered interrupt flag ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " TXFE ,Transmit Buffer FIFO Empty ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ADET ,Automatic Baud Rate Detect Complete ." "0,1"
width 5.
group.long 0x9c++0x3
    line.long 0x00 "UESC,UART Escape Character Register"
        hexmask.long.byte 0x00 0.--8. 1. " ESC_CHAR ,UART Escape Character ."
width 5.
group.long 0xa0++0x3
    line.long 0x00 "UTIM,UART Escape Timer Register"
        hexmask.long.word 0x00 0.--12. 1. " TIM ,UART Escape Timer."
width 5.
group.long 0xa4++0x3
    line.long 0x00 "UBIR,UART BRM Incremental Register"
        hexmask.long.word 0x00 0.--16. 1. " INC ,Incremental Numerator."
width 5.
group.long 0xa8++0x3
    line.long 0x00 "UBMR,UART BRM Modulator Register"
        hexmask.long.word 0x00 0.--16. 1. " MOD ,Modulator Denominator."
width 5.
rgroup.long 0xac++0x3
    line.long 0x00 "UBRC,UART Baud Rate Count Register"
        hexmask.long.word 0x00 0.--16. 1. " BCNT ,Baud Rate Count Register."
width 6.
group.long 0xb0++0x3
    line.long 0x00 "ONEMS,UART One Millisecond Register"
        hexmask.long.long 0x00 0.--24. 1. " ONEMS ,One Millisecond Register."
width 4.
group.long 0xb4++0x3
    line.long 0x00 "UTS,UART Test Register"
        bitfld.long 0x00 0. " SOFTRST ,Software Reset." "0,1"
        textline "   "
        bitfld.long 0x00 3. " RXFULL ,RxFIFO FULL." "0,1"
        textline "   "
        bitfld.long 0x00 4. " TXFULL ,TxFIFO FULL." "0,1"
        textline "   "
        bitfld.long 0x00 5. " RXEMPTY ,RxFIFO Empty." "0,1"
        textline "   "
        bitfld.long 0x00 6. " TXEMPTY ,TxFIFO Empty." "0,1"
        textline "   "
        bitfld.long 0x00 9. " RXDBG ,RX_fifo_debug_mode." "0,1"
        textline "   "
        bitfld.long 0x00 10. " LOOPIR ,Loop TX and RX for IR Test (LOOPIR) ." "0,1"
        textline "   "
        bitfld.long 0x00 11. " DBGEN ,debug_enable ." "0,1"
        textline "   "
        bitfld.long 0x00 12. " LOOP ,Loop TX and RX for Test." "0,1"
        textline "   "
        bitfld.long 0x00 13. " FRCPERR ,Force Parity Error." "0,1"
width 5.
group.long 0xb8++0x3
    line.long 0x00 "UMCR,UART RS-485 Mode Control Register"
        bitfld.long 0x00 0. " MDEN ,9-bit data or Multidrop Mode (RS-485) Enable." "0,1"
        textline "    "
        bitfld.long 0x00 1. " SLAM ,RS-485 Slave Address Detect Mode Selection." "0,1"
        textline "    "
        bitfld.long 0x00 2. " TXB8 ,Transmit RS-485 bit 8 (the ninth bit or 9 th bit)." "0,1"
        textline "    "
        bitfld.long 0x00 3. " SADEN ,RS-485 Slave Address Detected Interrupt Enable." "0,1"
        textline "    "
        hexmask.long.byte 0x00 8.--16. 1. " SLADDR ,RS-485 Slave Address Character."


    tree.end
    tree "UART5"
        base ad:0x02018000

width 5.
rgroup.long 0x0++0x3
    line.long 0x00 "URXD,UART Receiver Register"
        hexmask.long.byte 0x00 0.--8. 1. " RX_DATA ,Received Data ."
        textline "    "
        bitfld.long 0x00 10. " PRERR ,In RS-485 mode, it holds the ninth data bit (bit [8]) of received 9-bit RS-485 data In RS232/IrDA mode, it is the Parity Error flag ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " BRK ,BREAK Detect." "0,1"
        textline "    "
        bitfld.long 0x00 12. " FRMERR ,Frame Error." "0,1"
        textline "    "
        bitfld.long 0x00 13. " OVRRUN ,Receiver Overrun." "0,1"
        textline "    "
        bitfld.long 0x00 14. " ERR ,Error Detect." "0,1"
        textline "    "
        bitfld.long 0x00 15. " CHARRDY ,Character Ready." "0,1"
width 5.
wgroup.long 0x40++0x3
    line.long 0x00 "UTXD,UART Transmitter Register"
        hexmask.long.byte 0x00 0.--8. 1. " TX_DATA ,Transmit Data ."
width 5.
group.long 0x80++0x3
    line.long 0x00 "UCR1,UART Control Register 1"
        bitfld.long 0x00 0. " UARTEN ,UART Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " DOZE ,DOZE ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " ATDMAEN ,Aging DMA Timer Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TXDMAEN ,Transmitter Ready DMA Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " SNDBRK ,Send BREAK ." "0,1"
        textline "    "
        bitfld.long 0x00 5. " RTSDEN ,RTS Delta Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " TXMPTYEN ,Transmitter Empty Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 7. " IREN ,Infrared Interface Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " RXDMAEN ,Receive Ready DMA Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RRDYEN ,Receiver Ready Interrupt Enable ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICD ,Idle Condition Detect ."
        textline "    "
        bitfld.long 0x00 12. " IDEN ,Idle Condition Detected Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 13. " TRDYEN ,Transmitter Ready Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " ADBR ,Automatic Detection of Baud Rate ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ADEN ,Automatic Baud Rate Detection Interrupt Enable ." "0,1"
width 5.
group.long 0x84++0x3
    line.long 0x00 "UCR2,UART Control Register 2"
        bitfld.long 0x00 0. " SRST ,Software Reset ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RXEN ,Receiver Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " TXEN ,Transmitter Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " ATEN ,Aging Timer Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RTSEN ,Request to Send Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 5. " WS ,Word Size ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " STPB ,Stop ." "0,1"
        textline "    "
        bitfld.long 0x00 7. " PROE ,Parity Odd/Even ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " PREN ,Parity Enable ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 9.--11. 1. " RTEC ,Request to Send Edge Control ."
        textline "    "
        bitfld.long 0x00 11. " ESCEN ,Escape Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 12. " CTS ,Clear to Send ." "0,1"
        textline "    "
        bitfld.long 0x00 13. " CTSC ,CTS Pin Control ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " IRTS ,Ignore RTS Pin ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ESCI ,Escape Sequence Interrupt Enable ." "0,1"
width 5.
group.long 0x88++0x3
    line.long 0x00 "UCR3,UART Control Register 3"
        bitfld.long 0x00 0. " ACIEN ,Autobaud Counter Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 1. " INVT ,Invert TXD output in RS-232/RS-485 mode, set TXD active level in IrDA mode." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RXDMUXSEL ,RXD Muxed Input Selected." "0,1"
        textline "    "
        bitfld.long 0x00 3. " DTRDEN ,Data Terminal Ready Delta Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " AWAKEN ,Asynchronous WAKE Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 5. " AIRINTEN ,Asynchronous IR WAKE Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RXDSEN ,Receive Status Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 7. " ADNIMP ,Autobaud Detection Not Improved-." "0,1"
        textline "    "
        bitfld.long 0x00 8. " RI ,Ring Indicator ." "0,1"
        textline "    "
        bitfld.long 0x00 9. " DCD ,Data Carrier Detect ." "0,1"
        textline "    "
        bitfld.long 0x00 10. " DSR ,Data Set Ready ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " FRAERREN ,Frame Error Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 12. " PARERREN ,Parity Error Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 13. " DTREN ,Data Terminal Ready Interrupt Enable ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " DPEC ,DTR/DSR Interrupt Edge Control ."
width 5.
group.long 0x8c++0x3
    line.long 0x00 "UCR4,UART Control Register 4"
        bitfld.long 0x00 0. " DREN ,Receive Data Ready Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " OREN ,Receiver Overrun Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " BKEN ,BREAK Condition Detected Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TCEN ,Transmit Complete Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " LPBYP ,Low Power Bypass ." "0,1"
        textline "    "
        bitfld.long 0x00 5. " IRSC ,IR Special Case ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " IDDMAEN ,DMA IDLE Condition Detected Interrupt Enable Enables/Disables the receive DMA request dma_req_rx for the IDLE interrupt (triggered with IDLE flag in USR2[12])." "0,1"
        textline "    "
        bitfld.long 0x00 7. " WKEN ,WAKE Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " ENIRI ,Serial Infrared Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 9. " INVR ,Invert RXD input in RS-232/RS-485 Mode, d etermine RXD input logic level being sampled in In IrDA mode." "0,1"
        textline "    "
        hexmask.long.byte 0x00 10.--16. 1. " CTSTL ,CTS Trigger Level ."
width 5.
group.long 0x90++0x3
    line.long 0x00 "UFCR,UART FIFO Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " RXTL ,Receiver Trigger Level ."
        textline "    "
        bitfld.long 0x00 6. " DCEDTE ,DCE/DTE mode select ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 7.--10. 1. " RFDIV ,Reference Frequency Divider."
        textline "    "
        hexmask.long.byte 0x00 10.--16. 1. " TXTL ,Transmitter Trigger Level ."
width 5.
group.long 0x94++0x3
    line.long 0x00 "USR1,UART Status Register 1"
        bitfld.long 0x00 3. " SAD ,RS-485 Slave Address Detected Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 4. " AWAKE ,Asynchronous WAKE Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 5. " AIRINT ,Asynchronous IR WAKE Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RXDS ,Receiver IDLE Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 7. " DTRD ,DTR Delta." "0,1"
        textline "    "
        bitfld.long 0x00 8. " AGTIM ,Ageing Timer Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RRDY ,Receiver Ready Interrupt / DMA Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 10. " FRAMERR ,Frame Error Interrupt Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ESCF ,Escape Sequence Interrupt Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 12. " RTSD ,RTS Delta." "0,1"
        textline "    "
        bitfld.long 0x00 13. " TRDY ,Transmitter Ready Interrupt / DMA Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " RTSS ,RTS Pin Status ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " PARITYERR ,Parity Error Interrupt Flag ." "0,1"
width 5.
group.long 0x98++0x3
    line.long 0x00 "USR2,UART Status Register 2"
        bitfld.long 0x00 0. " RDR ,Receive Data Ready -Indicates that at least 1 character is received and written to the RxFIFO." "0,1"
        textline "    "
        bitfld.long 0x00 1. " ORE ,Overrun Error ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " BRCD ,BREAK Condition Detected ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TXDC ,Transmitter Complete ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RTSF ,RTS Edge Triggered Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 5. " DCDIN ,Data Carrier Detect Input ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " DCDDELT ,Data Carrier Detect Delta ." "0,1"
        textline "    "
        bitfld.long 0x00 7. " WAKE ,Wake ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " IRINT ,Serial Infrared Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RIIN ,Ring Indicator Input ." "0,1"
        textline "    "
        bitfld.long 0x00 10. " RIDELT ,Ring Indicator Delta ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ACST ,Autobaud Counter Stopped ." "0,1"
        textline "    "
        bitfld.long 0x00 12. " IDLE ,Idle Condition ." "0,1"
        textline "    "
        bitfld.long 0x00 13. " DTRF ,DTR edge triggered interrupt flag ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " TXFE ,Transmit Buffer FIFO Empty ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ADET ,Automatic Baud Rate Detect Complete ." "0,1"
width 5.
group.long 0x9c++0x3
    line.long 0x00 "UESC,UART Escape Character Register"
        hexmask.long.byte 0x00 0.--8. 1. " ESC_CHAR ,UART Escape Character ."
width 5.
group.long 0xa0++0x3
    line.long 0x00 "UTIM,UART Escape Timer Register"
        hexmask.long.word 0x00 0.--12. 1. " TIM ,UART Escape Timer."
width 5.
group.long 0xa4++0x3
    line.long 0x00 "UBIR,UART BRM Incremental Register"
        hexmask.long.word 0x00 0.--16. 1. " INC ,Incremental Numerator."
width 5.
group.long 0xa8++0x3
    line.long 0x00 "UBMR,UART BRM Modulator Register"
        hexmask.long.word 0x00 0.--16. 1. " MOD ,Modulator Denominator."
width 5.
rgroup.long 0xac++0x3
    line.long 0x00 "UBRC,UART Baud Rate Count Register"
        hexmask.long.word 0x00 0.--16. 1. " BCNT ,Baud Rate Count Register."
width 6.
group.long 0xb0++0x3
    line.long 0x00 "ONEMS,UART One Millisecond Register"
        hexmask.long.long 0x00 0.--24. 1. " ONEMS ,One Millisecond Register."
width 4.
group.long 0xb4++0x3
    line.long 0x00 "UTS,UART Test Register"
        bitfld.long 0x00 0. " SOFTRST ,Software Reset." "0,1"
        textline "   "
        bitfld.long 0x00 3. " RXFULL ,RxFIFO FULL." "0,1"
        textline "   "
        bitfld.long 0x00 4. " TXFULL ,TxFIFO FULL." "0,1"
        textline "   "
        bitfld.long 0x00 5. " RXEMPTY ,RxFIFO Empty." "0,1"
        textline "   "
        bitfld.long 0x00 6. " TXEMPTY ,TxFIFO Empty." "0,1"
        textline "   "
        bitfld.long 0x00 9. " RXDBG ,RX_fifo_debug_mode." "0,1"
        textline "   "
        bitfld.long 0x00 10. " LOOPIR ,Loop TX and RX for IR Test (LOOPIR) ." "0,1"
        textline "   "
        bitfld.long 0x00 11. " DBGEN ,debug_enable ." "0,1"
        textline "   "
        bitfld.long 0x00 12. " LOOP ,Loop TX and RX for Test." "0,1"
        textline "   "
        bitfld.long 0x00 13. " FRCPERR ,Force Parity Error." "0,1"
width 5.
group.long 0xb8++0x3
    line.long 0x00 "UMCR,UART RS-485 Mode Control Register"
        bitfld.long 0x00 0. " MDEN ,9-bit data or Multidrop Mode (RS-485) Enable." "0,1"
        textline "    "
        bitfld.long 0x00 1. " SLAM ,RS-485 Slave Address Detect Mode Selection." "0,1"
        textline "    "
        bitfld.long 0x00 2. " TXB8 ,Transmit RS-485 bit 8 (the ninth bit or 9 th bit)." "0,1"
        textline "    "
        bitfld.long 0x00 3. " SADEN ,RS-485 Slave Address Detected Interrupt Enable." "0,1"
        textline "    "
        hexmask.long.byte 0x00 8.--16. 1. " SLADDR ,RS-485 Slave Address Character."


    tree.end

tree.end



;--------------------------------------------------------------------------------
; USB_ANALOG
;--------------------------------------------------------------------------------
tree "USB_ANALOG"
    base ad:0x020c8000

width 17.
group.long 0x1a0++0x3
    line.long 0x00 "USB1_VBUS_DETECT,USB VBUS Detect Register"
        hexmask.long.byte 0x00 0.--3. 1. " VBUSVALID_THRESH ,Set the threshold for the VBUSVALID comparator."
        textline "                "
        bitfld.long 0x00 20. " VBUSVALID_PWRUP_CMPS ,Powers up comparators for vbus_valid detector." "0,1"
        textline "                "
        bitfld.long 0x00 26. " DISCHARGE_VBUS ,USB OTG discharge VBUS." "0,1"
        textline "                "
        bitfld.long 0x00 27. " CHARGE_VBUS ,USB OTG charge VBUS." "0,1"
width 17.
group.long 0x1b0++0x3
    line.long 0x00 "USB1_CHRG_DETECT,USB Charger Detect Register"
        bitfld.long 0x00 18. " CHK_CONTACT ," "0,1"
        textline "                "
        bitfld.long 0x00 19. " CHK_CHRG_B ," "0,1"
        textline "                "
        bitfld.long 0x00 20. " EN_B ,Control the charger detector." "0,1"
width 22.
rgroup.long 0x1c0++0x3
    line.long 0x00 "USB1_VBUS_DETECT_STAT,USB VBUS Detect Status Register"
        bitfld.long 0x00 0. " SESSEND ,Session End for USB OTG." "0,1"
        textline "                     "
        bitfld.long 0x00 1. " BVALID ,Indicates VBus is valid for a B-peripheral." "0,1"
        textline "                     "
        bitfld.long 0x00 2. " AVALID ,Indicates VBus is valid for a A-peripheral." "0,1"
        textline "                     "
        bitfld.long 0x00 3. " VBUS_VALID ,VBus valid for USB OTG." "0,1"
width 22.
rgroup.long 0x1d0++0x3
    line.long 0x00 "USB1_CHRG_DETECT_STAT,USB Charger Detect Status Register"
        bitfld.long 0x00 0. " PLUG_CONTACT ,State of the USB plug contact detector." "0,1"
        textline "                     "
        bitfld.long 0x00 1. " CHRG_DETECTED ,State of charger detection." "0,1"
        textline "                     "
        bitfld.long 0x00 2. " DM_STATE ,DM line state output of the charger detector." "0,1"
        textline "                     "
        bitfld.long 0x00 3. " DP_STATE ,DP line state output of the charger detector." "0,1"
width 10.
group.long 0x1f0++0x3
    line.long 0x00 "USB1_MISC,USB Misc Register"
        bitfld.long 0x00 0. " HS_USE_EXTERNAL_R ,Use external resistor to generate the current bias for the high speed transmitter." "0,1"
        textline "         "
        bitfld.long 0x00 1. " EN_DEGLITCH ,Enable the deglitching circuit of the USB PLL output." "0,1"
        textline "         "
        bitfld.long 0x00 30. " EN_CLK_UTMI ,Enables the clk to the UTMI block." "0,1"
width 17.
group.long 0x200++0x3
    line.long 0x00 "USB2_VBUS_DETECT,USB VBUS Detect Register"
        hexmask.long.byte 0x00 0.--3. 1. " VBUSVALID_THRESH ,Set the threshold for the VBUSVALID comparator."
        textline "                "
        bitfld.long 0x00 20. " VBUSVALID_PWRUP_CMPS ,Powers up comparators for vbus_valid detector." "0,1"
        textline "                "
        bitfld.long 0x00 26. " DISCHARGE_VBUS ,USB OTG discharge VBUS." "0,1"
        textline "                "
        bitfld.long 0x00 27. " CHARGE_VBUS ,USB OTG charge VBUS." "0,1"
width 17.
group.long 0x210++0x3
    line.long 0x00 "USB2_CHRG_DETECT,USB Charger Detect Register"
        bitfld.long 0x00 18. " CHK_CONTACT ," "0,1"
        textline "                "
        bitfld.long 0x00 19. " CHK_CHRG_B ," "0,1"
        textline "                "
        bitfld.long 0x00 20. " EN_B ,Control the charger detector." "0,1"
width 22.
rgroup.long 0x220++0x3
    line.long 0x00 "USB2_VBUS_DETECT_STAT,USB VBUS Detect Status Register"
        bitfld.long 0x00 0. " SESSEND ,Session End for USB OTG." "0,1"
        textline "                     "
        bitfld.long 0x00 1. " BVALID ,Indicates VBus is valid for a B-peripheral." "0,1"
        textline "                     "
        bitfld.long 0x00 2. " AVALID ,Indicates VBus is valid for a A-peripheral." "0,1"
        textline "                     "
        bitfld.long 0x00 3. " VBUS_VALID ,VBus valid for USB OTG." "0,1"
width 22.
rgroup.long 0x230++0x3
    line.long 0x00 "USB2_CHRG_DETECT_STAT,USB Charger Detect Status Register"
        bitfld.long 0x00 0. " PLUG_CONTACT ,State of the USB plug contact detector." "0,1"
        textline "                     "
        bitfld.long 0x00 1. " CHRG_DETECTED ,State of charger detection." "0,1"
        textline "                     "
        bitfld.long 0x00 2. " DM_STATE ,DM line state output of the charger detector." "0,1"
        textline "                     "
        bitfld.long 0x00 3. " DP_STATE ,DP line state output of the charger detector." "0,1"
width 10.
group.long 0x250++0x3
    line.long 0x00 "USB2_MISC,USB Misc Register"
        bitfld.long 0x00 0. " HS_USE_EXTERNAL_R ,Use external resistor to generate the current bias for the high speed transmitter." "0,1"
        textline "         "
        bitfld.long 0x00 1. " EN_DEGLITCH ,Enable the deglitching circuit of the USB PLL output." "0,1"
        textline "         "
        bitfld.long 0x00 30. " EN_CLK_UTMI ,Enables the clk to the UTMI block." "0,1"
width 8.
rgroup.long 0x280++0x3
    line.long 0x00 "DIGPROG,Chip Silicon Version"
        hexmask.long.byte 0x00 0.--8. 1. " MINOR ,Fixed read-only value reflecting the MINOR field of the RTL version."
        textline "       "
        hexmask.long.word 0x00 8.--24. 1. " MAJOR ,Fixed read-only value reflecting the MAJOR field of the RTL version."


tree.end



;--------------------------------------------------------------------------------
; USBC
;--------------------------------------------------------------------------------
tree "USBC"
    base ad:0x02184000

width 8.
rgroup.long 0x0++0x3
    line.long 0x00 "UOG1_ID,Identification register"
        hexmask.long.byte 0x00 0.--6. 1. " ID ,Configuration number."
        textline "       "
        hexmask.long.byte 0x00 8.--14. 1. " NID ,Complement version of ID"
        textline "       "
        hexmask.long.byte 0x00 16.--24. 1. " REVISION ,Revision number of the controller core."
width 15.
rgroup.long 0x4++0x3
    line.long 0x00 "UOG1_HWGENERAL,Hardware General"
        hexmask.long.byte 0x00 4.--6. 1. " PHYW ,Data width of the transciever connected to the controller core."
        textline "              "
        hexmask.long.byte 0x00 6.--9. 1. " PHYM ,Transciever type PHYM bit reset value: '0000b' for OTG controller core, '0100b' for Host-only controller core."
        textline "              "
        hexmask.long.byte 0x00 9.--11. 1. " SM ,Serial interface mode capability SM bit reset value is '00b'"
width 12.
rgroup.long 0x8++0x3
    line.long 0x00 "UOG1_HWHOST,Host Hardware Parameters"
        bitfld.long 0x00 0. " HC ,Host Capable." "0,1"
        textline "           "
        hexmask.long.byte 0x00 1.--4. 1. " NPORT ,The Nmber of downstream ports supported by the host controller is (NPORT+1)."
width 14.
rgroup.long 0xc++0x3
    line.long 0x00 "UOG1_HWDEVICE,Device Hardware Parameters"
        bitfld.long 0x00 0. " DC ,Device Capable." "0,1"
        textline "             "
        hexmask.long.byte 0x00 1.--6. 1. " DEVEP ,Device Endpoint Number"
width 13.
rgroup.long 0x10++0x3
    line.long 0x00 "UOG1_HWTXBUF,TX Buffer Hardware Parameters"
        hexmask.long.byte 0x00 0.--8. 1. " TXBURST ,Default burst size for memory to TX buffer transfer."
        textline "            "
        hexmask.long.byte 0x00 16.--24. 1. " TXCHANADD ,TX FIFO Buffer size is: (2^TXCHANADD) * 4 Bytes."
width 13.
rgroup.long 0x14++0x3
    line.long 0x00 "UOG1_HWRXBUF,RX Buffer Hardware Parameters"
        hexmask.long.byte 0x00 0.--8. 1. " RXBURST ,Default burst size for memory to RX buffer transfer."
        textline "            "
        hexmask.long.byte 0x00 8.--16. 1. " RXADD ,Buffer total size for all receive endpoints is (2^RXADD)."
width 16.
group.long 0x80++0x3
    line.long 0x00 "UOG1_GPTIMER0LD,General Purpose Timer #0 Load"
        hexmask.long.long 0x00 0.--24. 1. " GPTLD ,General Purpose Timer Load Value These bit fields are loaded to GPTCNT bits when GPTRST bit is set '1b'."
width 18.
group.long 0x84++0x3
    line.long 0x00 "UOG1_GPTIMER0CTRL,General Purpose Timer #0 Controller"
        hexmask.long.long 0x00 0.--24. 1. " GPTCNT ,General Purpose Timer Counter."
        textline "                 "
        bitfld.long 0x00 24. " GPTMODE ,General Purpose Timer Mode In one shot mode, the timer will count down to zero, generate an interrupt, and stop until the counter is reset by software; In repeat mode, the timer will count down to zero, generate an interrupt and automatically reload the counter value from GPTLD bits to start again." "0,1"
        textline "                 "
        bitfld.long 0x00 30. " GPTRST ,General Purpose Timer Reset" "0,1"
        textline "                 "
        bitfld.long 0x00 31. " GPTRUN ,General Purpose Timer Run GPTCNT bits are not effected when setting or clearing this bit." "0,1"
width 16.
group.long 0x88++0x3
    line.long 0x00 "UOG1_GPTIMER1LD,General Purpose Timer #1 Load"
        hexmask.long.long 0x00 0.--24. 1. " GPTLD ,General Purpose Timer Load Value These bit fields are loaded to GPTCNT bits when GPTRST bit is set '1b'."
width 18.
group.long 0x8c++0x3
    line.long 0x00 "UOG1_GPTIMER1CTRL,General Purpose Timer #1 Controller"
        hexmask.long.long 0x00 0.--24. 1. " GPTCNT ,General Purpose Timer Counter."
        textline "                 "
        bitfld.long 0x00 24. " GPTMODE ,General Purpose Timer Mode In one shot mode, the timer will count down to zero, generate an interrupt, and stop until the counter is reset by software." "0,1"
        textline "                 "
        bitfld.long 0x00 30. " GPTRST ,General Purpose Timer Reset" "0,1"
        textline "                 "
        bitfld.long 0x00 31. " GPTRUN ,General Purpose Timer Run GPTCNT bits are not effected when setting or clearing this bit." "0,1"
width 13.
group.long 0x90++0x3
    line.long 0x00 "UOG1_SBUSCFG,System Bus Config"
        hexmask.long.byte 0x00 0.--3. 1. " AHBBRST ,AHB master interface Burst configuration These bits control AHB master transfer type sequence (or priority)."
width 15.
rgroup.byte 0x100++0x0
    line.byte 0x00 "UOG1_CAPLENGTH,Capability Registers Length"
        hexmask.byte.byte 0x00 0.--8. 1. " CAPLENGTH ,These bits are used as an offset to add to register base to find the beginning of the Operational Register."
width 16.
rgroup.word 0x102++0x1
    line.word 0x00 "UOG1_HCIVERSION,Host Controller Interface Version"
        hexmask.word.word 0x00 0.--16. 1. " HCIVERSION ,Host Controller Interface Version Number Default value is '10h', which means EHCI rev1.0."
width 15.
rgroup.long 0x104++0x3
    line.long 0x00 "UOG1_HCSPARAMS,Host Controller Structural Parameters"
        hexmask.long.byte 0x00 0.--4. 1. " N_PORTS ,Number of downstream ports."
        textline "              "
        bitfld.long 0x00 4. " PPC ,Port Power Control This field indicates whether the host controller implementation includes port power control." "0,1"
        textline "              "
        hexmask.long.byte 0x00 8.--12. 1. " N_PCC ,Number of Ports per Companion Controller This field indicates the number of ports supported per internal Companion Controller."
        textline "              "
        hexmask.long.byte 0x00 12.--16. 1. " N_CC ,Number of Companion Controller (N_CC)."
        textline "              "
        bitfld.long 0x00 16. " PI ,Port Indicators (P INDICATOR) This bit indicates whether the ports support port indicator control." "0,1"
        textline "              "
        hexmask.long.byte 0x00 20.--24. 1. " N_PTT ,Number of Ports per Transaction Translator (N_PTT)."
        textline "              "
        hexmask.long.byte 0x00 24.--28. 1. " N_TT ,Number of Transaction Translators (N_TT)."
width 15.
rgroup.long 0x108++0x3
    line.long 0x00 "UOG1_HCCPARAMS,Host Controller Capability Parameters"
        bitfld.long 0x00 0. " ADC ,64-bit Addressing Capability This bit is set '0b' in all controller core, no 64-bit addressing capability is supported." "0,1"
        textline "              "
        bitfld.long 0x00 1. " PFL ,Programmable Frame List Flag If this bit is set to zero, then the system software must use a frame list length of 1024 elements with this host controller." "0,1"
        textline "              "
        bitfld.long 0x00 2. " ASP ,Asynchronous Schedule Park Capability If this bit is set to a one, then the host controller supports the park feature for high-speed queue heads in the Asynchronous Schedule." "0,1"
        textline "              "
        hexmask.long.byte 0x00 4.--8. 1. " IST ,Isochronous Scheduling Threshold."
        textline "              "
        hexmask.long.byte 0x00 8.--16. 1. " EECP ,EHCI Extended Capabilities Pointer."
width 16.
rgroup.word 0x120++0x1
    line.word 0x00 "UOG1_DCIVERSION,Device Controller Interface Version"
        hexmask.word.word 0x00 0.--16. 1. " DCIVERSION ,Device Controller Interface Version Number Default value is '01h', which means rev0.1."
width 15.
rgroup.long 0x124++0x3
    line.long 0x00 "UOG1_DCCPARAMS,Device Controller Capability Parameters"
        hexmask.long.byte 0x00 0.--5. 1. " DEN ,Device Endpoint Number This field indicates the number of endpoints built into the device controller."
        textline "              "
        bitfld.long 0x00 7. " DC ,Device Capable When this bit is 1, this controller is capable of operating as a USB 2.0 device." "0,1"
        textline "              "
        bitfld.long 0x00 8. " HC ,Host Capable When this bit is 1, this controller is capable of operating as an EHCI compatible USB 2.0 host controller." "0,1"
width 12.
group.long 0x140++0x3
    line.long 0x00 "UOG1_USBCMD,USB Command Register"
        bitfld.long 0x00 0. " RS ,Run/Stop (RS) - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 1. " RST ,Controller Reset (RESET) - Read/Write." "0,1"
        textline "           "
        hexmask.long.byte 0x00 2.--4. 1. " FS_1 ,See description at bit 15"
        textline "           "
        bitfld.long 0x00 4. " PSE ,Periodic Schedule Enable- Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 5. " ASE ,Asynchronous Schedule Enable - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 6. " IAA ,Interrupt on Async Advance Doorbell - Read/Write." "0,1"
        textline "           "
        hexmask.long.byte 0x00 8.--10. 1. " ASP ,Asynchronous Schedule Park Mode Count - Read/Write."
        textline "           "
        bitfld.long 0x00 11. " ASPE ,Asynchronous Schedule Park Mode Enable - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 13. " SUTW ,Setup TripWire - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 14. " ATDTW ,Add dTD TripWire - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 15. " FS_2 ,See also bits 3-2 Frame List Size - (Read/Write or Read Only)." "0,1"
        textline "           "
        hexmask.long.byte 0x00 16.--24. 1. " ITC ,Interrupt Threshold Control -Read/Write."
width 12.
group.long 0x144++0x3
    line.long 0x00 "UOG1_USBSTS,USB Status Register"
        bitfld.long 0x00 0. " UI ,USB Interrupt (USBINT) - R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 1. " UEI ,USB Error Interrupt (USBERRINT) - R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 2. " PCI ,Port Change Detect - R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 3. " FRI ,Frame List Rollover - R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 4. " SEI ,System Error- R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 5. " AAI ,Interrupt on Async Advance - R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 6. " URI ,USB Reset Received - R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 7. " SRI ,SOF Received - R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 8. " SLI ,DCSuspend - R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 10. " ULPII ,ULPI Interrupt - R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 12. " HCH ,HCHaIted - Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 13. " RCL ,Reclamation - Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 14. " PS ,Periodic Schedule Status - Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 15. " AS ,Asynchronous Schedule Status - Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 16. " NAKI ,NAK Interrupt Bit--RO." "0,1"
        textline "           "
        bitfld.long 0x00 24. " TI0 ,General Purpose Timer Interrupt 0(GPTINT0)--R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 25. " TI1 ,General Purpose Timer Interrupt 1(GPTINT1)--R/WC." "0,1"
width 13.
group.long 0x148++0x3
    line.long 0x00 "UOG1_USBINTR,Interrupt Enable Register"
        bitfld.long 0x00 0. " UE ,USB Interrupt Enalbe When this bit is one and the UI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "            "
        bitfld.long 0x00 1. " UEE ,USB Error Interrupt Enable When this bit is one and the UEI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "            "
        bitfld.long 0x00 2. " PCE ,Port Change Detect Interrupt Enable When this bit is one and the PCI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "            "
        bitfld.long 0x00 3. " FRE ,Frame List Rollover Interrupt Enable When this bit is one and the FRI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "            "
        bitfld.long 0x00 4. " SEE ,System Error Interrupt Enable When this bit is one and the SEI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "            "
        bitfld.long 0x00 5. " AAE ,Async Advance Interrupt Enable When this bit is one and the AAI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "            "
        bitfld.long 0x00 6. " URE ,USB Reset Interrupt Enable When this bit is one and the URI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "            "
        bitfld.long 0x00 7. " SRE ,SOF Received Interrupt Enable When this bit is one and the SRI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "            "
        bitfld.long 0x00 8. " SLE ,Sleep Interrupt Enable When this bit is one and the SLI bit in n_n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "            "
        bitfld.long 0x00 10. " ULPIE ,ULPI Interrupt Enable When this bit is one and the UPLII bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "            "
        bitfld.long 0x00 16. " NAKE ,NAK Interrupt Enable When this bit is one and the NAKI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "            "
        bitfld.long 0x00 18. " UAIE ,USB Host Asynchronous Interrupt Enable When this bit is one, and the UAI bit in the n_USBSTS register is one, host controller will issue an interrupt at the next interrupt threshold." "0,1"
        textline "            "
        bitfld.long 0x00 19. " UPIE ,USB Host Periodic Interrupt Enable When this bit is one, and the UPI bit in the n_USBSTS register is one, host controller will issue an interrupt at the next interrupt threshold." "0,1"
        textline "            "
        bitfld.long 0x00 24. " TIE0 ,General Purpose Timer #0 Interrupt Enable When this bit is one and the TI0 bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "            "
        bitfld.long 0x00 25. " TIE1 ,General Purpose Timer #1 Interrupt Enable When this bit is one and the TI1 bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
width 13.
group.long 0x14c++0x3
    line.long 0x00 "UOG1_FRINDEX,USB Frame Index"
        hexmask.long.word 0x00 0.--14. 1. " FRINDEX ,Frame Index."
width 22.
group.long 0x154++0x3
    line.long 0x00 "UOG1_PERIODICLISTBASE,Frame List Base Address"
        hexmask.long.long 0x00 12.--32. 1. " BASEADR ,Base Address (Low)."
width 16.
group.long 0x154++0x3
    line.long 0x00 "UOG1_DEVICEADDR,Device Address"
        bitfld.long 0x00 24. " USBADRA ,Device Address Advance." "0,1"
        textline "               "
        hexmask.long.byte 0x00 25.--32. 1. " USBADR ,Device Address."
width 19.
group.long 0x158++0x3
    line.long 0x00 "UOG1_ASYNCLISTADDR,Next Asynch. Address"
        hexmask.long.long 0x00 5.--32. 1. " ASYBASE ,Link Pointer Low (LPL)."
width 19.
group.long 0x158++0x3
    line.long 0x00 "UOG1_ENDPTLISTADDR,Endpoint List Address"
        hexmask.long.long 0x00 11.--32. 1. " EPBASE ,Endpoint List Pointer(Low)."
width 15.
group.long 0x160++0x3
    line.long 0x00 "UOG1_BURSTSIZE,Programmable Burst Size"
        hexmask.long.byte 0x00 0.--8. 1. " RXPBURST ,Programmable RX Burst Size."
        textline "              "
        hexmask.long.word 0x00 8.--17. 1. " TXPBURST ,Programmable TX Burst Size."
width 18.
group.long 0x164++0x3
    line.long 0x00 "UOG1_TXFILLTUNING,TX FIFO Fill Tuning"
        hexmask.long.byte 0x00 0.--8. 1. " TXSCHOH ,Scheduler Overhead."
        textline "                 "
        hexmask.long.byte 0x00 8.--13. 1. " TXSCHHEALTH ,Scheduler Health Counter."
        textline "                 "
        hexmask.long.byte 0x00 16.--22. 1. " TXFIFOTHRES ,FIFO Burst Threshold."
width 14.
group.long 0x178++0x3
    line.long 0x00 "UOG1_ENDPTNAK,Endpoint NAK"
        hexmask.long.byte 0x00 0.--8. 1. " EPRN ,RX Endpoint NAK - R/WC."
        textline "             "
        hexmask.long.byte 0x00 16.--24. 1. " EPTN ,TX Endpoint NAK - R/WC."
width 16.
group.long 0x17c++0x3
    line.long 0x00 "UOG1_ENDPTNAKEN,Endpoint NAK Enable"
        hexmask.long.byte 0x00 0.--8. 1. " EPRNE ,RX Endpoint NAK Enable - R/W."
        textline "               "
        hexmask.long.byte 0x00 16.--24. 1. " EPTNE ,TX Endpoint NAK Enable - R/W."
width 16.
group.long 0x180++0x3
    line.long 0x00 "UOG1_CONFIGFLAG,Configure Flag Register"
        bitfld.long 0x00 0. " CF ,Configure Flag Host software sets this bit as the last action in its process of configuring the Host Controller." "0,1"
width 13.
group.long 0x184++0x3
    line.long 0x00 "UOG1_PORTSC1,Port Status & Control"
        bitfld.long 0x00 0. " CCS ,Current Connect Status-Read Only." "0,1"
        textline "            "
        bitfld.long 0x00 1. " CSC ,Connect Status Change-R/WC." "0,1"
        textline "            "
        bitfld.long 0x00 2. " PE ,Port Enabled/Disabled-Read/Write." "0,1"
        textline "            "
        bitfld.long 0x00 3. " PEC ,Port Enable/Disable Change-R/WC." "0,1"
        textline "            "
        bitfld.long 0x00 4. " OCA ,Over-current Active-Read Only." "0,1"
        textline "            "
        bitfld.long 0x00 5. " OCC ,Over-current Change-R/WC." "0,1"
        textline "            "
        bitfld.long 0x00 6. " FPR ,Force Port Resume -Read/Write." "0,1"
        textline "            "
        bitfld.long 0x00 7. " SUSP ,Suspend - Read/Write or Read Only." "0,1"
        textline "            "
        bitfld.long 0x00 8. " PR ,Port Reset - Read/Write or Read Only." "0,1"
        textline "            "
        bitfld.long 0x00 9. " HSP ,High-Speed Port - Read Only." "0,1"
        textline "            "
        hexmask.long.byte 0x00 10.--12. 1. " LS ,Line Status-Read Only."
        textline "            "
        bitfld.long 0x00 12. " PP ,Port Power (PP)-Read/Write or Read Only." "0,1"
        textline "            "
        bitfld.long 0x00 13. " PO ,Port Owner-Read/Write." "0,1"
        textline "            "
        hexmask.long.byte 0x00 14.--16. 1. " PIC ,Port Indicator Control - Read/Write."
        textline "            "
        hexmask.long.byte 0x00 16.--20. 1. " PTC ,Port Test Control - Read/Write."
        textline "            "
        bitfld.long 0x00 20. " WKCN ,Wake on Connect Enable (WKCNNT_E) - Read/Write." "0,1"
        textline "            "
        bitfld.long 0x00 21. " WKDC ,Wake on Disconnect Enable (WKDSCNNT_E) - Read/Write." "0,1"
        textline "            "
        bitfld.long 0x00 22. " WKOC ,Wake on Over-current Enable (WKOC_E) - Read/Write." "0,1"
        textline "            "
        bitfld.long 0x00 23. " PHCD ,PHY Low Power Suspend - Clock Disable (PLPSCD) - Read/Write." "0,1"
        textline "            "
        bitfld.long 0x00 24. " PFSC ,Port Force Full Speed Connect - Read/Write." "0,1"
        textline "            "
        bitfld.long 0x00 25. " PTS_2 ,See description at bits 31-30" "0,1"
        textline "            "
        hexmask.long.byte 0x00 26.--28. 1. " PSPD ,Port Speed - Read Only."
        textline "            "
        bitfld.long 0x00 28. " PTW ,Parallel Transceiver Width This bit has no effect if serial interface engine is used." "0,1"
        textline "            "
        bitfld.long 0x00 29. " STS ,Serial Transceiver Select - Read Only Serial Transceiver Select 1 Serial Interface Engine is selected 0 Parallel Interface signals is selected Serial Interface Engine can be used in combination with UTMI+/ULPI physical interface to provide FS/LS signaling instead of the parallel interface signals." "0,1"
        textline "            "
        hexmask.long.byte 0x00 30.--32. 1. " PTS_1 ,Bit field {bit25, bit31, bit30}: ""000b"" UTMI/UTMI+ ""001b"" Reserved ""010b"" ULPI ""011b"" Serial/USB 1.1 PHY/IC-USB (FS Only) ""100b"" HSIC All USB port interface modes are listed in this field description, but not all are supported."
width 11.
group.long 0x1a4++0x3
    line.long 0x00 "UOG1_OTGSC,On-The-Go Status & control"
        bitfld.long 0x00 0. " VD ,VBUS_Discharge - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 1. " VC ,VBUS Charge - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 3. " OT ,OTG Termination - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 4. " DP ,Data Pulsing - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 5. " IDPU ,ID Pullup - Read/Write This bit provide control over the ID pull-up resister; 0 = off, 1 = on [default]." "0,1"
        textline "          "
        bitfld.long 0x00 8. " ID ,USB ID - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 9. " AVV ,A VBus Valid - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 10. " ASV ,A Session Valid - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 11. " BSV ,B Session Valid - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 12. " BSE ,B Session End - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 13. " _1MST ,1 millisecond timer toggle - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 14. " DPS ,Data Bus Pulsing Status - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 16. " IDIS ,USB ID Interrupt Status - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 17. " AVVIS ,A VBus Valid Interrupt Status - Read/Write to Clear." "0,1"
        textline "          "
        bitfld.long 0x00 18. " ASVIS ,A Session Valid Interrupt Status - Read/Write to Clear." "0,1"
        textline "          "
        bitfld.long 0x00 19. " BSVIS ,B Session Valid Interrupt Status - Read/Write to Clear." "0,1"
        textline "          "
        bitfld.long 0x00 20. " BSEIS ,B Session End Interrupt Status - Read/Write to Clear." "0,1"
        textline "          "
        bitfld.long 0x00 21. " _1MSS ,1 millisecond timer Interrupt Status - Read/Write to Clear." "0,1"
        textline "          "
        bitfld.long 0x00 22. " DPIS ,Data Pulse Interrupt Status - Read/Write to Clear." "0,1"
        textline "          "
        bitfld.long 0x00 24. " IDIE ,USB ID Interrupt Enable - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 25. " AVVIE ,A VBus Valid Interrupt Enable - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 26. " ASVIE ,A Session Valid Interrupt Enable - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 27. " BSVIE ,B Session Valid Interrupt Enable - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 28. " BSEIE ,B Session End Interrupt Enable - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 29. " _1MSE ,1 millisecond timer Interrupt Enable - Read/Write" "0,1"
        textline "          "
        bitfld.long 0x00 30. " DPIE ,Data Pulse Interrupt Enable" "0,1"
width 13.
group.long 0x1a8++0x3
    line.long 0x00 "UOG1_USBMODE,USB Device Mode"
        hexmask.long.byte 0x00 0.--2. 1. " CM ,Controller Mode - R/WO."
        textline "            "
        bitfld.long 0x00 2. " ES ,Endian Select - Read/Write." "0,1"
        textline "            "
        bitfld.long 0x00 3. " SLOM ,Setup Lockout Mode." "0,1"
        textline "            "
        bitfld.long 0x00 4. " SDIS ,Stream Disable Mode." "0,1"
width 20.
group.long 0x1ac++0x3
    line.long 0x00 "UOG1_ENDPTSETUPSTAT,Endpoint Setup Status"
        hexmask.long.word 0x00 0.--16. 1. " ENDPTSETUPSTAT ,Setup Endpoint Status."
width 16.
group.long 0x1b0++0x3
    line.long 0x00 "UOG1_ENDPTPRIME,Endpoint Prime"
        hexmask.long.byte 0x00 0.--8. 1. " PERB ,Prime Endpoint Receive Buffer - R/WS."
        textline "               "
        hexmask.long.byte 0x00 16.--24. 1. " PETB ,Prime Endpoint Transmit Buffer - R/WS."
width 16.
group.long 0x1b4++0x3
    line.long 0x00 "UOG1_ENDPTFLUSH,Endpoint Flush"
        hexmask.long.byte 0x00 0.--8. 1. " FERB ,Flush Endpoint Receive Buffer - R/WS."
        textline "               "
        hexmask.long.byte 0x00 16.--24. 1. " FETB ,Flush Endpoint Transmit Buffer - R/WS."
width 15.
rgroup.long 0x1b8++0x3
    line.long 0x00 "UOG1_ENDPTSTAT,Endpoint Status"
        hexmask.long.byte 0x00 0.--8. 1. " ERBR ,Endpoint Receive Buffer Ready -- Read Only."
        textline "              "
        hexmask.long.byte 0x00 16.--24. 1. " ETBR ,Endpoint Transmit Buffer Ready -- Read Only."
width 19.
group.long 0x1bc++0x3
    line.long 0x00 "UOG1_ENDPTCOMPLETE,Endpoint Complete"
        hexmask.long.byte 0x00 0.--8. 1. " ERCE ,Endpoint Receive Complete Event - RW/C."
        textline "                  "
        hexmask.long.byte 0x00 16.--24. 1. " ETCE ,Endpoint Transmit Complete Event - R/WC."
width 16.
group.long 0x1c0++0x3
    line.long 0x00 "UOG1_ENDPTCTRL0,Endpoint Control0"
        bitfld.long 0x00 0. " RXS ,RX Endpoint Stall - Read/Write 0 End Point OK." "0,1"
        textline "               "
        hexmask.long.byte 0x00 2.--4. 1. " RXT ,RX Endpoint Type - Read/Write 00 Control Endpoint0 is fixed as a Control End Point."
        textline "               "
        bitfld.long 0x00 7. " RXE ,RX Endpoint Enable 1 Enabled Endpoint0 is always enabled." "0,1"
        textline "               "
        bitfld.long 0x00 16. " TXS ,TX Endpoint Stall - Read/Write 0 End Point OK [Default] 1 End Point Stalled Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host." "0,1"
        textline "               "
        hexmask.long.byte 0x00 18.--20. 1. " TXT ,TX Endpoint Type - Read/Write 00 - Control Endpoint0 is fixed as a Control End Point."
        textline "               "
        bitfld.long 0x00 23. " TXE ,TX Endpoint Enable 1 Enabled Endpoint0 is always enabled." "0,1"
width 16.
group.long 0x1c4++0x3
    line.long 0x00 "UOG1_ENDPTCTRL1,Endpoint Control 1"
        bitfld.long 0x00 0. " RXS ,RX Endpoint Stall - Read/Write 0 End Point OK." "0,1"
        textline "               "
        bitfld.long 0x00 1. " RXD ,RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA Engine [Default] Should always be written as zero." "0,1"
        textline "               "
        hexmask.long.byte 0x00 2.--4. 1. " RXT ,RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Reserved"
        textline "               "
        bitfld.long 0x00 5. " RXI ,RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only used for test and should always be written as zero." "0,1"
        textline "               "
        bitfld.long 0x00 6. " RXR ,RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device." "0,1"
        textline "               "
        bitfld.long 0x00 7. " RXE ,RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
        textline "               "
        bitfld.long 0x00 16. " TXS ,TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This bit is set automatically upon receipt of a SETUP request if this Endpoint is not configured as a Control Endpoint." "0,1"
        textline "               "
        bitfld.long 0x00 17. " TXD ,TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Engine [DEFAULT] Should always be written as 0." "0,1"
        textline "               "
        hexmask.long.byte 0x00 18.--20. 1. " TXT ,TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt"
        textline "               "
        bitfld.long 0x00 21. " TXI ,TX Data Toggle Inhibit 0 PID Sequencing Enabled." "0,1"
        textline "               "
        bitfld.long 0x00 22. " TXR ,TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the Host and device." "0,1"
        textline "               "
        bitfld.long 0x00 23. " TXE ,TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
width 16.
group.long 0x1c8++0x3
    line.long 0x00 "UOG1_ENDPTCTRL2,Endpoint Control 2"
        bitfld.long 0x00 0. " RXS ,RX Endpoint Stall - Read/Write 0 End Point OK." "0,1"
        textline "               "
        bitfld.long 0x00 1. " RXD ,RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA Engine [Default] Should always be written as zero." "0,1"
        textline "               "
        hexmask.long.byte 0x00 2.--4. 1. " RXT ,RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Reserved"
        textline "               "
        bitfld.long 0x00 5. " RXI ,RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only used for test and should always be written as zero." "0,1"
        textline "               "
        bitfld.long 0x00 6. " RXR ,RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device." "0,1"
        textline "               "
        bitfld.long 0x00 7. " RXE ,RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
        textline "               "
        bitfld.long 0x00 16. " TXS ,TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This bit is set automatically upon receipt of a SETUP request if this Endpoint is not configured as a Control Endpoint." "0,1"
        textline "               "
        bitfld.long 0x00 17. " TXD ,TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Engine [DEFAULT] Should always be written as 0." "0,1"
        textline "               "
        hexmask.long.byte 0x00 18.--20. 1. " TXT ,TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt"
        textline "               "
        bitfld.long 0x00 21. " TXI ,TX Data Toggle Inhibit 0 PID Sequencing Enabled." "0,1"
        textline "               "
        bitfld.long 0x00 22. " TXR ,TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the Host and device." "0,1"
        textline "               "
        bitfld.long 0x00 23. " TXE ,TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
width 16.
group.long 0x1cc++0x3
    line.long 0x00 "UOG1_ENDPTCTRL3,Endpoint Control 3"
        bitfld.long 0x00 0. " RXS ,RX Endpoint Stall - Read/Write 0 End Point OK." "0,1"
        textline "               "
        bitfld.long 0x00 1. " RXD ,RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA Engine [Default] Should always be written as zero." "0,1"
        textline "               "
        hexmask.long.byte 0x00 2.--4. 1. " RXT ,RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Reserved"
        textline "               "
        bitfld.long 0x00 5. " RXI ,RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only used for test and should always be written as zero." "0,1"
        textline "               "
        bitfld.long 0x00 6. " RXR ,RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device." "0,1"
        textline "               "
        bitfld.long 0x00 7. " RXE ,RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
        textline "               "
        bitfld.long 0x00 16. " TXS ,TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This bit is set automatically upon receipt of a SETUP request if this Endpoint is not configured as a Control Endpoint." "0,1"
        textline "               "
        bitfld.long 0x00 17. " TXD ,TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Engine [DEFAULT] Should always be written as 0." "0,1"
        textline "               "
        hexmask.long.byte 0x00 18.--20. 1. " TXT ,TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt"
        textline "               "
        bitfld.long 0x00 21. " TXI ,TX Data Toggle Inhibit 0 PID Sequencing Enabled." "0,1"
        textline "               "
        bitfld.long 0x00 22. " TXR ,TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the Host and device." "0,1"
        textline "               "
        bitfld.long 0x00 23. " TXE ,TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
width 16.
group.long 0x1d0++0x3
    line.long 0x00 "UOG1_ENDPTCTRL4,Endpoint Control 4"
        bitfld.long 0x00 0. " RXS ,RX Endpoint Stall - Read/Write 0 End Point OK." "0,1"
        textline "               "
        bitfld.long 0x00 1. " RXD ,RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA Engine [Default] Should always be written as zero." "0,1"
        textline "               "
        hexmask.long.byte 0x00 2.--4. 1. " RXT ,RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Reserved"
        textline "               "
        bitfld.long 0x00 5. " RXI ,RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only used for test and should always be written as zero." "0,1"
        textline "               "
        bitfld.long 0x00 6. " RXR ,RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device." "0,1"
        textline "               "
        bitfld.long 0x00 7. " RXE ,RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
        textline "               "
        bitfld.long 0x00 16. " TXS ,TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This bit is set automatically upon receipt of a SETUP request if this Endpoint is not configured as a Control Endpoint." "0,1"
        textline "               "
        bitfld.long 0x00 17. " TXD ,TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Engine [DEFAULT] Should always be written as 0." "0,1"
        textline "               "
        hexmask.long.byte 0x00 18.--20. 1. " TXT ,TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt"
        textline "               "
        bitfld.long 0x00 21. " TXI ,TX Data Toggle Inhibit 0 PID Sequencing Enabled." "0,1"
        textline "               "
        bitfld.long 0x00 22. " TXR ,TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the Host and device." "0,1"
        textline "               "
        bitfld.long 0x00 23. " TXE ,TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
width 16.
group.long 0x1d4++0x3
    line.long 0x00 "UOG1_ENDPTCTRL5,Endpoint Control 5"
        bitfld.long 0x00 0. " RXS ,RX Endpoint Stall - Read/Write 0 End Point OK." "0,1"
        textline "               "
        bitfld.long 0x00 1. " RXD ,RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA Engine [Default] Should always be written as zero." "0,1"
        textline "               "
        hexmask.long.byte 0x00 2.--4. 1. " RXT ,RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Reserved"
        textline "               "
        bitfld.long 0x00 5. " RXI ,RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only used for test and should always be written as zero." "0,1"
        textline "               "
        bitfld.long 0x00 6. " RXR ,RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device." "0,1"
        textline "               "
        bitfld.long 0x00 7. " RXE ,RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
        textline "               "
        bitfld.long 0x00 16. " TXS ,TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This bit is set automatically upon receipt of a SETUP request if this Endpoint is not configured as a Control Endpoint." "0,1"
        textline "               "
        bitfld.long 0x00 17. " TXD ,TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Engine [DEFAULT] Should always be written as 0." "0,1"
        textline "               "
        hexmask.long.byte 0x00 18.--20. 1. " TXT ,TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt"
        textline "               "
        bitfld.long 0x00 21. " TXI ,TX Data Toggle Inhibit 0 PID Sequencing Enabled." "0,1"
        textline "               "
        bitfld.long 0x00 22. " TXR ,TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the Host and device." "0,1"
        textline "               "
        bitfld.long 0x00 23. " TXE ,TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
width 16.
group.long 0x1d8++0x3
    line.long 0x00 "UOG1_ENDPTCTRL6,Endpoint Control 6"
        bitfld.long 0x00 0. " RXS ,RX Endpoint Stall - Read/Write 0 End Point OK." "0,1"
        textline "               "
        bitfld.long 0x00 1. " RXD ,RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA Engine [Default] Should always be written as zero." "0,1"
        textline "               "
        hexmask.long.byte 0x00 2.--4. 1. " RXT ,RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Reserved"
        textline "               "
        bitfld.long 0x00 5. " RXI ,RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only used for test and should always be written as zero." "0,1"
        textline "               "
        bitfld.long 0x00 6. " RXR ,RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device." "0,1"
        textline "               "
        bitfld.long 0x00 7. " RXE ,RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
        textline "               "
        bitfld.long 0x00 16. " TXS ,TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This bit is set automatically upon receipt of a SETUP request if this Endpoint is not configured as a Control Endpoint." "0,1"
        textline "               "
        bitfld.long 0x00 17. " TXD ,TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Engine [DEFAULT] Should always be written as 0." "0,1"
        textline "               "
        hexmask.long.byte 0x00 18.--20. 1. " TXT ,TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt"
        textline "               "
        bitfld.long 0x00 21. " TXI ,TX Data Toggle Inhibit 0 PID Sequencing Enabled." "0,1"
        textline "               "
        bitfld.long 0x00 22. " TXR ,TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the Host and device." "0,1"
        textline "               "
        bitfld.long 0x00 23. " TXE ,TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
width 16.
group.long 0x1dc++0x3
    line.long 0x00 "UOG1_ENDPTCTRL7,Endpoint Control 7"
        bitfld.long 0x00 0. " RXS ,RX Endpoint Stall - Read/Write 0 End Point OK." "0,1"
        textline "               "
        bitfld.long 0x00 1. " RXD ,RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA Engine [Default] Should always be written as zero." "0,1"
        textline "               "
        hexmask.long.byte 0x00 2.--4. 1. " RXT ,RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Reserved"
        textline "               "
        bitfld.long 0x00 5. " RXI ,RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only used for test and should always be written as zero." "0,1"
        textline "               "
        bitfld.long 0x00 6. " RXR ,RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device." "0,1"
        textline "               "
        bitfld.long 0x00 7. " RXE ,RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
        textline "               "
        bitfld.long 0x00 16. " TXS ,TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This bit is set automatically upon receipt of a SETUP request if this Endpoint is not configured as a Control Endpoint." "0,1"
        textline "               "
        bitfld.long 0x00 17. " TXD ,TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Engine [DEFAULT] Should always be written as 0." "0,1"
        textline "               "
        hexmask.long.byte 0x00 18.--20. 1. " TXT ,TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt"
        textline "               "
        bitfld.long 0x00 21. " TXI ,TX Data Toggle Inhibit 0 PID Sequencing Enabled." "0,1"
        textline "               "
        bitfld.long 0x00 22. " TXR ,TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the Host and device." "0,1"
        textline "               "
        bitfld.long 0x00 23. " TXE ,TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
width 8.
rgroup.long 0x200++0x3
    line.long 0x00 "UOG2_ID,Identification register"
        hexmask.long.byte 0x00 0.--6. 1. " ID ,Configuration number."
        textline "       "
        hexmask.long.byte 0x00 8.--14. 1. " NID ,Complement version of ID"
        textline "       "
        hexmask.long.byte 0x00 16.--24. 1. " REVISION ,Revision number of the controller core."
width 15.
rgroup.long 0x204++0x3
    line.long 0x00 "UOG2_HWGENERAL,Hardware General"
        hexmask.long.byte 0x00 4.--6. 1. " PHYW ,Data width of the transciever connected to the controller core."
        textline "              "
        hexmask.long.byte 0x00 6.--9. 1. " PHYM ,Transciever type PHYM bit reset value: '0000b' for OTG controller core, '0100b' for Host-only controller core."
        textline "              "
        hexmask.long.byte 0x00 9.--11. 1. " SM ,Serial interface mode capability SM bit reset value is '00b'"
width 12.
rgroup.long 0x208++0x3
    line.long 0x00 "UOG2_HWHOST,Host Hardware Parameters"
        bitfld.long 0x00 0. " HC ,Host Capable." "0,1"
        textline "           "
        hexmask.long.byte 0x00 1.--4. 1. " NPORT ,The Nmber of downstream ports supported by the host controller is (NPORT+1)."
width 14.
rgroup.long 0x20c++0x3
    line.long 0x00 "UOG2_HWDEVICE,Device Hardware Parameters"
        bitfld.long 0x00 0. " DC ,Device Capable." "0,1"
        textline "             "
        hexmask.long.byte 0x00 1.--6. 1. " DEVEP ,Device Endpoint Number"
width 13.
rgroup.long 0x210++0x3
    line.long 0x00 "UOG2_HWTXBUF,TX Buffer Hardware Parameters"
        hexmask.long.byte 0x00 0.--8. 1. " TXBURST ,Default burst size for memory to TX buffer transfer."
        textline "            "
        hexmask.long.byte 0x00 16.--24. 1. " TXCHANADD ,TX FIFO Buffer size is: (2^TXCHANADD) * 4 Bytes."
width 13.
rgroup.long 0x214++0x3
    line.long 0x00 "UOG2_HWRXBUF,RX Buffer Hardware Parameters"
        hexmask.long.byte 0x00 0.--8. 1. " RXBURST ,Default burst size for memory to RX buffer transfer."
        textline "            "
        hexmask.long.byte 0x00 8.--16. 1. " RXADD ,Buffer total size for all receive endpoints is (2^RXADD)."
width 16.
group.long 0x280++0x3
    line.long 0x00 "UOG2_GPTIMER0LD,General Purpose Timer #0 Load"
        hexmask.long.long 0x00 0.--24. 1. " GPTLD ,General Purpose Timer Load Value These bit fields are loaded to GPTCNT bits when GPTRST bit is set '1b'."
width 18.
group.long 0x284++0x3
    line.long 0x00 "UOG2_GPTIMER0CTRL,General Purpose Timer #0 Controller"
        hexmask.long.long 0x00 0.--24. 1. " GPTCNT ,General Purpose Timer Counter."
        textline "                 "
        bitfld.long 0x00 24. " GPTMODE ,General Purpose Timer Mode In one shot mode, the timer will count down to zero, generate an interrupt, and stop until the counter is reset by software; In repeat mode, the timer will count down to zero, generate an interrupt and automatically reload the counter value from GPTLD bits to start again." "0,1"
        textline "                 "
        bitfld.long 0x00 30. " GPTRST ,General Purpose Timer Reset" "0,1"
        textline "                 "
        bitfld.long 0x00 31. " GPTRUN ,General Purpose Timer Run GPTCNT bits are not effected when setting or clearing this bit." "0,1"
width 16.
group.long 0x288++0x3
    line.long 0x00 "UOG2_GPTIMER1LD,General Purpose Timer #1 Load"
        hexmask.long.long 0x00 0.--24. 1. " GPTLD ,General Purpose Timer Load Value These bit fields are loaded to GPTCNT bits when GPTRST bit is set '1b'."
width 18.
group.long 0x28c++0x3
    line.long 0x00 "UOG2_GPTIMER1CTRL,General Purpose Timer #1 Controller"
        hexmask.long.long 0x00 0.--24. 1. " GPTCNT ,General Purpose Timer Counter."
        textline "                 "
        bitfld.long 0x00 24. " GPTMODE ,General Purpose Timer Mode In one shot mode, the timer will count down to zero, generate an interrupt, and stop until the counter is reset by software." "0,1"
        textline "                 "
        bitfld.long 0x00 30. " GPTRST ,General Purpose Timer Reset" "0,1"
        textline "                 "
        bitfld.long 0x00 31. " GPTRUN ,General Purpose Timer Run GPTCNT bits are not effected when setting or clearing this bit." "0,1"
width 13.
group.long 0x290++0x3
    line.long 0x00 "UOG2_SBUSCFG,System Bus Config"
        hexmask.long.byte 0x00 0.--3. 1. " AHBBRST ,AHB master interface Burst configuration These bits control AHB master transfer type sequence (or priority)."
width 15.
rgroup.byte 0x300++0x0
    line.byte 0x00 "UOG2_CAPLENGTH,Capability Registers Length"
        hexmask.byte.byte 0x00 0.--8. 1. " CAPLENGTH ,These bits are used as an offset to add to register base to find the beginning of the Operational Register."
width 16.
rgroup.word 0x302++0x1
    line.word 0x00 "UOG2_HCIVERSION,Host Controller Interface Version"
        hexmask.word.word 0x00 0.--16. 1. " HCIVERSION ,Host Controller Interface Version Number Default value is '10h', which means EHCI rev1.0."
width 15.
rgroup.long 0x304++0x3
    line.long 0x00 "UOG2_HCSPARAMS,Host Controller Structural Parameters"
        hexmask.long.byte 0x00 0.--4. 1. " N_PORTS ,Number of downstream ports."
        textline "              "
        bitfld.long 0x00 4. " PPC ,Port Power Control This field indicates whether the host controller implementation includes port power control." "0,1"
        textline "              "
        hexmask.long.byte 0x00 8.--12. 1. " N_PCC ,Number of Ports per Companion Controller This field indicates the number of ports supported per internal Companion Controller."
        textline "              "
        hexmask.long.byte 0x00 12.--16. 1. " N_CC ,Number of Companion Controller (N_CC)."
        textline "              "
        bitfld.long 0x00 16. " PI ,Port Indicators (P INDICATOR) This bit indicates whether the ports support port indicator control." "0,1"
        textline "              "
        hexmask.long.byte 0x00 20.--24. 1. " N_PTT ,Number of Ports per Transaction Translator (N_PTT)."
        textline "              "
        hexmask.long.byte 0x00 24.--28. 1. " N_TT ,Number of Transaction Translators (N_TT)."
width 15.
rgroup.long 0x308++0x3
    line.long 0x00 "UOG2_HCCPARAMS,Host Controller Capability Parameters"
        bitfld.long 0x00 0. " ADC ,64-bit Addressing Capability This bit is set '0b' in all controller core, no 64-bit addressing capability is supported." "0,1"
        textline "              "
        bitfld.long 0x00 1. " PFL ,Programmable Frame List Flag If this bit is set to zero, then the system software must use a frame list length of 1024 elements with this host controller." "0,1"
        textline "              "
        bitfld.long 0x00 2. " ASP ,Asynchronous Schedule Park Capability If this bit is set to a one, then the host controller supports the park feature for high-speed queue heads in the Asynchronous Schedule." "0,1"
        textline "              "
        hexmask.long.byte 0x00 4.--8. 1. " IST ,Isochronous Scheduling Threshold."
        textline "              "
        hexmask.long.byte 0x00 8.--16. 1. " EECP ,EHCI Extended Capabilities Pointer."
width 16.
rgroup.word 0x320++0x1
    line.word 0x00 "UOG2_DCIVERSION,Device Controller Interface Version"
        hexmask.word.word 0x00 0.--16. 1. " DCIVERSION ,Device Controller Interface Version Number Default value is '01h', which means rev0.1."
width 15.
rgroup.long 0x324++0x3
    line.long 0x00 "UOG2_DCCPARAMS,Device Controller Capability Parameters"
        hexmask.long.byte 0x00 0.--5. 1. " DEN ,Device Endpoint Number This field indicates the number of endpoints built into the device controller."
        textline "              "
        bitfld.long 0x00 7. " DC ,Device Capable When this bit is 1, this controller is capable of operating as a USB 2.0 device." "0,1"
        textline "              "
        bitfld.long 0x00 8. " HC ,Host Capable When this bit is 1, this controller is capable of operating as an EHCI compatible USB 2.0 host controller." "0,1"
width 12.
group.long 0x340++0x3
    line.long 0x00 "UOG2_USBCMD,USB Command Register"
        bitfld.long 0x00 0. " RS ,Run/Stop (RS) - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 1. " RST ,Controller Reset (RESET) - Read/Write." "0,1"
        textline "           "
        hexmask.long.byte 0x00 2.--4. 1. " FS_1 ,See description at bit 15"
        textline "           "
        bitfld.long 0x00 4. " PSE ,Periodic Schedule Enable- Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 5. " ASE ,Asynchronous Schedule Enable - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 6. " IAA ,Interrupt on Async Advance Doorbell - Read/Write." "0,1"
        textline "           "
        hexmask.long.byte 0x00 8.--10. 1. " ASP ,Asynchronous Schedule Park Mode Count - Read/Write."
        textline "           "
        bitfld.long 0x00 11. " ASPE ,Asynchronous Schedule Park Mode Enable - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 13. " SUTW ,Setup TripWire - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 14. " ATDTW ,Add dTD TripWire - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 15. " FS_2 ,See also bits 3-2 Frame List Size - (Read/Write or Read Only)." "0,1"
        textline "           "
        hexmask.long.byte 0x00 16.--24. 1. " ITC ,Interrupt Threshold Control -Read/Write."
width 12.
group.long 0x344++0x3
    line.long 0x00 "UOG2_USBSTS,USB Status Register"
        bitfld.long 0x00 0. " UI ,USB Interrupt (USBINT) - R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 1. " UEI ,USB Error Interrupt (USBERRINT) - R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 2. " PCI ,Port Change Detect - R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 3. " FRI ,Frame List Rollover - R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 4. " SEI ,System Error- R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 5. " AAI ,Interrupt on Async Advance - R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 6. " URI ,USB Reset Received - R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 7. " SRI ,SOF Received - R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 8. " SLI ,DCSuspend - R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 10. " ULPII ,ULPI Interrupt - R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 12. " HCH ,HCHaIted - Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 13. " RCL ,Reclamation - Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 14. " PS ,Periodic Schedule Status - Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 15. " AS ,Asynchronous Schedule Status - Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 16. " NAKI ,NAK Interrupt Bit--RO." "0,1"
        textline "           "
        bitfld.long 0x00 24. " TI0 ,General Purpose Timer Interrupt 0(GPTINT0)--R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 25. " TI1 ,General Purpose Timer Interrupt 1(GPTINT1)--R/WC." "0,1"
width 13.
group.long 0x348++0x3
    line.long 0x00 "UOG2_USBINTR,Interrupt Enable Register"
        bitfld.long 0x00 0. " UE ,USB Interrupt Enalbe When this bit is one and the UI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "            "
        bitfld.long 0x00 1. " UEE ,USB Error Interrupt Enable When this bit is one and the UEI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "            "
        bitfld.long 0x00 2. " PCE ,Port Change Detect Interrupt Enable When this bit is one and the PCI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "            "
        bitfld.long 0x00 3. " FRE ,Frame List Rollover Interrupt Enable When this bit is one and the FRI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "            "
        bitfld.long 0x00 4. " SEE ,System Error Interrupt Enable When this bit is one and the SEI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "            "
        bitfld.long 0x00 5. " AAE ,Async Advance Interrupt Enable When this bit is one and the AAI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "            "
        bitfld.long 0x00 6. " URE ,USB Reset Interrupt Enable When this bit is one and the URI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "            "
        bitfld.long 0x00 7. " SRE ,SOF Received Interrupt Enable When this bit is one and the SRI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "            "
        bitfld.long 0x00 8. " SLE ,Sleep Interrupt Enable When this bit is one and the SLI bit in n_n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "            "
        bitfld.long 0x00 10. " ULPIE ,ULPI Interrupt Enable When this bit is one and the UPLII bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "            "
        bitfld.long 0x00 16. " NAKE ,NAK Interrupt Enable When this bit is one and the NAKI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "            "
        bitfld.long 0x00 18. " UAIE ,USB Host Asynchronous Interrupt Enable When this bit is one, and the UAI bit in the n_USBSTS register is one, host controller will issue an interrupt at the next interrupt threshold." "0,1"
        textline "            "
        bitfld.long 0x00 19. " UPIE ,USB Host Periodic Interrupt Enable When this bit is one, and the UPI bit in the n_USBSTS register is one, host controller will issue an interrupt at the next interrupt threshold." "0,1"
        textline "            "
        bitfld.long 0x00 24. " TIE0 ,General Purpose Timer #0 Interrupt Enable When this bit is one and the TI0 bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "            "
        bitfld.long 0x00 25. " TIE1 ,General Purpose Timer #1 Interrupt Enable When this bit is one and the TI1 bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
width 13.
group.long 0x34c++0x3
    line.long 0x00 "UOG2_FRINDEX,USB Frame Index"
        hexmask.long.word 0x00 0.--14. 1. " FRINDEX ,Frame Index."
width 22.
group.long 0x354++0x3
    line.long 0x00 "UOG2_PERIODICLISTBASE,Frame List Base Address"
        hexmask.long.long 0x00 12.--32. 1. " BASEADR ,Base Address (Low)."
width 16.
group.long 0x354++0x3
    line.long 0x00 "UOG2_DEVICEADDR,Device Address"
        bitfld.long 0x00 24. " USBADRA ,Device Address Advance." "0,1"
        textline "               "
        hexmask.long.byte 0x00 25.--32. 1. " USBADR ,Device Address."
width 19.
group.long 0x358++0x3
    line.long 0x00 "UOG2_ASYNCLISTADDR,Next Asynch. Address"
        hexmask.long.long 0x00 5.--32. 1. " ASYBASE ,Link Pointer Low (LPL)."
width 19.
group.long 0x358++0x3
    line.long 0x00 "UOG2_ENDPTLISTADDR,Endpoint List Address"
        hexmask.long.long 0x00 11.--32. 1. " EPBASE ,Endpoint List Pointer(Low)."
width 15.
group.long 0x360++0x3
    line.long 0x00 "UOG2_BURSTSIZE,Programmable Burst Size"
        hexmask.long.byte 0x00 0.--8. 1. " RXPBURST ,Programmable RX Burst Size."
        textline "              "
        hexmask.long.word 0x00 8.--17. 1. " TXPBURST ,Programmable TX Burst Size."
width 18.
group.long 0x364++0x3
    line.long 0x00 "UOG2_TXFILLTUNING,TX FIFO Fill Tuning"
        hexmask.long.byte 0x00 0.--8. 1. " TXSCHOH ,Scheduler Overhead."
        textline "                 "
        hexmask.long.byte 0x00 8.--13. 1. " TXSCHHEALTH ,Scheduler Health Counter."
        textline "                 "
        hexmask.long.byte 0x00 16.--22. 1. " TXFIFOTHRES ,FIFO Burst Threshold."
width 14.
group.long 0x378++0x3
    line.long 0x00 "UOG2_ENDPTNAK,Endpoint NAK"
        hexmask.long.byte 0x00 0.--8. 1. " EPRN ,RX Endpoint NAK - R/WC."
        textline "             "
        hexmask.long.byte 0x00 16.--24. 1. " EPTN ,TX Endpoint NAK - R/WC."
width 16.
group.long 0x37c++0x3
    line.long 0x00 "UOG2_ENDPTNAKEN,Endpoint NAK Enable"
        hexmask.long.byte 0x00 0.--8. 1. " EPRNE ,RX Endpoint NAK Enable - R/W."
        textline "               "
        hexmask.long.byte 0x00 16.--24. 1. " EPTNE ,TX Endpoint NAK Enable - R/W."
width 16.
group.long 0x380++0x3
    line.long 0x00 "UOG2_CONFIGFLAG,Configure Flag Register"
        bitfld.long 0x00 0. " CF ,Configure Flag Host software sets this bit as the last action in its process of configuring the Host Controller." "0,1"
width 13.
group.long 0x384++0x3
    line.long 0x00 "UOG2_PORTSC1,Port Status & Control"
        bitfld.long 0x00 0. " CCS ,Current Connect Status-Read Only." "0,1"
        textline "            "
        bitfld.long 0x00 1. " CSC ,Connect Status Change-R/WC." "0,1"
        textline "            "
        bitfld.long 0x00 2. " PE ,Port Enabled/Disabled-Read/Write." "0,1"
        textline "            "
        bitfld.long 0x00 3. " PEC ,Port Enable/Disable Change-R/WC." "0,1"
        textline "            "
        bitfld.long 0x00 4. " OCA ,Over-current Active-Read Only." "0,1"
        textline "            "
        bitfld.long 0x00 5. " OCC ,Over-current Change-R/WC." "0,1"
        textline "            "
        bitfld.long 0x00 6. " FPR ,Force Port Resume -Read/Write." "0,1"
        textline "            "
        bitfld.long 0x00 7. " SUSP ,Suspend - Read/Write or Read Only." "0,1"
        textline "            "
        bitfld.long 0x00 8. " PR ,Port Reset - Read/Write or Read Only." "0,1"
        textline "            "
        bitfld.long 0x00 9. " HSP ,High-Speed Port - Read Only." "0,1"
        textline "            "
        hexmask.long.byte 0x00 10.--12. 1. " LS ,Line Status-Read Only."
        textline "            "
        bitfld.long 0x00 12. " PP ,Port Power (PP)-Read/Write or Read Only." "0,1"
        textline "            "
        bitfld.long 0x00 13. " PO ,Port Owner-Read/Write." "0,1"
        textline "            "
        hexmask.long.byte 0x00 14.--16. 1. " PIC ,Port Indicator Control - Read/Write."
        textline "            "
        hexmask.long.byte 0x00 16.--20. 1. " PTC ,Port Test Control - Read/Write."
        textline "            "
        bitfld.long 0x00 20. " WKCN ,Wake on Connect Enable (WKCNNT_E) - Read/Write." "0,1"
        textline "            "
        bitfld.long 0x00 21. " WKDC ,Wake on Disconnect Enable (WKDSCNNT_E) - Read/Write." "0,1"
        textline "            "
        bitfld.long 0x00 22. " WKOC ,Wake on Over-current Enable (WKOC_E) - Read/Write." "0,1"
        textline "            "
        bitfld.long 0x00 23. " PHCD ,PHY Low Power Suspend - Clock Disable (PLPSCD) - Read/Write." "0,1"
        textline "            "
        bitfld.long 0x00 24. " PFSC ,Port Force Full Speed Connect - Read/Write." "0,1"
        textline "            "
        bitfld.long 0x00 25. " PTS_2 ,See description at bits 31-30" "0,1"
        textline "            "
        hexmask.long.byte 0x00 26.--28. 1. " PSPD ,Port Speed - Read Only."
        textline "            "
        bitfld.long 0x00 28. " PTW ,Parallel Transceiver Width This bit has no effect if serial interface engine is used." "0,1"
        textline "            "
        bitfld.long 0x00 29. " STS ,Serial Transceiver Select - Read Only Serial Transceiver Select 1 Serial Interface Engine is selected 0 Parallel Interface signals is selected Serial Interface Engine can be used in combination with UTMI+/ULPI physical interface to provide FS/LS signaling instead of the parallel interface signals." "0,1"
        textline "            "
        hexmask.long.byte 0x00 30.--32. 1. " PTS_1 ,Bit field {bit25, bit31, bit30}: ""000b"" UTMI/UTMI+ ""001b"" Reserved ""010b"" ULPI ""011b"" Serial/USB 1.1 PHY/IC-USB (FS Only) ""100b"" HSIC All USB port interface modes are listed in this field description, but not all are supported."
width 11.
group.long 0x3a4++0x3
    line.long 0x00 "UOG2_OTGSC,On-The-Go Status & control"
        bitfld.long 0x00 0. " VD ,VBUS_Discharge - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 1. " VC ,VBUS Charge - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 3. " OT ,OTG Termination - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 4. " DP ,Data Pulsing - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 5. " IDPU ,ID Pullup - Read/Write This bit provide control over the ID pull-up resister; 0 = off, 1 = on [default]." "0,1"
        textline "          "
        bitfld.long 0x00 8. " ID ,USB ID - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 9. " AVV ,A VBus Valid - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 10. " ASV ,A Session Valid - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 11. " BSV ,B Session Valid - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 12. " BSE ,B Session End - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 13. " _1MST ,1 millisecond timer toggle - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 14. " DPS ,Data Bus Pulsing Status - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 16. " IDIS ,USB ID Interrupt Status - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 17. " AVVIS ,A VBus Valid Interrupt Status - Read/Write to Clear." "0,1"
        textline "          "
        bitfld.long 0x00 18. " ASVIS ,A Session Valid Interrupt Status - Read/Write to Clear." "0,1"
        textline "          "
        bitfld.long 0x00 19. " BSVIS ,B Session Valid Interrupt Status - Read/Write to Clear." "0,1"
        textline "          "
        bitfld.long 0x00 20. " BSEIS ,B Session End Interrupt Status - Read/Write to Clear." "0,1"
        textline "          "
        bitfld.long 0x00 21. " _1MSS ,1 millisecond timer Interrupt Status - Read/Write to Clear." "0,1"
        textline "          "
        bitfld.long 0x00 22. " DPIS ,Data Pulse Interrupt Status - Read/Write to Clear." "0,1"
        textline "          "
        bitfld.long 0x00 24. " IDIE ,USB ID Interrupt Enable - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 25. " AVVIE ,A VBus Valid Interrupt Enable - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 26. " ASVIE ,A Session Valid Interrupt Enable - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 27. " BSVIE ,B Session Valid Interrupt Enable - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 28. " BSEIE ,B Session End Interrupt Enable - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 29. " _1MSE ,1 millisecond timer Interrupt Enable - Read/Write" "0,1"
        textline "          "
        bitfld.long 0x00 30. " DPIE ,Data Pulse Interrupt Enable" "0,1"
width 13.
group.long 0x3a8++0x3
    line.long 0x00 "UOG2_USBMODE,USB Device Mode"
        hexmask.long.byte 0x00 0.--2. 1. " CM ,Controller Mode - R/WO."
        textline "            "
        bitfld.long 0x00 2. " ES ,Endian Select - Read/Write." "0,1"
        textline "            "
        bitfld.long 0x00 3. " SLOM ,Setup Lockout Mode." "0,1"
        textline "            "
        bitfld.long 0x00 4. " SDIS ,Stream Disable Mode." "0,1"
width 20.
group.long 0x3ac++0x3
    line.long 0x00 "UOG2_ENDPTSETUPSTAT,Endpoint Setup Status"
        hexmask.long.word 0x00 0.--16. 1. " ENDPTSETUPSTAT ,Setup Endpoint Status."
width 16.
group.long 0x3b0++0x3
    line.long 0x00 "UOG2_ENDPTPRIME,Endpoint Prime"
        hexmask.long.byte 0x00 0.--8. 1. " PERB ,Prime Endpoint Receive Buffer - R/WS."
        textline "               "
        hexmask.long.byte 0x00 16.--24. 1. " PETB ,Prime Endpoint Transmit Buffer - R/WS."
width 16.
group.long 0x3b4++0x3
    line.long 0x00 "UOG2_ENDPTFLUSH,Endpoint Flush"
        hexmask.long.byte 0x00 0.--8. 1. " FERB ,Flush Endpoint Receive Buffer - R/WS."
        textline "               "
        hexmask.long.byte 0x00 16.--24. 1. " FETB ,Flush Endpoint Transmit Buffer - R/WS."
width 15.
rgroup.long 0x3b8++0x3
    line.long 0x00 "UOG2_ENDPTSTAT,Endpoint Status"
        hexmask.long.byte 0x00 0.--8. 1. " ERBR ,Endpoint Receive Buffer Ready -- Read Only."
        textline "              "
        hexmask.long.byte 0x00 16.--24. 1. " ETBR ,Endpoint Transmit Buffer Ready -- Read Only."
width 19.
group.long 0x3bc++0x3
    line.long 0x00 "UOG2_ENDPTCOMPLETE,Endpoint Complete"
        hexmask.long.byte 0x00 0.--8. 1. " ERCE ,Endpoint Receive Complete Event - RW/C."
        textline "                  "
        hexmask.long.byte 0x00 16.--24. 1. " ETCE ,Endpoint Transmit Complete Event - R/WC."
width 16.
group.long 0x3c0++0x3
    line.long 0x00 "UOG2_ENDPTCTRL0,Endpoint Control0"
        bitfld.long 0x00 0. " RXS ,RX Endpoint Stall - Read/Write 0 End Point OK." "0,1"
        textline "               "
        hexmask.long.byte 0x00 2.--4. 1. " RXT ,RX Endpoint Type - Read/Write 00 Control Endpoint0 is fixed as a Control End Point."
        textline "               "
        bitfld.long 0x00 7. " RXE ,RX Endpoint Enable 1 Enabled Endpoint0 is always enabled." "0,1"
        textline "               "
        bitfld.long 0x00 16. " TXS ,TX Endpoint Stall - Read/Write 0 End Point OK [Default] 1 End Point Stalled Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host." "0,1"
        textline "               "
        hexmask.long.byte 0x00 18.--20. 1. " TXT ,TX Endpoint Type - Read/Write 00 - Control Endpoint0 is fixed as a Control End Point."
        textline "               "
        bitfld.long 0x00 23. " TXE ,TX Endpoint Enable 1 Enabled Endpoint0 is always enabled." "0,1"
width 16.
group.long 0x3c4++0x3
    line.long 0x00 "UOG2_ENDPTCTRL1,Endpoint Control 1"
        bitfld.long 0x00 0. " RXS ,RX Endpoint Stall - Read/Write 0 End Point OK." "0,1"
        textline "               "
        bitfld.long 0x00 1. " RXD ,RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA Engine [Default] Should always be written as zero." "0,1"
        textline "               "
        hexmask.long.byte 0x00 2.--4. 1. " RXT ,RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Reserved"
        textline "               "
        bitfld.long 0x00 5. " RXI ,RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only used for test and should always be written as zero." "0,1"
        textline "               "
        bitfld.long 0x00 6. " RXR ,RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device." "0,1"
        textline "               "
        bitfld.long 0x00 7. " RXE ,RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
        textline "               "
        bitfld.long 0x00 16. " TXS ,TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This bit is set automatically upon receipt of a SETUP request if this Endpoint is not configured as a Control Endpoint." "0,1"
        textline "               "
        bitfld.long 0x00 17. " TXD ,TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Engine [DEFAULT] Should always be written as 0." "0,1"
        textline "               "
        hexmask.long.byte 0x00 18.--20. 1. " TXT ,TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt"
        textline "               "
        bitfld.long 0x00 21. " TXI ,TX Data Toggle Inhibit 0 PID Sequencing Enabled." "0,1"
        textline "               "
        bitfld.long 0x00 22. " TXR ,TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the Host and device." "0,1"
        textline "               "
        bitfld.long 0x00 23. " TXE ,TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
width 16.
group.long 0x3c8++0x3
    line.long 0x00 "UOG2_ENDPTCTRL2,Endpoint Control 2"
        bitfld.long 0x00 0. " RXS ,RX Endpoint Stall - Read/Write 0 End Point OK." "0,1"
        textline "               "
        bitfld.long 0x00 1. " RXD ,RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA Engine [Default] Should always be written as zero." "0,1"
        textline "               "
        hexmask.long.byte 0x00 2.--4. 1. " RXT ,RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Reserved"
        textline "               "
        bitfld.long 0x00 5. " RXI ,RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only used for test and should always be written as zero." "0,1"
        textline "               "
        bitfld.long 0x00 6. " RXR ,RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device." "0,1"
        textline "               "
        bitfld.long 0x00 7. " RXE ,RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
        textline "               "
        bitfld.long 0x00 16. " TXS ,TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This bit is set automatically upon receipt of a SETUP request if this Endpoint is not configured as a Control Endpoint." "0,1"
        textline "               "
        bitfld.long 0x00 17. " TXD ,TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Engine [DEFAULT] Should always be written as 0." "0,1"
        textline "               "
        hexmask.long.byte 0x00 18.--20. 1. " TXT ,TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt"
        textline "               "
        bitfld.long 0x00 21. " TXI ,TX Data Toggle Inhibit 0 PID Sequencing Enabled." "0,1"
        textline "               "
        bitfld.long 0x00 22. " TXR ,TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the Host and device." "0,1"
        textline "               "
        bitfld.long 0x00 23. " TXE ,TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
width 16.
group.long 0x3cc++0x3
    line.long 0x00 "UOG2_ENDPTCTRL3,Endpoint Control 3"
        bitfld.long 0x00 0. " RXS ,RX Endpoint Stall - Read/Write 0 End Point OK." "0,1"
        textline "               "
        bitfld.long 0x00 1. " RXD ,RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA Engine [Default] Should always be written as zero." "0,1"
        textline "               "
        hexmask.long.byte 0x00 2.--4. 1. " RXT ,RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Reserved"
        textline "               "
        bitfld.long 0x00 5. " RXI ,RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only used for test and should always be written as zero." "0,1"
        textline "               "
        bitfld.long 0x00 6. " RXR ,RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device." "0,1"
        textline "               "
        bitfld.long 0x00 7. " RXE ,RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
        textline "               "
        bitfld.long 0x00 16. " TXS ,TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This bit is set automatically upon receipt of a SETUP request if this Endpoint is not configured as a Control Endpoint." "0,1"
        textline "               "
        bitfld.long 0x00 17. " TXD ,TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Engine [DEFAULT] Should always be written as 0." "0,1"
        textline "               "
        hexmask.long.byte 0x00 18.--20. 1. " TXT ,TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt"
        textline "               "
        bitfld.long 0x00 21. " TXI ,TX Data Toggle Inhibit 0 PID Sequencing Enabled." "0,1"
        textline "               "
        bitfld.long 0x00 22. " TXR ,TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the Host and device." "0,1"
        textline "               "
        bitfld.long 0x00 23. " TXE ,TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
width 16.
group.long 0x3d0++0x3
    line.long 0x00 "UOG2_ENDPTCTRL4,Endpoint Control 4"
        bitfld.long 0x00 0. " RXS ,RX Endpoint Stall - Read/Write 0 End Point OK." "0,1"
        textline "               "
        bitfld.long 0x00 1. " RXD ,RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA Engine [Default] Should always be written as zero." "0,1"
        textline "               "
        hexmask.long.byte 0x00 2.--4. 1. " RXT ,RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Reserved"
        textline "               "
        bitfld.long 0x00 5. " RXI ,RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only used for test and should always be written as zero." "0,1"
        textline "               "
        bitfld.long 0x00 6. " RXR ,RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device." "0,1"
        textline "               "
        bitfld.long 0x00 7. " RXE ,RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
        textline "               "
        bitfld.long 0x00 16. " TXS ,TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This bit is set automatically upon receipt of a SETUP request if this Endpoint is not configured as a Control Endpoint." "0,1"
        textline "               "
        bitfld.long 0x00 17. " TXD ,TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Engine [DEFAULT] Should always be written as 0." "0,1"
        textline "               "
        hexmask.long.byte 0x00 18.--20. 1. " TXT ,TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt"
        textline "               "
        bitfld.long 0x00 21. " TXI ,TX Data Toggle Inhibit 0 PID Sequencing Enabled." "0,1"
        textline "               "
        bitfld.long 0x00 22. " TXR ,TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the Host and device." "0,1"
        textline "               "
        bitfld.long 0x00 23. " TXE ,TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
width 16.
group.long 0x3d4++0x3
    line.long 0x00 "UOG2_ENDPTCTRL5,Endpoint Control 5"
        bitfld.long 0x00 0. " RXS ,RX Endpoint Stall - Read/Write 0 End Point OK." "0,1"
        textline "               "
        bitfld.long 0x00 1. " RXD ,RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA Engine [Default] Should always be written as zero." "0,1"
        textline "               "
        hexmask.long.byte 0x00 2.--4. 1. " RXT ,RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Reserved"
        textline "               "
        bitfld.long 0x00 5. " RXI ,RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only used for test and should always be written as zero." "0,1"
        textline "               "
        bitfld.long 0x00 6. " RXR ,RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device." "0,1"
        textline "               "
        bitfld.long 0x00 7. " RXE ,RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
        textline "               "
        bitfld.long 0x00 16. " TXS ,TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This bit is set automatically upon receipt of a SETUP request if this Endpoint is not configured as a Control Endpoint." "0,1"
        textline "               "
        bitfld.long 0x00 17. " TXD ,TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Engine [DEFAULT] Should always be written as 0." "0,1"
        textline "               "
        hexmask.long.byte 0x00 18.--20. 1. " TXT ,TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt"
        textline "               "
        bitfld.long 0x00 21. " TXI ,TX Data Toggle Inhibit 0 PID Sequencing Enabled." "0,1"
        textline "               "
        bitfld.long 0x00 22. " TXR ,TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the Host and device." "0,1"
        textline "               "
        bitfld.long 0x00 23. " TXE ,TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
width 16.
group.long 0x3d8++0x3
    line.long 0x00 "UOG2_ENDPTCTRL6,Endpoint Control 6"
        bitfld.long 0x00 0. " RXS ,RX Endpoint Stall - Read/Write 0 End Point OK." "0,1"
        textline "               "
        bitfld.long 0x00 1. " RXD ,RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA Engine [Default] Should always be written as zero." "0,1"
        textline "               "
        hexmask.long.byte 0x00 2.--4. 1. " RXT ,RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Reserved"
        textline "               "
        bitfld.long 0x00 5. " RXI ,RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only used for test and should always be written as zero." "0,1"
        textline "               "
        bitfld.long 0x00 6. " RXR ,RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device." "0,1"
        textline "               "
        bitfld.long 0x00 7. " RXE ,RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
        textline "               "
        bitfld.long 0x00 16. " TXS ,TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This bit is set automatically upon receipt of a SETUP request if this Endpoint is not configured as a Control Endpoint." "0,1"
        textline "               "
        bitfld.long 0x00 17. " TXD ,TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Engine [DEFAULT] Should always be written as 0." "0,1"
        textline "               "
        hexmask.long.byte 0x00 18.--20. 1. " TXT ,TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt"
        textline "               "
        bitfld.long 0x00 21. " TXI ,TX Data Toggle Inhibit 0 PID Sequencing Enabled." "0,1"
        textline "               "
        bitfld.long 0x00 22. " TXR ,TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the Host and device." "0,1"
        textline "               "
        bitfld.long 0x00 23. " TXE ,TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
width 16.
group.long 0x3dc++0x3
    line.long 0x00 "UOG2_ENDPTCTRL7,Endpoint Control 7"
        bitfld.long 0x00 0. " RXS ,RX Endpoint Stall - Read/Write 0 End Point OK." "0,1"
        textline "               "
        bitfld.long 0x00 1. " RXD ,RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA Engine [Default] Should always be written as zero." "0,1"
        textline "               "
        hexmask.long.byte 0x00 2.--4. 1. " RXT ,RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Reserved"
        textline "               "
        bitfld.long 0x00 5. " RXI ,RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only used for test and should always be written as zero." "0,1"
        textline "               "
        bitfld.long 0x00 6. " RXR ,RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device." "0,1"
        textline "               "
        bitfld.long 0x00 7. " RXE ,RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
        textline "               "
        bitfld.long 0x00 16. " TXS ,TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This bit is set automatically upon receipt of a SETUP request if this Endpoint is not configured as a Control Endpoint." "0,1"
        textline "               "
        bitfld.long 0x00 17. " TXD ,TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Engine [DEFAULT] Should always be written as 0." "0,1"
        textline "               "
        hexmask.long.byte 0x00 18.--20. 1. " TXT ,TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt"
        textline "               "
        bitfld.long 0x00 21. " TXI ,TX Data Toggle Inhibit 0 PID Sequencing Enabled." "0,1"
        textline "               "
        bitfld.long 0x00 22. " TXR ,TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the Host and device." "0,1"
        textline "               "
        bitfld.long 0x00 23. " TXE ,TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
width 7.
rgroup.long 0x400++0x3
    line.long 0x00 "UH1_ID,Identification register"
        hexmask.long.byte 0x00 0.--6. 1. " ID ,Configuration number."
        textline "      "
        hexmask.long.byte 0x00 8.--14. 1. " NID ,Complement version of ID"
        textline "      "
        hexmask.long.byte 0x00 16.--24. 1. " REVISION ,Revision number of the controller core."
width 14.
rgroup.long 0x404++0x3
    line.long 0x00 "UH1_HWGENERAL,Hardware General"
        hexmask.long.byte 0x00 4.--6. 1. " PHYW ,Data width of the transciever connected to the controller core."
        textline "             "
        hexmask.long.byte 0x00 6.--9. 1. " PHYM ,Transciever type PHYM bit reset value: '0000b' for OTG controller core, '0100b' for Host-only controller core."
        textline "             "
        hexmask.long.byte 0x00 9.--11. 1. " SM ,Serial interface mode capability SM bit reset value is '00b'"
width 11.
rgroup.long 0x408++0x3
    line.long 0x00 "UH1_HWHOST,Host Hardware Parameters"
        bitfld.long 0x00 0. " HC ,Host Capable." "0,1"
        textline "          "
        hexmask.long.byte 0x00 1.--4. 1. " NPORT ,The Nmber of downstream ports supported by the host controller is (NPORT+1)."
width 12.
rgroup.long 0x410++0x3
    line.long 0x00 "UH1_HWTXBUF,TX Buffer Hardware Parameters"
        hexmask.long.byte 0x00 0.--8. 1. " TXBURST ,Default burst size for memory to TX buffer transfer."
        textline "           "
        hexmask.long.byte 0x00 16.--24. 1. " TXCHANADD ,TX FIFO Buffer size is: (2^TXCHANADD) * 4 Bytes."
width 12.
rgroup.long 0x414++0x3
    line.long 0x00 "UH1_HWRXBUF,RX Buffer Hardware Parameters"
        hexmask.long.byte 0x00 0.--8. 1. " RXBURST ,Default burst size for memory to RX buffer transfer."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " RXADD ,Buffer total size for all receive endpoints is (2^RXADD)."
width 15.
group.long 0x480++0x3
    line.long 0x00 "UH1_GPTIMER0LD,General Purpose Timer #0 Load"
        hexmask.long.long 0x00 0.--24. 1. " GPTLD ,General Purpose Timer Load Value These bit fields are loaded to GPTCNT bits when GPTRST bit is set '1b'."
width 17.
group.long 0x484++0x3
    line.long 0x00 "UH1_GPTIMER0CTRL,General Purpose Timer #0 Controller"
        hexmask.long.long 0x00 0.--24. 1. " GPTCNT ,General Purpose Timer Counter."
        textline "                "
        bitfld.long 0x00 24. " GPTMODE ,General Purpose Timer Mode In one shot mode, the timer will count down to zero, generate an interrupt, and stop until the counter is reset by software; In repeat mode, the timer will count down to zero, generate an interrupt and automatically reload the counter value from GPTLD bits to start again." "0,1"
        textline "                "
        bitfld.long 0x00 30. " GPTRST ,General Purpose Timer Reset" "0,1"
        textline "                "
        bitfld.long 0x00 31. " GPTRUN ,General Purpose Timer Run GPTCNT bits are not effected when setting or clearing this bit." "0,1"
width 15.
group.long 0x488++0x3
    line.long 0x00 "UH1_GPTIMER1LD,General Purpose Timer #1 Load"
        hexmask.long.long 0x00 0.--24. 1. " GPTLD ,General Purpose Timer Load Value These bit fields are loaded to GPTCNT bits when GPTRST bit is set '1b'."
width 17.
group.long 0x48c++0x3
    line.long 0x00 "UH1_GPTIMER1CTRL,General Purpose Timer #1 Controller"
        hexmask.long.long 0x00 0.--24. 1. " GPTCNT ,General Purpose Timer Counter."
        textline "                "
        bitfld.long 0x00 24. " GPTMODE ,General Purpose Timer Mode In one shot mode, the timer will count down to zero, generate an interrupt, and stop until the counter is reset by software." "0,1"
        textline "                "
        bitfld.long 0x00 30. " GPTRST ,General Purpose Timer Reset" "0,1"
        textline "                "
        bitfld.long 0x00 31. " GPTRUN ,General Purpose Timer Run GPTCNT bits are not effected when setting or clearing this bit." "0,1"
width 12.
group.long 0x490++0x3
    line.long 0x00 "UH1_SBUSCFG,System Bus Config"
        hexmask.long.byte 0x00 0.--3. 1. " AHBBRST ,AHB master interface Burst configuration These bits control AHB master transfer type sequence (or priority)."
width 14.
rgroup.byte 0x500++0x0
    line.byte 0x00 "UH1_CAPLENGTH,Capability Registers Length"
        hexmask.byte.byte 0x00 0.--8. 1. " CAPLENGTH ,These bits are used as an offset to add to register base to find the beginning of the Operational Register."
width 15.
rgroup.word 0x502++0x1
    line.word 0x00 "UH1_HCIVERSION,Host Controller Interface Version"
        hexmask.word.word 0x00 0.--16. 1. " HCIVERSION ,Host Controller Interface Version Number Default value is '10h', which means EHCI rev1.0."
width 14.
rgroup.long 0x504++0x3
    line.long 0x00 "UH1_HCSPARAMS,Host Controller Structural Parameters"
        hexmask.long.byte 0x00 0.--4. 1. " N_PORTS ,Number of downstream ports."
        textline "             "
        bitfld.long 0x00 4. " PPC ,Port Power Control This field indicates whether the host controller implementation includes port power control." "0,1"
        textline "             "
        hexmask.long.byte 0x00 8.--12. 1. " N_PCC ,Number of Ports per Companion Controller This field indicates the number of ports supported per internal Companion Controller."
        textline "             "
        hexmask.long.byte 0x00 12.--16. 1. " N_CC ,Number of Companion Controller (N_CC)."
        textline "             "
        bitfld.long 0x00 16. " PI ,Port Indicators (P INDICATOR) This bit indicates whether the ports support port indicator control." "0,1"
        textline "             "
        hexmask.long.byte 0x00 20.--24. 1. " N_PTT ,Number of Ports per Transaction Translator (N_PTT)."
        textline "             "
        hexmask.long.byte 0x00 24.--28. 1. " N_TT ,Number of Transaction Translators (N_TT)."
width 14.
rgroup.long 0x508++0x3
    line.long 0x00 "UH1_HCCPARAMS,Host Controller Capability Parameters"
        bitfld.long 0x00 0. " ADC ,64-bit Addressing Capability This bit is set '0b' in all controller core, no 64-bit addressing capability is supported." "0,1"
        textline "             "
        bitfld.long 0x00 1. " PFL ,Programmable Frame List Flag If this bit is set to zero, then the system software must use a frame list length of 1024 elements with this host controller." "0,1"
        textline "             "
        bitfld.long 0x00 2. " ASP ,Asynchronous Schedule Park Capability If this bit is set to a one, then the host controller supports the park feature for high-speed queue heads in the Asynchronous Schedule." "0,1"
        textline "             "
        hexmask.long.byte 0x00 4.--8. 1. " IST ,Isochronous Scheduling Threshold."
        textline "             "
        hexmask.long.byte 0x00 8.--16. 1. " EECP ,EHCI Extended Capabilities Pointer."
width 11.
group.long 0x540++0x3
    line.long 0x00 "UH1_USBCMD,USB Command Register"
        bitfld.long 0x00 0. " RS ,Run/Stop (RS) - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 1. " RST ,Controller Reset (RESET) - Read/Write." "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--4. 1. " FS_1 ,See description at bit 15"
        textline "          "
        bitfld.long 0x00 4. " PSE ,Periodic Schedule Enable- Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 5. " ASE ,Asynchronous Schedule Enable - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 6. " IAA ,Interrupt on Async Advance Doorbell - Read/Write." "0,1"
        textline "          "
        hexmask.long.byte 0x00 8.--10. 1. " ASP ,Asynchronous Schedule Park Mode Count - Read/Write."
        textline "          "
        bitfld.long 0x00 11. " ASPE ,Asynchronous Schedule Park Mode Enable - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 13. " SUTW ,Setup TripWire - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 14. " ATDTW ,Add dTD TripWire - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 15. " FS_2 ,See also bits 3-2 Frame List Size - (Read/Write or Read Only)." "0,1"
        textline "          "
        hexmask.long.byte 0x00 16.--24. 1. " ITC ,Interrupt Threshold Control -Read/Write."
width 11.
group.long 0x544++0x3
    line.long 0x00 "UH1_USBSTS,USB Status Register"
        bitfld.long 0x00 0. " UI ,USB Interrupt (USBINT) - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 1. " UEI ,USB Error Interrupt (USBERRINT) - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 2. " PCI ,Port Change Detect - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 3. " FRI ,Frame List Rollover - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 4. " SEI ,System Error- R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 5. " AAI ,Interrupt on Async Advance - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 6. " URI ,USB Reset Received - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 7. " SRI ,SOF Received - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 8. " SLI ,DCSuspend - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 10. " ULPII ,ULPI Interrupt - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 12. " HCH ,HCHaIted - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 13. " RCL ,Reclamation - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 14. " PS ,Periodic Schedule Status - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 15. " AS ,Asynchronous Schedule Status - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 16. " NAKI ,NAK Interrupt Bit--RO." "0,1"
        textline "          "
        bitfld.long 0x00 24. " TI0 ,General Purpose Timer Interrupt 0(GPTINT0)--R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 25. " TI1 ,General Purpose Timer Interrupt 1(GPTINT1)--R/WC." "0,1"
width 12.
group.long 0x548++0x3
    line.long 0x00 "UH1_USBINTR,Interrupt Enable Register"
        bitfld.long 0x00 0. " UE ,USB Interrupt Enalbe When this bit is one and the UI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 1. " UEE ,USB Error Interrupt Enable When this bit is one and the UEI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 2. " PCE ,Port Change Detect Interrupt Enable When this bit is one and the PCI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 3. " FRE ,Frame List Rollover Interrupt Enable When this bit is one and the FRI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 4. " SEE ,System Error Interrupt Enable When this bit is one and the SEI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 5. " AAE ,Async Advance Interrupt Enable When this bit is one and the AAI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 6. " URE ,USB Reset Interrupt Enable When this bit is one and the URI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 7. " SRE ,SOF Received Interrupt Enable When this bit is one and the SRI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 8. " SLE ,Sleep Interrupt Enable When this bit is one and the SLI bit in n_n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 10. " ULPIE ,ULPI Interrupt Enable When this bit is one and the UPLII bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 16. " NAKE ,NAK Interrupt Enable When this bit is one and the NAKI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 18. " UAIE ,USB Host Asynchronous Interrupt Enable When this bit is one, and the UAI bit in the n_USBSTS register is one, host controller will issue an interrupt at the next interrupt threshold." "0,1"
        textline "           "
        bitfld.long 0x00 19. " UPIE ,USB Host Periodic Interrupt Enable When this bit is one, and the UPI bit in the n_USBSTS register is one, host controller will issue an interrupt at the next interrupt threshold." "0,1"
        textline "           "
        bitfld.long 0x00 24. " TIE0 ,General Purpose Timer #0 Interrupt Enable When this bit is one and the TI0 bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 25. " TIE1 ,General Purpose Timer #1 Interrupt Enable When this bit is one and the TI1 bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
width 12.
group.long 0x54c++0x3
    line.long 0x00 "UH1_FRINDEX,USB Frame Index"
        hexmask.long.word 0x00 0.--14. 1. " FRINDEX ,Frame Index."
width 21.
group.long 0x554++0x3
    line.long 0x00 "UH1_PERIODICLISTBASE,Frame List Base Address"
        hexmask.long.long 0x00 12.--32. 1. " BASEADR ,Base Address (Low)."
width 18.
group.long 0x558++0x3
    line.long 0x00 "UH1_ASYNCLISTADDR,Next Asynch. Address"
        hexmask.long.long 0x00 5.--32. 1. " ASYBASE ,Link Pointer Low (LPL)."
width 14.
group.long 0x560++0x3
    line.long 0x00 "UH1_BURSTSIZE,Programmable Burst Size"
        hexmask.long.byte 0x00 0.--8. 1. " RXPBURST ,Programmable RX Burst Size."
        textline "             "
        hexmask.long.word 0x00 8.--17. 1. " TXPBURST ,Programmable TX Burst Size."
width 17.
group.long 0x564++0x3
    line.long 0x00 "UH1_TXFILLTUNING,TX FIFO Fill Tuning"
        hexmask.long.byte 0x00 0.--8. 1. " TXSCHOH ,Scheduler Overhead."
        textline "                "
        hexmask.long.byte 0x00 8.--13. 1. " TXSCHHEALTH ,Scheduler Health Counter."
        textline "                "
        hexmask.long.byte 0x00 16.--22. 1. " TXFIFOTHRES ,FIFO Burst Threshold."
width 15.
group.long 0x580++0x3
    line.long 0x00 "UH1_CONFIGFLAG,Configure Flag Register"
        bitfld.long 0x00 0. " CF ,Configure Flag Host software sets this bit as the last action in its process of configuring the Host Controller." "0,1"
width 12.
group.long 0x584++0x3
    line.long 0x00 "UH1_PORTSC1,Port Status & Control"
        bitfld.long 0x00 0. " CCS ,Current Connect Status-Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 1. " CSC ,Connect Status Change-R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 2. " PE ,Port Enabled/Disabled-Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 3. " PEC ,Port Enable/Disable Change-R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 4. " OCA ,Over-current Active-Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 5. " OCC ,Over-current Change-R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 6. " FPR ,Force Port Resume -Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 7. " SUSP ,Suspend - Read/Write or Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 8. " PR ,Port Reset - Read/Write or Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 9. " HSP ,High-Speed Port - Read Only." "0,1"
        textline "           "
        hexmask.long.byte 0x00 10.--12. 1. " LS ,Line Status-Read Only."
        textline "           "
        bitfld.long 0x00 12. " PP ,Port Power (PP)-Read/Write or Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 13. " PO ,Port Owner-Read/Write." "0,1"
        textline "           "
        hexmask.long.byte 0x00 14.--16. 1. " PIC ,Port Indicator Control - Read/Write."
        textline "           "
        hexmask.long.byte 0x00 16.--20. 1. " PTC ,Port Test Control - Read/Write."
        textline "           "
        bitfld.long 0x00 20. " WKCN ,Wake on Connect Enable (WKCNNT_E) - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 21. " WKDC ,Wake on Disconnect Enable (WKDSCNNT_E) - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 22. " WKOC ,Wake on Over-current Enable (WKOC_E) - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 23. " PHCD ,PHY Low Power Suspend - Clock Disable (PLPSCD) - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 24. " PFSC ,Port Force Full Speed Connect - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 25. " PTS_2 ,See description at bits 31-30" "0,1"
        textline "           "
        hexmask.long.byte 0x00 26.--28. 1. " PSPD ,Port Speed - Read Only."
        textline "           "
        bitfld.long 0x00 28. " PTW ,Parallel Transceiver Width This bit has no effect if serial interface engine is used." "0,1"
        textline "           "
        bitfld.long 0x00 29. " STS ,Serial Transceiver Select - Read Only Serial Transceiver Select 1 Serial Interface Engine is selected 0 Parallel Interface signals is selected Serial Interface Engine can be used in combination with UTMI+/ULPI physical interface to provide FS/LS signaling instead of the parallel interface signals." "0,1"
        textline "           "
        hexmask.long.byte 0x00 30.--32. 1. " PTS_1 ,Bit field {bit25, bit31, bit30}: ""000b"" UTMI/UTMI+ ""001b"" Reserved ""010b"" ULPI ""011b"" Serial/USB 1.1 PHY/IC-USB (FS Only) ""100b"" HSIC All USB port interface modes are listed in this field description, but not all are supported."
width 12.
group.long 0x5a8++0x3
    line.long 0x00 "UH1_USBMODE,USB Device Mode"
        hexmask.long.byte 0x00 0.--2. 1. " CM ,Controller Mode - R/WO."
        textline "           "
        bitfld.long 0x00 2. " ES ,Endian Select - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 3. " SLOM ,Setup Lockout Mode." "0,1"
        textline "           "
        bitfld.long 0x00 4. " SDIS ,Stream Disable Mode." "0,1"


tree.end



;--------------------------------------------------------------------------------
; USBNC
;--------------------------------------------------------------------------------
tree "USBNC"
    base ad:0x02184000

width 14.
group.long 0x800++0x3
    line.long 0x00 "USB_OTG1_CTRL,USB OTG1 Control Register"
        bitfld.long 0x00 7. " OVER_CUR_DIS ,Disable OTG1 Overcurrent Detection" "0,1"
        textline "             "
        bitfld.long 0x00 8. " OVER_CUR_POL ,OTG1 Polarity of Overcurrent The polarity of OTG1 port overcurrent event" "0,1"
        textline "             "
        bitfld.long 0x00 9. " PWR_POL ,OTG1 Power Polarity This bit should be set according to PMIC Power Pin polarity." "0,1"
        textline "             "
        bitfld.long 0x00 10. " WIE ,OTG1 Wake-up Interrupt Enable This bit enables or disables the OTG1 wake-up interrupt." "0,1"
        textline "             "
        bitfld.long 0x00 14. " WKUP_SW_EN ,OTG1 Software Wake-up Enable" "0,1"
        textline "             "
        bitfld.long 0x00 15. " WKUP_SW ,OTG1 Software Wake-up" "0,1"
        textline "             "
        bitfld.long 0x00 16. " WKUP_ID_EN ,OTG1 Wake-up on ID change enable" "0,1"
        textline "             "
        bitfld.long 0x00 17. " WKUP_VBUS_EN ,OTG1 wake-up on VBUS change enable" "0,1"
        textline "             "
        bitfld.long 0x00 31. " WIR ,OTG1 Wake-up Interrupt Request This bit indicates that a wake-up interrupt request is received on the OTG1 port." "0,1"
width 14.
group.long 0x804++0x3
    line.long 0x00 "USB_OTG2_CTRL,USB OTG2 Control Register"
        bitfld.long 0x00 7. " OVER_CUR_DIS ,Disable OTG2 Overcurrent Detection" "0,1"
        textline "             "
        bitfld.long 0x00 8. " OVER_CUR_POL ,OTG2 Polarity of Overcurrent The polarity of OTG2 port overcurrent event" "0,1"
        textline "             "
        bitfld.long 0x00 9. " PWR_POL ,OTG2 Power Polarity This bit should be set according to PMIC Power Pin polarity." "0,1"
        textline "             "
        bitfld.long 0x00 10. " WIE ,OTG2 Wake-up Interrupt Enable This bit enables or disables the OTG2 wake-up interrupt." "0,1"
        textline "             "
        bitfld.long 0x00 14. " WKUP_SW_EN ,OTG2 Software Wake-up Enable" "0,1"
        textline "             "
        bitfld.long 0x00 15. " WKUP_SW ,OTG2 Software Wake-up" "0,1"
        textline "             "
        bitfld.long 0x00 16. " WKUP_ID_EN ,OTG2 Wake-up on ID change enable" "0,1"
        textline "             "
        bitfld.long 0x00 17. " WKUP_VBUS_EN ,OTG2 wake-up on VBUS change enable" "0,1"
        textline "             "
        bitfld.long 0x00 31. " WIR ,OTG2 Wake-up Interrupt Request This bit indicates that a wake-up interrupt request is received on the OTG port." "0,1"
width 12.
group.long 0x808++0x3
    line.long 0x00 "USB_UH_CTRL,USB Host Control Register"
        bitfld.long 0x00 10. " WIE ,Host Wake-up Interrupt Enable This bit enables or disables the Host wake-up interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 11. " RESET ,Force Host UTMI PHY Reset This bit is used to force a reset to the UTMI PHY." "0,1"
        textline "           "
        bitfld.long 0x00 12. " SUSPENDM ,Force Host UTMI PHY Suspend This bit is used to put PHY into suspend mode." "0,1"
        textline "           "
        bitfld.long 0x00 13. " _480M_CLK_ON ,Force OTG UTMI PHY 480M clock output on when Host is not in suspend mode." "0,1"
        textline "           "
        bitfld.long 0x00 14. " WKUP_SW_EN ,Host Software Wake-up Enable" "0,1"
        textline "           "
        bitfld.long 0x00 15. " WKUP_SW ,Host Software Wake-up" "0,1"
        textline "           "
        bitfld.long 0x00 31. " WIR ,Host Wake-up Interrupt Request This bit indicates that a wake-up interrupt request is received on the Host port." "0,1"
width 17.
group.long 0x810++0x3
    line.long 0x00 "USB_UH_HSIC_CTRL,USB Host HSIC Control Register"
        bitfld.long 0x00 11. " HSIC_CLK_ON ,Force Host HSIC module 480M clock on, even when in Host is in suspend mode." "0,1"
        textline "                "
        bitfld.long 0x00 12. " HSIC_EN ,Host HSIC enable" "0,1"
        textline "                "
        bitfld.long 0x00 31. " CLK_VLD ,Indicating whether Host HSIC clock is valid." "0,1"
width 20.
group.long 0x818++0x3
    line.long 0x00 "USB_OTG1_PHY_CTRL_0,OTG1 UTMI PHY Control 0 Register"
        bitfld.long 0x00 31. " UTMI_CLK_VLD ,Indicating whether OTG1 UTMI PHY clock is valid" "0,1"
width 20.
group.long 0x81c++0x3
    line.long 0x00 "USB_OTG2_PHY_CTRL_0,OTG2 UTMI PHY Control 0 Register"
        bitfld.long 0x00 31. " UTMI_CLK_VLD ,Indicating whether OTG2 UTMI PHY clock is valid" "0,1"


tree.end



;--------------------------------------------------------------------------------
; USBPHY
;--------------------------------------------------------------------------------
tree.open "USBPHY"
    tree "USBPHY1"
        base ad:0x020c9000

width 4.
group.long 0x0++0x3
    line.long 0x00 "PWD,USB PHY Power-Down Register"
        bitfld.long 0x00 10. " TXPWDFS ,0 = Normal operation." "0,1"
        textline "   "
        bitfld.long 0x00 11. " TXPWDIBIAS ,0 = Normal operation." "0,1"
        textline "   "
        bitfld.long 0x00 12. " TXPWDV2I ,0 = Normal operation." "0,1"
        textline "   "
        bitfld.long 0x00 17. " RXPWDENV ,0 = Normal operation." "0,1"
        textline "   "
        bitfld.long 0x00 18. " RXPWD1PT1 ,0 = Normal operation." "0,1"
        textline "   "
        bitfld.long 0x00 19. " RXPWDDIFF ,0 = Normal operation." "0,1"
        textline "   "
        bitfld.long 0x00 20. " RXPWDRX ,0 = Normal operation." "0,1"
width 3.
group.long 0x10++0x3
    line.long 0x00 "TX,USB PHY Transmitter Control Register"
        hexmask.long.byte 0x00 0.--4. 1. " D_CAL ,Resistor Trimming Code: 0000 = 0.16% 0111 = Nominal 1111 = +25%"
        textline "  "
        hexmask.long.byte 0x00 8.--12. 1. " TXCAL45DN ,Decode to select a 45-Ohm resistance to the USB_DN output pin."
        textline "  "
        hexmask.long.byte 0x00 16.--20. 1. " TXCAL45DP ,Decode to select a 45-Ohm resistance to the USB_DP output pin."
        textline "  "
        hexmask.long.byte 0x00 26.--29. 1. " USBPHY_TX_EDGECTRL ,Controls the edge-rate of the current sensing transistors used in HS transmit."
width 3.
group.long 0x20++0x3
    line.long 0x00 "RX,USB PHY Receiver Control Register"
        hexmask.long.byte 0x00 0.--3. 1. " ENVADJ ,The ENVADJ field adjusts the trip point for the envelope detector."
        textline "  "
        hexmask.long.byte 0x00 4.--7. 1. " DISCONADJ ,The DISCONADJ field adjusts the trip point for the disconnect detector: 000 = Trip-Level Voltage is 0.57500 V 001 = Trip-Level Voltage is 0.56875 V 010 = Trip-Level Voltage is 0.58125 V 011 = Trip-Level Voltage is 0.58750 V 1XX = Reserved"
        textline "  "
        bitfld.long 0x00 22. " RXDBYPASS ,0 = Normal operation." "0,1"
width 5.
group.long 0x30++0x3
    line.long 0x00 "CTRL,USB PHY General Control Register"
        bitfld.long 0x00 0. " ENOTG_ID_CHG_IRQ ,Enable OTG_ID_CHG_IRQ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " ENHOSTDISCONDETECT ,For host mode, enables high-speed disconnect detector." "0,1"
        textline "    "
        bitfld.long 0x00 2. " ENIRQHOSTDISCON ,Enables interrupt for detection of disconnection to Device when in high-speed host mode." "0,1"
        textline "    "
        bitfld.long 0x00 3. " HOSTDISCONDETECT_IRQ ,Indicates that the device has disconnected in high-speed mode." "0,1"
        textline "    "
        bitfld.long 0x00 4. " ENDEVPLUGINDETECT ,For device mode, enables 200-KOhm pullups for detecting connectivity to the host." "0,1"
        textline "    "
        bitfld.long 0x00 5. " DEVPLUGIN_POLARITY ,For device mode, if this bit is cleared to 0, then it trips the interrupt if the device is plugged in." "0,1"
        textline "    "
        bitfld.long 0x00 6. " OTG_ID_CHG_IRQ ,OTG ID change interrupt." "0,1"
        textline "    "
        bitfld.long 0x00 7. " ENOTGIDDETECT ,Enables circuit to detect resistance of MiniAB ID pin." "0,1"
        textline "    "
        bitfld.long 0x00 8. " RESUMEIRQSTICKY ,Set to 1 will make RESUME_IRQ bit a sticky bit until software clear it." "0,1"
        textline "    "
        bitfld.long 0x00 9. " ENIRQRESUMEDETECT ,Enables interrupt for detection of a non-J state on the USB line." "0,1"
        textline "    "
        bitfld.long 0x00 10. " RESUME_IRQ ,Indicates that the host is sending a wake-up after suspend." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ENIRQDEVPLUGIN ,Enables interrupt for the detection of connectivity to the USB line." "0,1"
        textline "    "
        bitfld.long 0x00 12. " DEVPLUGIN_IRQ ,Indicates that the device is connected." "0,1"
        textline "    "
        bitfld.long 0x00 13. " DATA_ON_LRADC ,Enables the LRADC to monitor USB_DP and USB_DM." "0,1"
        textline "    "
        bitfld.long 0x00 14. " ENUTMILEVEL2 ,Enables UTMI+ Level2." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ENUTMILEVEL3 ,Enables UTMI+ Level3." "0,1"
        textline "    "
        bitfld.long 0x00 16. " ENIRQWAKEUP ,Enables interrupt for the wakeup events." "0,1"
        textline "    "
        bitfld.long 0x00 17. " WAKEUP_IRQ ,Indicates that there is a wakeup event." "0,1"
        textline "    "
        bitfld.long 0x00 19. " ENAUTOCLR_CLKGATE ,Enables the feature to auto-clear the CLKGATE bit if there is wakeup event while USB is suspended." "0,1"
        textline "    "
        bitfld.long 0x00 20. " ENAUTOCLR_PHY_PWD ,Enables the feature to auto-clear the PWD register bits in USBPHYx_PWD if there is wakeup event while USB is suspended." "0,1"
        textline "    "
        bitfld.long 0x00 21. " ENDPDMCHG_WKUP ,Enables the feature to wakeup USB if DP/DM is toggled when USB is suspended." "0,1"
        textline "    "
        bitfld.long 0x00 22. " ENIDCHG_WKUP ,Enables the feature to wakeup USB if ID is toggled when USB is suspended." "0,1"
        textline "    "
        bitfld.long 0x00 23. " ENVBUSCHG_WKUP ,Enables the feature to wakeup USB if VBUS is toggled when USB is suspended." "0,1"
        textline "    "
        bitfld.long 0x00 24. " FSDLL_RST_EN ,Enables the feature to reset the FSDLL lock detection logic at the end of each TX packet." "0,1"
        textline "    "
        bitfld.long 0x00 27. " OTG_ID_VALUE ,Almost same as OTGID_STATUS in USBPHYx_STATUS Register." "0,1"
        textline "    "
        bitfld.long 0x00 28. " HOST_FORCE_LS_SE0 ,Forces the next FS packet that is transmitted to have a EOP with LS timing." "0,1"
        textline "    "
        bitfld.long 0x00 29. " UTMI_SUSPENDM ,Used by the PHY to indicate a powered-down state." "0,1"
        textline "    "
        bitfld.long 0x00 30. " CLKGATE ,Gate UTMI Clocks." "0,1"
        textline "    "
        bitfld.long 0x00 31. " SFTRST ,Writing a 1 to this bit will soft-reset the USBPHYx_PWD, USBPHYx_TX, USBPHYx_RX, and USBPHYx_CTRL registers." "0,1"
width 7.
group.long 0x40++0x3
    line.long 0x00 "STATUS,USB PHY Status Register"
        bitfld.long 0x00 3. " HOSTDISCONDETECT_STATUS ,Indicates that the device has disconnected while in high-speed host mode." "0,1"
        textline "      "
        bitfld.long 0x00 6. " DEVPLUGIN_STATUS ,Indicates that the device has been connected on the USB_DP and USB_DM lines." "0,1"
        textline "      "
        bitfld.long 0x00 8. " OTGID_STATUS ,Indicates the results of ID pin on MiniAB plug." "0,1"
        textline "      "
        bitfld.long 0x00 10. " RESUME_STATUS ,Indicates that the host is sending a wake-up after suspend and has triggered an interrupt." "0,1"
width 6.
group.long 0x50++0x3
    line.long 0x00 "DEBUG,USB PHY Debug Register"
        bitfld.long 0x00 0. " OTGIDPIOLOCK ,Once OTG ID from USBPHYx_STATUS_OTGID_STATUS, use this to hold the value." "0,1"
        textline "     "
        bitfld.long 0x00 1. " DEBUG_INTERFACE_HOLD ,Use holding registers to assist in timing for external UTMI interface." "0,1"
        textline "     "
        hexmask.long.byte 0x00 2.--4. 1. " HSTPULLDOWN ,Set bit 3 to 1 to pull down 15-KOhm on USB_DP line."
        textline "     "
        hexmask.long.byte 0x00 4.--6. 1. " ENHSTPULLDOWN ,Set bit 5 to 1 to override the control of the USB_DP 15-KOhm pulldown."
        textline "     "
        hexmask.long.byte 0x00 8.--12. 1. " TX2RXCOUNT ,Delay in between the end of transmit to the beginning of receive."
        textline "     "
        bitfld.long 0x00 12. " ENTX2RXCOUNT ,Set this bit to allow a countdown to transition in between TX and RX." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--21. 1. " SQUELCHRESETCOUNT ,Delay in between the detection of squelch to the reset of high-speed RX."
        textline "     "
        bitfld.long 0x00 24. " ENSQUELCHRESET ,Set bit to allow squelch to reset high-speed receive." "0,1"
        textline "     "
        hexmask.long.byte 0x00 25.--29. 1. " SQUELCHRESETLENGTH ,Duration of RESET in terms of the number of 480-MHz cycles."
        textline "     "
        bitfld.long 0x00 29. " HOST_RESUME_DEBUG ,Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UTMI_SUSPEND = 1." "0,1"
        textline "     "
        bitfld.long 0x00 30. " CLKGATE ,Gate Test Clocks." "0,1"
width 14.
rgroup.long 0x60++0x3
    line.long 0x00 "DEBUG0_STATUS,UTMI Debug Status Register 0"
        hexmask.long.word 0x00 0.--16. 1. " LOOP_BACK_FAIL_COUNT ,Running count of the failed pseudo-random generator loopback."
        textline "             "
        hexmask.long.word 0x00 16.--26. 1. " UTMI_RXERROR_FAIL_COUNT ,Running count of the UTMI_RXERROR."
        textline "             "
        hexmask.long.byte 0x00 26.--32. 1. " SQUELCH_COUNT ,Running count of the squelch reset instead of normal end for HS RX."
width 7.
group.long 0x70++0x3
    line.long 0x00 "DEBUG1,UTMI Debug Status Register 1"
        hexmask.long.byte 0x00 13.--15. 1. " ENTAILADJVD ,Delay increment of the rise of squelch: 00 = Delay is nominal 01 = Delay is +20% 10 = Delay is -20% 11 = Delay is -40%"
width 8.
rgroup.long 0x80++0x3
    line.long 0x00 "VERSION,UTMI RTL Version"
        hexmask.long.word 0x00 0.--16. 1. " STEP ,Fixed read-only value reflecting the stepping of the RTL version."
        textline "       "
        hexmask.long.byte 0x00 16.--24. 1. " MINOR ,Fixed read-only value reflecting the MINOR field of the RTL version."
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " MAJOR ,Fixed read-only value reflecting the MAJOR field of the RTL version."


    tree.end
    tree "USBPHY2"
        base ad:0x020ca000

width 4.
group.long 0x0++0x3
    line.long 0x00 "PWD,USB PHY Power-Down Register"
        bitfld.long 0x00 10. " TXPWDFS ,0 = Normal operation." "0,1"
        textline "   "
        bitfld.long 0x00 11. " TXPWDIBIAS ,0 = Normal operation." "0,1"
        textline "   "
        bitfld.long 0x00 12. " TXPWDV2I ,0 = Normal operation." "0,1"
        textline "   "
        bitfld.long 0x00 17. " RXPWDENV ,0 = Normal operation." "0,1"
        textline "   "
        bitfld.long 0x00 18. " RXPWD1PT1 ,0 = Normal operation." "0,1"
        textline "   "
        bitfld.long 0x00 19. " RXPWDDIFF ,0 = Normal operation." "0,1"
        textline "   "
        bitfld.long 0x00 20. " RXPWDRX ,0 = Normal operation." "0,1"
width 3.
group.long 0x10++0x3
    line.long 0x00 "TX,USB PHY Transmitter Control Register"
        hexmask.long.byte 0x00 0.--4. 1. " D_CAL ,Resistor Trimming Code: 0000 = 0.16% 0111 = Nominal 1111 = +25%"
        textline "  "
        hexmask.long.byte 0x00 8.--12. 1. " TXCAL45DN ,Decode to select a 45-Ohm resistance to the USB_DN output pin."
        textline "  "
        hexmask.long.byte 0x00 16.--20. 1. " TXCAL45DP ,Decode to select a 45-Ohm resistance to the USB_DP output pin."
        textline "  "
        hexmask.long.byte 0x00 26.--29. 1. " USBPHY_TX_EDGECTRL ,Controls the edge-rate of the current sensing transistors used in HS transmit."
width 3.
group.long 0x20++0x3
    line.long 0x00 "RX,USB PHY Receiver Control Register"
        hexmask.long.byte 0x00 0.--3. 1. " ENVADJ ,The ENVADJ field adjusts the trip point for the envelope detector."
        textline "  "
        hexmask.long.byte 0x00 4.--7. 1. " DISCONADJ ,The DISCONADJ field adjusts the trip point for the disconnect detector: 000 = Trip-Level Voltage is 0.57500 V 001 = Trip-Level Voltage is 0.56875 V 010 = Trip-Level Voltage is 0.58125 V 011 = Trip-Level Voltage is 0.58750 V 1XX = Reserved"
        textline "  "
        bitfld.long 0x00 22. " RXDBYPASS ,0 = Normal operation." "0,1"
width 5.
group.long 0x30++0x3
    line.long 0x00 "CTRL,USB PHY General Control Register"
        bitfld.long 0x00 0. " ENOTG_ID_CHG_IRQ ,Enable OTG_ID_CHG_IRQ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " ENHOSTDISCONDETECT ,For host mode, enables high-speed disconnect detector." "0,1"
        textline "    "
        bitfld.long 0x00 2. " ENIRQHOSTDISCON ,Enables interrupt for detection of disconnection to Device when in high-speed host mode." "0,1"
        textline "    "
        bitfld.long 0x00 3. " HOSTDISCONDETECT_IRQ ,Indicates that the device has disconnected in high-speed mode." "0,1"
        textline "    "
        bitfld.long 0x00 4. " ENDEVPLUGINDETECT ,For device mode, enables 200-KOhm pullups for detecting connectivity to the host." "0,1"
        textline "    "
        bitfld.long 0x00 5. " DEVPLUGIN_POLARITY ,For device mode, if this bit is cleared to 0, then it trips the interrupt if the device is plugged in." "0,1"
        textline "    "
        bitfld.long 0x00 6. " OTG_ID_CHG_IRQ ,OTG ID change interrupt." "0,1"
        textline "    "
        bitfld.long 0x00 7. " ENOTGIDDETECT ,Enables circuit to detect resistance of MiniAB ID pin." "0,1"
        textline "    "
        bitfld.long 0x00 8. " RESUMEIRQSTICKY ,Set to 1 will make RESUME_IRQ bit a sticky bit until software clear it." "0,1"
        textline "    "
        bitfld.long 0x00 9. " ENIRQRESUMEDETECT ,Enables interrupt for detection of a non-J state on the USB line." "0,1"
        textline "    "
        bitfld.long 0x00 10. " RESUME_IRQ ,Indicates that the host is sending a wake-up after suspend." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ENIRQDEVPLUGIN ,Enables interrupt for the detection of connectivity to the USB line." "0,1"
        textline "    "
        bitfld.long 0x00 12. " DEVPLUGIN_IRQ ,Indicates that the device is connected." "0,1"
        textline "    "
        bitfld.long 0x00 13. " DATA_ON_LRADC ,Enables the LRADC to monitor USB_DP and USB_DM." "0,1"
        textline "    "
        bitfld.long 0x00 14. " ENUTMILEVEL2 ,Enables UTMI+ Level2." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ENUTMILEVEL3 ,Enables UTMI+ Level3." "0,1"
        textline "    "
        bitfld.long 0x00 16. " ENIRQWAKEUP ,Enables interrupt for the wakeup events." "0,1"
        textline "    "
        bitfld.long 0x00 17. " WAKEUP_IRQ ,Indicates that there is a wakeup event." "0,1"
        textline "    "
        bitfld.long 0x00 19. " ENAUTOCLR_CLKGATE ,Enables the feature to auto-clear the CLKGATE bit if there is wakeup event while USB is suspended." "0,1"
        textline "    "
        bitfld.long 0x00 20. " ENAUTOCLR_PHY_PWD ,Enables the feature to auto-clear the PWD register bits in USBPHYx_PWD if there is wakeup event while USB is suspended." "0,1"
        textline "    "
        bitfld.long 0x00 21. " ENDPDMCHG_WKUP ,Enables the feature to wakeup USB if DP/DM is toggled when USB is suspended." "0,1"
        textline "    "
        bitfld.long 0x00 22. " ENIDCHG_WKUP ,Enables the feature to wakeup USB if ID is toggled when USB is suspended." "0,1"
        textline "    "
        bitfld.long 0x00 23. " ENVBUSCHG_WKUP ,Enables the feature to wakeup USB if VBUS is toggled when USB is suspended." "0,1"
        textline "    "
        bitfld.long 0x00 24. " FSDLL_RST_EN ,Enables the feature to reset the FSDLL lock detection logic at the end of each TX packet." "0,1"
        textline "    "
        bitfld.long 0x00 27. " OTG_ID_VALUE ,Almost same as OTGID_STATUS in USBPHYx_STATUS Register." "0,1"
        textline "    "
        bitfld.long 0x00 28. " HOST_FORCE_LS_SE0 ,Forces the next FS packet that is transmitted to have a EOP with LS timing." "0,1"
        textline "    "
        bitfld.long 0x00 29. " UTMI_SUSPENDM ,Used by the PHY to indicate a powered-down state." "0,1"
        textline "    "
        bitfld.long 0x00 30. " CLKGATE ,Gate UTMI Clocks." "0,1"
        textline "    "
        bitfld.long 0x00 31. " SFTRST ,Writing a 1 to this bit will soft-reset the USBPHYx_PWD, USBPHYx_TX, USBPHYx_RX, and USBPHYx_CTRL registers." "0,1"
width 7.
group.long 0x40++0x3
    line.long 0x00 "STATUS,USB PHY Status Register"
        bitfld.long 0x00 3. " HOSTDISCONDETECT_STATUS ,Indicates that the device has disconnected while in high-speed host mode." "0,1"
        textline "      "
        bitfld.long 0x00 6. " DEVPLUGIN_STATUS ,Indicates that the device has been connected on the USB_DP and USB_DM lines." "0,1"
        textline "      "
        bitfld.long 0x00 8. " OTGID_STATUS ,Indicates the results of ID pin on MiniAB plug." "0,1"
        textline "      "
        bitfld.long 0x00 10. " RESUME_STATUS ,Indicates that the host is sending a wake-up after suspend and has triggered an interrupt." "0,1"
width 6.
group.long 0x50++0x3
    line.long 0x00 "DEBUG,USB PHY Debug Register"
        bitfld.long 0x00 0. " OTGIDPIOLOCK ,Once OTG ID from USBPHYx_STATUS_OTGID_STATUS, use this to hold the value." "0,1"
        textline "     "
        bitfld.long 0x00 1. " DEBUG_INTERFACE_HOLD ,Use holding registers to assist in timing for external UTMI interface." "0,1"
        textline "     "
        hexmask.long.byte 0x00 2.--4. 1. " HSTPULLDOWN ,Set bit 3 to 1 to pull down 15-KOhm on USB_DP line."
        textline "     "
        hexmask.long.byte 0x00 4.--6. 1. " ENHSTPULLDOWN ,Set bit 5 to 1 to override the control of the USB_DP 15-KOhm pulldown."
        textline "     "
        hexmask.long.byte 0x00 8.--12. 1. " TX2RXCOUNT ,Delay in between the end of transmit to the beginning of receive."
        textline "     "
        bitfld.long 0x00 12. " ENTX2RXCOUNT ,Set this bit to allow a countdown to transition in between TX and RX." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--21. 1. " SQUELCHRESETCOUNT ,Delay in between the detection of squelch to the reset of high-speed RX."
        textline "     "
        bitfld.long 0x00 24. " ENSQUELCHRESET ,Set bit to allow squelch to reset high-speed receive." "0,1"
        textline "     "
        hexmask.long.byte 0x00 25.--29. 1. " SQUELCHRESETLENGTH ,Duration of RESET in terms of the number of 480-MHz cycles."
        textline "     "
        bitfld.long 0x00 29. " HOST_RESUME_DEBUG ,Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UTMI_SUSPEND = 1." "0,1"
        textline "     "
        bitfld.long 0x00 30. " CLKGATE ,Gate Test Clocks." "0,1"
width 14.
rgroup.long 0x60++0x3
    line.long 0x00 "DEBUG0_STATUS,UTMI Debug Status Register 0"
        hexmask.long.word 0x00 0.--16. 1. " LOOP_BACK_FAIL_COUNT ,Running count of the failed pseudo-random generator loopback."
        textline "             "
        hexmask.long.word 0x00 16.--26. 1. " UTMI_RXERROR_FAIL_COUNT ,Running count of the UTMI_RXERROR."
        textline "             "
        hexmask.long.byte 0x00 26.--32. 1. " SQUELCH_COUNT ,Running count of the squelch reset instead of normal end for HS RX."
width 7.
group.long 0x70++0x3
    line.long 0x00 "DEBUG1,UTMI Debug Status Register 1"
        hexmask.long.byte 0x00 13.--15. 1. " ENTAILADJVD ,Delay increment of the rise of squelch: 00 = Delay is nominal 01 = Delay is +20% 10 = Delay is -20% 11 = Delay is -40%"
width 8.
rgroup.long 0x80++0x3
    line.long 0x00 "VERSION,UTMI RTL Version"
        hexmask.long.word 0x00 0.--16. 1. " STEP ,Fixed read-only value reflecting the stepping of the RTL version."
        textline "       "
        hexmask.long.byte 0x00 16.--24. 1. " MINOR ,Fixed read-only value reflecting the MINOR field of the RTL version."
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " MAJOR ,Fixed read-only value reflecting the MAJOR field of the RTL version."


    tree.end

tree.end



;--------------------------------------------------------------------------------
; USDHC
;--------------------------------------------------------------------------------
tree.open "USDHC"
    tree "USDHC1"
        base ad:0x02190000

width 8.
group.long 0x0++0x3
    line.long 0x00 "DS_ADDR,DMA System Address"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,DMA System Address: This register contains the 32-bit system memory address for a DMA transfer."
width 8.
group.long 0x4++0x3
    line.long 0x00 "BLK_ATT,Block Attributes"
        hexmask.long.word 0x00 0.--13. 1. " BLKSIZE ,Transfer Block Size: This register specifies the block size for block data transfers."
        textline "       "
        hexmask.long.word 0x00 16.--32. 1. " BLKCNT ,Blocks Count For Current Transfer: This register is enabled when the Block Count Enable bit in the Transfer Mode register is set to 1 and is valid only for multiple block transfers."
width 8.
group.long 0x8++0x3
    line.long 0x00 "CMD_ARG,Command Argument"
        hexmask.long.long 0x00 0.--32. 1. " CMDARG ,Command Argument: The SD/MMC Command Argument is specified as bits 39-8 of the Command Format in the SD or MMC Specification.This register is write protected when the Command Inhibit (CMD) bit in the Present State register is set."
width 12.
group.long 0xc++0x3
    line.long 0x00 "CMD_XFR_TYP,Command Transfer Type"
        hexmask.long.byte 0x00 16.--18. 1. " RSPTYP ,Response Type Select:"
        textline "           "
        bitfld.long 0x00 19. " CCCEN ,Command CRC Check Enable: If this bit is set to 1, the uSDHC shall check the CRC field in the response." "0,1"
        textline "           "
        bitfld.long 0x00 20. " CICEN ,Command Index Check Enable: If this bit is set to 1, the uSDHC will check the Index field in the response to see if it has the same value as the command index." "0,1"
        textline "           "
        bitfld.long 0x00 21. " DPSEL ,Data Present Select: This bit is set to 1 to indicate that data is present and shall be transferred using the DAT line." "0,1"
        textline "           "
        hexmask.long.byte 0x00 22.--24. 1. " CMDTYP ,Command Type: There are three types of special commands: Suspend, Resume and Abort."
        textline "           "
        hexmask.long.byte 0x00 24.--30. 1. " CMDINX ,Command Index: These bits shall be set to the command number that is specified in bits 45-40 of the Command-Format in the SD Memory Card Physical Layer Specification and SDIO Card Specification."
width 9.
rgroup.long 0x10++0x3
    line.long 0x00 "CMD_RSP0,Command Response0"
        hexmask.long.long 0x00 0.--32. 1. " CMDRSP0 ,Command Response 0: Refer to for the mapping of command responses from the SD Bus to this register for each response type."
width 9.
rgroup.long 0x14++0x3
    line.long 0x00 "CMD_RSP1,Command Response1"
        hexmask.long.long 0x00 0.--32. 1. " CMDRSP1 ,Command Response 1: Refer to for the mapping of command responses from the SD Bus to this register for each response type."
width 9.
rgroup.long 0x18++0x3
    line.long 0x00 "CMD_RSP2,Command Response2"
        hexmask.long.long 0x00 0.--32. 1. " CMDRSP2 ,Command Response 2: Refer to for the mapping of command responses from the SD Bus to this register for each response type."
width 9.
rgroup.long 0x1c++0x3
    line.long 0x00 "CMD_RSP3,Command Response3"
        hexmask.long.long 0x00 0.--32. 1. " CMDRSP3 ,Command Response 3: Refer to for the mapping of command responses from the SD Bus to this register for each response type."
width 19.
group.long 0x20++0x3
    line.long 0x00 "DATA_BUFF_ACC_PORT,Data Buffer Access Port"
        hexmask.long.long 0x00 0.--32. 1. " DATCONT ,Data Content: The Buffer Data Port register is for 32-bit data access by the ARM platform or the external DMA."
width 11.
rgroup.long 0x24++0x3
    line.long 0x00 "PRES_STATE,Present State"
        bitfld.long 0x00 0. " CIHB ,Command Inhibit (CMD): If this status bit is 0, it indicates that the CMD line is not in use and the uSDHC can issue a SD/MMC Command using the CMD line." "0,1"
        textline "          "
        bitfld.long 0x00 1. " CDIHB ,Command Inhibit (DAT): This status bit is generated if either the DAT Line Active or the Read Transfer Active is set to 1." "0,1"
        textline "          "
        bitfld.long 0x00 2. " DLA ,Data Line Active This status bit indicates whether one of the DAT lines on the SD Bus is in use." "0,1"
        textline "          "
        bitfld.long 0x00 3. " SDSTB ,SD Clock Stable This status bit indicates that the internal card clock is stable." "0,1"
        textline "          "
        bitfld.long 0x00 4. " IPGOFF ,ipg_clk Gated Off Internally: This status bit indicates that the ipg_clk is internally gated off." "0,1"
        textline "          "
        bitfld.long 0x00 5. " HCKOFF ,hclk Gated Off Internally: This status bit indicates that the hclk is internally gated off." "0,1"
        textline "          "
        bitfld.long 0x00 6. " PEROFF ,ipg_perclk Gated Off Internally: This status bit indicates that the ipg_perclk is internally gated off." "0,1"
        textline "          "
        bitfld.long 0x00 7. " SDOFF ,SD Clock Gated Off Internally: This status bit indicates that the SD Clock is internally gated off, because of buffer over/under-run or read pause without read wait assertion, or the driver set FRC_SDCLK_ON bit is 0 to stop the SD clock in idle status." "0,1"
        textline "          "
        bitfld.long 0x00 8. " WTA ,Write Transfer Active: This status bit indicates a write transfer is active." "0,1"
        textline "          "
        bitfld.long 0x00 9. " RTA ,Read Transfer Active: This status bit is used for detecting completion of a read transfer." "0,1"
        textline "          "
        bitfld.long 0x00 10. " BWEN ,Buffer Write Enable: This status bit is used for non-DMA write transfers." "0,1"
        textline "          "
        bitfld.long 0x00 11. " BREN ,Buffer Read Enable: This status bit is used for non-DMA read transfers." "0,1"
        textline "          "
        bitfld.long 0x00 12. " RTR ,Re-Tuning Request: (only for SD3.0 SDR104 mode) Host Controller may request Host Driver to execute re-tuning sequence by setting this bit when the data window is shifted by temperature drift and a tuned sampling point does not have a good margin to receive correct data." "0,1"
        textline "          "
        bitfld.long 0x00 15. " TSCD ,Tape Select Change Done : This bit indicates the dealy setting is effective after write CLK_TUNE_CTRL_STATUS register." "0,1"
        textline "          "
        bitfld.long 0x00 16. " CINST ,Card Inserted: This bit indicates whether a card has been inserted." "0,1"
        textline "          "
        bitfld.long 0x00 18. " CDPL ,Card Detect Pin Level: This bit reflects the inverse value of the CD# pin for the card socket." "0,1"
        textline "          "
        bitfld.long 0x00 19. " WPSPL ,Write Protect Switch Pin Level: The Write Protect Switch is supported for memory and combo cards.This bit reflects the inverted value of the WP pin of the card socket." "0,1"
        textline "          "
        bitfld.long 0x00 23. " CLSL ,CMD Line Signal Level: This status is used to check the CMD line level to recover from errors, and for debugging." "0,1"
        textline "          "
        hexmask.long.byte 0x00 24.--32. 1. " DLSL ,DAT[7:0] Line Signal Level: This status is used to check the DAT line level to recover from errors, and for debugging.This is especially useful in detecting the busy signal level from DAT[0]."
width 10.
group.long 0x28++0x3
    line.long 0x00 "PROT_CTRL,Protocol Control"
        bitfld.long 0x00 0. " LCTL ,LED Control: This bit, fully controlled by the Host Driver, is used to caution the user not to remove the card while the card is being accessed." "0,1"
        textline "         "
        hexmask.long.byte 0x00 1.--3. 1. " DTW ,Data Transfer Width: This bit selects the data width of the SD bus for a data transfer."
        textline "         "
        bitfld.long 0x00 3. " D3CD ,DAT3 as Card Detection Pin: If this bit is set, DAT3 should be pulled down to act as a card detection pin." "0,1"
        textline "         "
        hexmask.long.byte 0x00 4.--6. 1. " EMODE ,Endian Mode: The uSDHC supports all three endian modes in data transfer."
        textline "         "
        bitfld.long 0x00 6. " CDTL ,Card Detect Test Level: This is bit is enabled while the Card Detection Signal Selection is set to 1 and it indicates card insertion." "0,1"
        textline "         "
        bitfld.long 0x00 7. " CDSS ,Card Detect Signal Selection: This bit selects the source for the card detection." "0,1"
        textline "         "
        hexmask.long.byte 0x00 8.--10. 1. " DMASEL ,DMA Select: This field is valid while DMA (SDMA or ADMA) is enabled and selects the DMA operation."
        textline "         "
        bitfld.long 0x00 16. " SABGREQ ,Stop At Block Gap Request: This bit is used to stop executing a transaction at the next block gap for both DMA and non-DMA transfers." "0,1"
        textline "         "
        bitfld.long 0x00 17. " CREQ ,Continue Request: This bit is used to restart a transaction which was stopped using the Stop At Block Gap Request." "0,1"
        textline "         "
        bitfld.long 0x00 18. " RWCTL ,Read Wait Control: The read wait function is optional for SDIO cards." "0,1"
        textline "         "
        bitfld.long 0x00 19. " IABG ,Interrupt At Block Gap: This bit is valid only in 4-bit mode, of the SDIO card, and selects a sample point in the interrupt cycle." "0,1"
        textline "         "
        bitfld.long 0x00 20. " RD_DONE_NO_8CLK ,Read done no 8 clock: According to the SD/MMC spec, for read data transaction, 8 clocks are needed after the end bit of the last data block." "0,1"
        textline "         "
        bitfld.long 0x00 24. " WECINT ,Wakeup Event Enable On Card Interrupt: This bit enables a wakeup event, via a Card Interrupt, in the Interrupt Status register." "0,1"
        textline "         "
        bitfld.long 0x00 25. " WECINS ,Wakeup Event Enable On SD Card Insertion: This bit enables a wakeup event, via a Card Insertion, in the Interrupt Status register." "0,1"
        textline "         "
        bitfld.long 0x00 26. " WECRM ,Wakeup Event Enable On SD Card Removal: This bit enables a wakeup event, via a Card Removal, in the Interrupt Status register." "0,1"
        textline "         "
        hexmask.long.byte 0x00 27.--30. 1. " BURST_LEN_EN ,BURST length enable for INCR, INCR4/INCR8/INCR16, INCR4-WRAP/INCR8-WRAP/INCR16-WRAP This is used to enable/disable the burst length for the external AHB2AXI bridge."
        textline "         "
        bitfld.long 0x00 30. " NON_EXACT_BLK_RD ,Current block read is non-exact block read." "0,1"
width 9.
group.long 0x2c++0x3
    line.long 0x00 "SYS_CTRL,System Control"
        hexmask.long.byte 0x00 4.--8. 1. " DVS ,Divisor: This register is used to provide a more exact divisor to generate the desired SD clock frequency."
        textline "        "
        hexmask.long.byte 0x00 8.--16. 1. " SDCLKFS ,SDCLK Frequency Select: This register is used to select the frequency of the SDCLK pin."
        textline "        "
        hexmask.long.byte 0x00 16.--20. 1. " DTOCV ,Data Timeout Counter Value: This value determines the interval by which DAT line timeouts are detected."
        textline "        "
        bitfld.long 0x00 23. " IPP_RST_N ,This register's value will be output to CARD from pad directly for hardware reset of the card if the card supports this feature." "0,1"
        textline "        "
        bitfld.long 0x00 24. " RSTA ,Software Reset For ALL: This reset effects the entire Host Controller except for the card detection circuit." "0,1"
        textline "        "
        bitfld.long 0x00 25. " RSTC ,Software Reset For CMD Line: Only part of the command circuit is reset." "0,1"
        textline "        "
        bitfld.long 0x00 26. " RSTD ,Software Reset For DAT Line: Only part of the data circuit is reset." "0,1"
        textline "        "
        bitfld.long 0x00 27. " INITA ,Initialization Active: When this bit is set, 80 SD-Clocks are sent to the card." "0,1"
        textline "        "
        bitfld.long 0x00 28. " RSTT ,Reset Tuning: When set this bit to 1, it will reset tuning circuit." "0,1"
width 11.
group.long 0x30++0x3
    line.long 0x00 "INT_STATUS,Interrupt Status"
        bitfld.long 0x00 0. " CC ,Command Complete: This bit is set when you receive the end bit of the command response (except Auto CMD12)." "0,1"
        textline "          "
        bitfld.long 0x00 1. " TC ,Transfer Complete: This bit is set when a read or write transfer is completed." "0,1"
        textline "          "
        bitfld.long 0x00 2. " BGE ,Block Gap Event: If the Stop At Block Gap Request bit in the Protocol Control register is set, this bit is set when a read or write transaction is stopped at a block gap." "0,1"
        textline "          "
        bitfld.long 0x00 3. " DINT ,DMA Interrupt: Occurs only when the internal DMA finishes the data transfer successfully." "0,1"
        textline "          "
        bitfld.long 0x00 4. " BWR ,Buffer Write Ready: This status bit is set if the Buffer Write Enable bit, in the Present State register, changes from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 5. " BRR ,Buffer Read Ready: This status bit is set if the Buffer Read Enable bit, in the Present State register, changes from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 6. " CINS ,Card Insertion: This status bit is set if the Card Inserted bit in the Present State register changes from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 7. " CRM ,Card Removal: This status bit is set if the Card Inserted bit in the Present State register changes from 1 to 0." "0,1"
        textline "          "
        bitfld.long 0x00 8. " CINT ,Card Interrupt: This status bit is set when an interrupt signal is detected from the external card." "0,1"
        textline "          "
        bitfld.long 0x00 12. " RTE ,Re-Tuning Event: (only for SD3.0 SDR104 mode) This status is set if Re-Tuning Request in the Present State register changes from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 14. " TP ,Tuning Pass:(only for SD3.0 SDR104 mode) Current CMD19 transfer is done successfully." "0,1"
        textline "          "
        bitfld.long 0x00 16. " CTOE ,Command Timeout Error: Occurs only if no response is returned within 64 SDCLK cycles from the end bit of the command." "0,1"
        textline "          "
        bitfld.long 0x00 17. " CCE ,Command CRC Error: Command CRC Error is generated in two cases." "0,1"
        textline "          "
        bitfld.long 0x00 18. " CEBE ,Command End Bit Error: Occurs when detecting that the end bit of a command response is 0." "0,1"
        textline "          "
        bitfld.long 0x00 19. " CIE ,Command Index Error: Occurs if a Command Index error occurs in the command response." "0,1"
        textline "          "
        bitfld.long 0x00 20. " DTOE ,Data Timeout Error: Occurs when detecting one of following time-out conditions." "0,1"
        textline "          "
        bitfld.long 0x00 21. " DCE ,Data CRC Error: Occurs when detecting a CRC error when transferring read data, which uses the DAT line, or when detecting the Write CRC status having a value other than 010." "0,1"
        textline "          "
        bitfld.long 0x00 22. " DEBE ,Data End Bit Error: Occurs either when detecting 0 at the end bit position of read data, which uses the DAT line, or at the end bit position of the CRC." "0,1"
        textline "          "
        bitfld.long 0x00 24. " AC12E ,Auto CMD12 Error: Occurs when detecting that one of the bits in the Auto CMD12 Error Status register has changed from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 26. " TNE ,Tuning Error: (only for SD3.0 SDR104 mode) This bit is set when an unrecoverable error is detected in a tuning circuit." "0,1"
        textline "          "
        bitfld.long 0x00 28. " DMAE ,DMA Error: Occurs when an Internal DMA transfer has failed." "0,1"
width 14.
group.long 0x34++0x3
    line.long 0x00 "INT_STATUS_EN,Interrupt Status Enable"
        bitfld.long 0x00 0. " CCSEN ,Command Complete Status Enable: 1 Enabled 0 Masked" "0,1"
        textline "             "
        bitfld.long 0x00 1. " TCSEN ,Transfer Complete Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 2. " BGESEN ,Block Gap Event Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 3. " DINTSEN ,DMA Interrupt Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 4. " BWRSEN ,Buffer Write Ready Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 5. " BRRSEN ,Buffer Read Ready Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 6. " CINSSEN ,Card Insertion Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 7. " CRMSEN ,Card Removal Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 8. " CINTSEN ,Card Interrupt Status Enable: If this bit is set to 0, the uSDHC will clear the interrupt request to the System." "0,1"
        textline "             "
        bitfld.long 0x00 12. " RTESEN ,Re-Tuning Event Status Enable" "0,1"
        textline "             "
        bitfld.long 0x00 14. " TPSEN ,Tuning Pass Status Enable" "0,1"
        textline "             "
        bitfld.long 0x00 16. " CTOESEN ,Command Timeout Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 17. " CCESEN ,Command CRC Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 18. " CEBESEN ,Command End Bit Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 19. " CIESEN ,Command Index Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 20. " DTOESEN ,Data Timeout Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 21. " DCESEN ,Data CRC Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 22. " DEBESEN ,Data End Bit Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 24. " AC12ESEN ,Auto CMD12 Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 26. " TNESEN ,Tuning Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 28. " DMAESEN ,DMA Error Status Enable:" "0,1"
width 14.
group.long 0x38++0x3
    line.long 0x00 "INT_SIGNAL_EN,Interrupt Signal Enable"
        bitfld.long 0x00 0. " CCIEN ,Command Complete Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 1. " TCIEN ,Transfer Complete Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 2. " BGEIEN ,Block Gap Event Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 3. " DINTIEN ,DMA Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 4. " BWRIEN ,Buffer Write Ready Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 5. " BRRIEN ,Buffer Read Ready Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 6. " CINSIEN ,Card Insertion Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 7. " CRMIEN ,Card Removal Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 8. " CINTIEN ,Card Interrupt Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 12. " RTEIEN ,Re-Tuning Event Interrupt Enable" "0,1"
        textline "             "
        bitfld.long 0x00 14. " TPIEN ,Tuning Pass Interrupt Enable" "0,1"
        textline "             "
        bitfld.long 0x00 16. " CTOEIEN ,Command Timeout Error Interrupt Enable" "0,1"
        textline "             "
        bitfld.long 0x00 17. " CCEIEN ,Command CRC Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 18. " CEBEIEN ,Command End Bit Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 19. " CIEIEN ,Command Index Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 20. " DTOEIEN ,Data Timeout Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 21. " DCEIEN ,Data CRC Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 22. " DEBEIEN ,Data End Bit Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 24. " AC12EIEN ,Auto CMD12 Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 26. " TNEIEN ,Tuning Error Interrupt Enable" "0,1"
        textline "             "
        bitfld.long 0x00 28. " DMAEIEN ,DMA Error Interrupt Enable:" "0,1"
width 21.
rgroup.long 0x3c++0x3
    line.long 0x00 "AUTOCMD12_ERR_STATUS,Auto CMD12 Error Status"
        bitfld.long 0x00 0. " AC12NE ,Auto CMD12 Not Executed: If memory multiple block data transfer is not started, due to a command error, this bit is not set because it is not necessary to issue an Auto CMD12." "0,1"
        textline "                    "
        bitfld.long 0x00 1. " AC12TOE ,Auto CMD12 Timeout Error: Occurs if no response is returned within 64 SDCLK cycles from the end bit of the command." "0,1"
        textline "                    "
        bitfld.long 0x00 2. " AC12EBE ,Auto CMD12 End Bit Error: Occurs when detecting that the end bit of command response is 0 which should be 1." "0,1"
        textline "                    "
        bitfld.long 0x00 3. " AC12CE ,Auto CMD12 CRC Error: Occurs when detecting a CRC error in the command response." "0,1"
        textline "                    "
        bitfld.long 0x00 4. " AC12IE ,Auto CMD12 Index Error: Occurs if the Command Index error occurs in response to a command." "0,1"
        textline "                    "
        bitfld.long 0x00 7. " CNIBAC12E ,Command Not Issued By Auto CMD12 Error: Setting this bit to 1 means CMD_wo_DAT is not executed due to an Auto CMD12 Error (D04-D01) in this register." "0,1"
        textline "                    "
        bitfld.long 0x00 22. " EXECUTE_TUNING ,Execute Tuning: When std_tuning_en bit is set, this bit is used to start tuning procedure." "0,1"
        textline "                    "
        bitfld.long 0x00 23. " SMP_CLK_SEL ,Sample Clock Select: When std_tuning_en bit is set, this bit is used to select sampling clock to receive CMD and DAT." "0,1"
width 14.
rgroup.long 0x40++0x3
    line.long 0x00 "HOST_CTRL_CAP,Host Controller Capabilities"
        bitfld.long 0x00 0. " SDR50_SUPPORT ,SDR50 support: This bit indicates support of SDR50 mode." "0,1"
        textline "             "
        bitfld.long 0x00 1. " SDR104_SUPPORT ,SDR104 support: This bit indicates support of SDR104 mode." "0,1"
        textline "             "
        bitfld.long 0x00 2. " DDR50_SUPPORT ,DDR50 support: This bit indicates support of DDR50 mode." "0,1"
        textline "             "
        hexmask.long.byte 0x00 8.--12. 1. " TIME_COUNT_RETUNING ,Time counter for retuning: This bit indicates an initial value of the Retuning Timer for Re-Tuning Mode1 and 3.Setting to 0 disables Retuning Timer."
        textline "             "
        bitfld.long 0x00 13. " USE_TUNING_SDR50 ,Use Tuning for SDR50: This bit is set to 1." "0,1"
        textline "             "
        hexmask.long.byte 0x00 14.--16. 1. " RETUNING_MODE ,Retuning Mode: This bit selects retuning method."
        textline "             "
        hexmask.long.byte 0x00 16.--19. 1. " MBL ,Max Block Length: This value indicates the maximum block size that the Host Driver can read and write to the buffer in the uSDHC."
        textline "             "
        bitfld.long 0x00 20. " ADMAS ,ADMA Support: This bit indicates whether the uSDHC supports the ADMA feature." "0,1"
        textline "             "
        bitfld.long 0x00 21. " HSS ,High Speed Support: This bit indicates whether the uSDHC supports High Speed mode and the Host System can supply a SD Clock frequency from 25 MHz to 50 MHz." "0,1"
        textline "             "
        bitfld.long 0x00 22. " DMAS ,DMA Support: This bit indicates whether the uSDHC is capable of using the internal DMA to transfer data between system memory and the data buffer directly." "0,1"
        textline "             "
        bitfld.long 0x00 23. " SRS ,Suspend / Resume Support: This bit indicates whether the uSDHC supports Suspend / Resume functionality." "0,1"
        textline "             "
        bitfld.long 0x00 24. " VS33 ,Voltage Support 3.3V: This bit shall depend on the Host System ability." "0,1"
        textline "             "
        bitfld.long 0x00 25. " VS30 ,Voltage Support 3.0V: This bit shall depend on the Host System ability." "0,1"
        textline "             "
        bitfld.long 0x00 26. " VS18 ,Voltage Support 1.8V: This bit shall depend on the Host System ability." "0,1"
width 9.
group.long 0x44++0x3
    line.long 0x00 "WTMK_LVL,Watermark Level"
        hexmask.long.byte 0x00 0.--8. 1. " RD_WML ,Read Watermark Level: The number of words used as the watermark level (FIFO threshold) in a DMA read operation."
        textline "        "
        hexmask.long.byte 0x00 8.--13. 1. " RD_BRST_LEN ,Read Burst Length: Due to system restriction, the actual burst length may not exceed 16."
        textline "        "
        hexmask.long.byte 0x00 16.--24. 1. " WR_WML ,Write Watermark Level: The number of words used as the watermark level (FIFO threshold) in a DMA write operation."
        textline "        "
        hexmask.long.byte 0x00 24.--29. 1. " WR_BRST_LEN ,Write Burst Length: Due to system restriction, the actual burst length may not exceed 16."
width 9.
group.long 0x48++0x3
    line.long 0x00 "MIX_CTRL,Mixer Control"
        bitfld.long 0x00 0. " DMAEN ,DMA Enable: This bit enables DMA functionality." "0,1"
        textline "        "
        bitfld.long 0x00 1. " BCEN ,Block Count Enable: This bit is used to enable the Block Count register, which is only relevant for multiple block transfers." "0,1"
        textline "        "
        bitfld.long 0x00 2. " AC12EN ,Auto CMD12 Enable: Multiple block transfers for memory require a CMD12 to stop the transaction." "0,1"
        textline "        "
        bitfld.long 0x00 3. " DDR_EN ,Dual Data Rate mode selection" "0,1"
        textline "        "
        bitfld.long 0x00 4. " DTDSEL ,Data Transfer Direction Select: This bit defines the direction of DAT line data transfers." "0,1"
        textline "        "
        bitfld.long 0x00 5. " MSBSEL ,Multi / Single Block Select: This bit enables multiple block DAT line data transfers." "0,1"
        textline "        "
        bitfld.long 0x00 6. " NIBBLE_POS ,In DDR 4-bit mode nibble position indictation." "0,1"
        textline "        "
        bitfld.long 0x00 7. " AC23EN ,Auto CMD23 Enable When this bit is set to 1, the Host Controller issues a CMD23 automatically before issuing a command specified in the Command Register." "0,1"
        textline "        "
        bitfld.long 0x00 22. " EXE_TUNE ,Execute Tuning: (Only used for SD3.0, SDR104 mode) When std_tuning_en is 0, this bit is set to 1 to indicate the Host Driver is starting tuning procedure." "0,1"
        textline "        "
        bitfld.long 0x00 23. " SMP_CLK_SEL ,When std_tuning_en is 0, this bit is used to select Tuned clock or Fixed clock to sample data/cmd (Only used for SD3.0, SDR104 mode)" "0,1"
        textline "        "
        bitfld.long 0x00 24. " AUTO_TUNE_EN ,Auto tuning enable (Only used for SD3.0, SDR104 mode)" "0,1"
        textline "        "
        bitfld.long 0x00 25. " FBCLK_SEL ,Feedback clock source selection (Only used for SD3.0, SDR104 mode)" "0,1"
width 12.
wgroup.long 0x50++0x3
    line.long 0x00 "FORCE_EVENT,Force Event"
        bitfld.long 0x00 0. " FEVTAC12NE ,Force Event Auto Command 12 Not Executed: Forces the AC12NE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 1. " FEVTAC12TOE ,Force Event Auto Command 12 Time Out Error: Forces the AC12TOE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 2. " FEVTAC12CE ,Force Event Auto Command 12 CRC Error: Forces the AC12CE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 3. " FEVTAC12EBE ,Force Event Auto Command 12 End Bit Error: Forces the AC12EBE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 4. " FEVTAC12IE ,Force Event Auto Command 12 Index Error: Forces the AC12IE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 7. " FEVTCNIBAC12E ,Force Event Command Not Executed By Auto Command 12 Error: Forces the CNIBAC12E bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 16. " FEVTCTOE ,Force Event Command Time Out Error: Forces the CTOE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 17. " FEVTCCE ,Force Event Command CRC Error: Forces the CCE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 18. " FEVTCEBE ,Force Event Command End Bit Error: Forces the CEBE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 19. " FEVTCIE ,Force Event Command Index Error: Forces the CCE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 20. " FEVTDTOE ,Force Event Data Time Out Error: Force the DTOE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 21. " FEVTDCE ,Force Event Data CRC Error: Forces the DCE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 22. " FEVTDEBE ,Force Event Data End Bit Error: Forces the DEBE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 24. " FEVTAC12E ,Force Event Auto Command 12 Error: Forces the AC12E bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 26. " FEVTTNE ,Force Tuning Error: Forces the TNE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 28. " FEVTDMAE ,Force Event DMA Error: Forces the DMAE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 31. " FEVTCINT ,Force Event Card Interrupt: Writing 1 to this bit generates a short low-level pulse on the internal DAT[1] line, as if a self clearing interrupt was received from the external card." "0,1"
width 16.
rgroup.long 0x54++0x3
    line.long 0x00 "ADMA_ERR_STATUS,ADMA Error Status Register"
        hexmask.long.byte 0x00 0.--2. 1. " ADMAES ,ADMA Error State (when ADMA Error is occurred.): This field indicates the state of the ADMA when an error has occurred during an ADMA data transfer."
        textline "               "
        bitfld.long 0x00 2. " ADMALME ,ADMA Length Mismatch Error: This error occurs in the following 2 cases: While the Block Count Enable is being set, the total data length specified by the Descriptor table is different from that specified by the Block Count and Block Length Total data length can not be divided by the block length" "0,1"
        textline "               "
        bitfld.long 0x00 3. " ADMADCE ,ADMA Descritor Error: This error occurs when invalid descriptor fetched by ADMA:" "0,1"
width 14.
group.long 0x58++0x3
    line.long 0x00 "ADMA_SYS_ADDR,ADMA System Address"
        hexmask.long.long 0x00 2.--32. 1. " ADS_ADDR ,ADMA System Address: This register holds the word address of the executing command in the Descriptor table."
width 9.
group.long 0x60++0x3
    line.long 0x00 "DLL_CTRL,DLL (Delay Line) Control"
        bitfld.long 0x00 0. " DLL_CTRL_ENABLE ,Set this bit to 1 to enable the DLL and delay chain; otherwise; set to 0 to bypasses DLL." "0,1"
        textline "        "
        bitfld.long 0x00 1. " DLL_CTRL_RESET ,Setting this bit to 1 force a reset on DLL." "0,1"
        textline "        "
        bitfld.long 0x00 2. " DLL_CTRL_SLV_FORCE_UPD ,Setting this bit to 1, forces the slave delay line to update to the DLL calibrated value immediately." "0,1"
        textline "        "
        hexmask.long.byte 0x00 3.--7. 1. " DLL_CTRL_SLV_DLY_TARGET0 ,The delay target for the uSDHC loopback read clock can be programmed in 1/16th increments of an ref_clock half-period."
        textline "        "
        bitfld.long 0x00 7. " DLL_CTRL_GATE_UPDATE ,Set this bit to 1 to prevent the DLL from updating (since when clock_in exists, glitches may appear during DLL updates)." "0,1"
        textline "        "
        bitfld.long 0x00 8. " DLL_CTRL_SLV_OVERRIDE ,Set this bit to 1 to Enable manual override for slave delay chain using SLV_OVERRIDE_VAL; to set 0 to disable manual override." "0,1"
        textline "        "
        hexmask.long.byte 0x00 9.--16. 1. " DLL_CTRL_SLV_OVERRIDE_VAL ,When SLV_OVERRIDE=1 This field is used to select 1 of 128 physical taps manually."
        textline "        "
        hexmask.long.byte 0x00 16.--19. 1. " DLL_CTRL_SLV_DLY_TARGET1 ,Refer to DLL_CTRL_SLV_DLY_TARGET0 below."
        textline "        "
        hexmask.long.byte 0x00 20.--28. 1. " DLL_CTRL_SLV_UPDATE_INT ,Slave delay line update interval."
        textline "        "
        hexmask.long.byte 0x00 28.--32. 1. " DLL_CTRL_REF_UPDATE_INT ,DLL control loop update interval."
width 11.
rgroup.long 0x64++0x3
    line.long 0x00 "DLL_STATUS,DLL Status"
        bitfld.long 0x00 0. " DLL_STS_SLV_LOCK ,Slave delay-line lock status." "0,1"
        textline "          "
        bitfld.long 0x00 1. " DLL_STS_REF_LOCK ,Reference DLL lock status." "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--9. 1. " DLL_STS_SLV_SEL ,Slave delay line select status."
        textline "          "
        hexmask.long.byte 0x00 9.--16. 1. " DLL_STS_REF_SEL ,Reference delay line select taps."
width 21.
group.long 0x68++0x3
    line.long 0x00 "CLK_TUNE_CTRL_STATUS,CLK Tuning Control and Status"
        hexmask.long.byte 0x00 0.--4. 1. " DLY_CELL_SET_POST ,Set the number of delay cells on the feedback clock between CLK_OUT and CLK_POST."
        textline "                    "
        hexmask.long.byte 0x00 4.--8. 1. " DLY_CELL_SET_OUT ,Set the number of delay cells on the feedback clock between CLK_PRE and CLK_OUT."
        textline "                    "
        hexmask.long.byte 0x00 8.--15. 1. " DLY_CELL_SET_PRE ,Set the number of delay cells on the feedback clock between the feedback clock and CLK_PRE."
        textline "                    "
        bitfld.long 0x00 15. " NXT_ERR ,NXT error which means the number of delay cells added on the feedback clock is too large." "0,1"
        textline "                    "
        hexmask.long.byte 0x00 16.--20. 1. " TAP_SEL_POST ,Reflect the number of delay cells added on the feedback clock between CLK_OUT and CLK_POST."
        textline "                    "
        hexmask.long.byte 0x00 20.--24. 1. " TAP_SEL_OUT ,Reflect the number of delay cells added on the feedback clock between CLK_PRE and CLK_OUT."
        textline "                    "
        hexmask.long.byte 0x00 24.--31. 1. " TAP_SEL_PRE ,Reflects the number of delay cells added on the feedback clock between the feedback clock and CLK_PRE."
        textline "                    "
        bitfld.long 0x00 31. " PRE_ERR ,PRE error which means the number of delay cells added on the feedback clock is too small." "0,1"
width 10.
group.long 0xc0++0x3
    line.long 0x00 "VEND_SPEC,Vendor Specific Register"
        bitfld.long 0x00 0. " EXT_DMA_EN ,External DMA Request Enable Enable the request to external DMA." "0,1"
        textline "         "
        bitfld.long 0x00 1. " VSELECT ,Voltage Selection Change the value of output signal VSELECT, to control the voltage on pads for external card." "0,1"
        textline "         "
        bitfld.long 0x00 2. " CONFLICT_CHK_EN ,It's not implemented in uSDHC IP." "0,1"
        textline "         "
        bitfld.long 0x00 3. " AC12_WR_CHKBUSY_EN ,Check busy enable after auto CMD12 for write data packet" "0,1"
        textline "         "
        bitfld.long 0x00 4. " DAT3_CD_POL ,Only for debug." "0,1"
        textline "         "
        bitfld.long 0x00 5. " CD_POL ,Only for debug." "0,1"
        textline "         "
        bitfld.long 0x00 6. " WP_POL ,Only for debug." "0,1"
        textline "         "
        bitfld.long 0x00 7. " CLKONJ_IN_ABORT ,Only for debug." "0,1"
        textline "         "
        bitfld.long 0x00 8. " FRC_SDCLK_ON ,Force CLK output active:" "0,1"
        textline "         "
        bitfld.long 0x00 11. " IPG_CLK_SOFT_EN ,IPG_CLK software enable" "0,1"
        textline "         "
        bitfld.long 0x00 12. " HCLK_SOFT_EN ,Please note, hardware auto-enables the AHB clock when the internal DMA is enabled even if HCLK_SOFT_EN is 0." "0,1"
        textline "         "
        bitfld.long 0x00 13. " IPG_PERCLK_SOFT_EN ,ipg_perclk software enable" "0,1"
        textline "         "
        bitfld.long 0x00 14. " CARD_CLK_SOFT_EN ,card clock software enable" "0,1"
        textline "         "
        bitfld.long 0x00 15. " CRC_CHK_DIS ,CRC check disable" "0,1"
        textline "         "
        hexmask.long.byte 0x00 16.--24. 1. " INT_ST_VAL ,Internal State Value Internal state value, reflecting the corresponding state value selected by Debug Select field."
width 9.
group.long 0xc4++0x3
    line.long 0x00 "MMC_BOOT,MMC Boot Register"
        hexmask.long.byte 0x00 0.--4. 1. " DTOCV_ACK ,Boot ACK time out counter value."
        textline "        "
        bitfld.long 0x00 4. " BOOT_ACK ,Boot ack mode select." "0,1"
        textline "        "
        bitfld.long 0x00 5. " BOOT_MODE ,Boot mode select." "0,1"
        textline "        "
        bitfld.long 0x00 6. " BOOT_EN ,Boot mode enable." "0,1"
        textline "        "
        bitfld.long 0x00 7. " AUTO_SABG_EN ,During boot, enable auto stop at block gap function." "0,1"
        textline "        "
        bitfld.long 0x00 8. " DISABLE_TIME_OUT ,Please note, when this bit is set, there is no timeout check no matter whether boot_en is set or not." "0,1"
        textline "        "
        hexmask.long.word 0x00 16.--32. 1. " BOOT_BLK_CNT ,The value defines the Stop At Block Gap value of automatic mode."
width 11.
group.long 0xc8++0x3
    line.long 0x00 "VEND_SPEC2,Vendor Specific 2 Register"
        bitfld.long 0x00 0. " SDR104_TIMING_DIS ,Timeout counter test." "0,1"
        textline "          "
        bitfld.long 0x00 1. " SDR104_OE_DIS ,CMD_OE/DAT_OE logic generation test." "0,1"
        textline "          "
        bitfld.long 0x00 2. " SDR104_NSD_DIS ,Interrupt window after abort command is sent." "0,1"
        textline "          "
        bitfld.long 0x00 3. " CARD_INT_D3_TEST ,Card interrupt detection test." "0,1"
        textline "          "
        bitfld.long 0x00 4. " TUNING_8BIT_EN ,Enable the auto tuning circuit to check the DAT[7:0]." "0,1"
        textline "          "
        bitfld.long 0x00 5. " TUNING_1BIT_EN ,Enable the auto tuning circuit to check the DAT0 only." "0,1"
        textline "          "
        bitfld.long 0x00 6. " TUNING_CMD_EN ,Enable the auto tuning circuit to check the CMD line." "0,1"
        textline "          "
        bitfld.long 0x00 7. " CARD_INT_AUTO_CLR_DIS ,Disable the feature to clear the Card interrupt status bit when Card Interrupt status enable bit is cleared." "0,1"
width 12.
group.long 0xcc++0x3
    line.long 0x00 "TUNING_CTRL,Tuning Control Register"
        hexmask.long.byte 0x00 0.--8. 1. " TUNING_START_TAP ,The start dealy cell point when send first CMD19 in tuning procedure."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " TUNING_COUNTER ,The MAX repeat CMD19 times in tuning procedure."
        textline "           "
        hexmask.long.byte 0x00 16.--19. 1. " TUNING_STEP ,The increasing delay cell step in tuning procedure."
        textline "           "
        hexmask.long.byte 0x00 20.--23. 1. " TUNING_WINDOW ,Select data window value for auto tuning"
        textline "           "
        bitfld.long 0x00 24. " STD_TUNING_EN ,Standard tuning circuit and procedure enable: This bit is used to enable standard tuning circuit and procedure." "0,1"


    tree.end
    tree "USDHC2"
        base ad:0x02194000

width 8.
group.long 0x0++0x3
    line.long 0x00 "DS_ADDR,DMA System Address"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,DMA System Address: This register contains the 32-bit system memory address for a DMA transfer."
width 8.
group.long 0x4++0x3
    line.long 0x00 "BLK_ATT,Block Attributes"
        hexmask.long.word 0x00 0.--13. 1. " BLKSIZE ,Transfer Block Size: This register specifies the block size for block data transfers."
        textline "       "
        hexmask.long.word 0x00 16.--32. 1. " BLKCNT ,Blocks Count For Current Transfer: This register is enabled when the Block Count Enable bit in the Transfer Mode register is set to 1 and is valid only for multiple block transfers."
width 8.
group.long 0x8++0x3
    line.long 0x00 "CMD_ARG,Command Argument"
        hexmask.long.long 0x00 0.--32. 1. " CMDARG ,Command Argument: The SD/MMC Command Argument is specified as bits 39-8 of the Command Format in the SD or MMC Specification.This register is write protected when the Command Inhibit (CMD) bit in the Present State register is set."
width 12.
group.long 0xc++0x3
    line.long 0x00 "CMD_XFR_TYP,Command Transfer Type"
        hexmask.long.byte 0x00 16.--18. 1. " RSPTYP ,Response Type Select:"
        textline "           "
        bitfld.long 0x00 19. " CCCEN ,Command CRC Check Enable: If this bit is set to 1, the uSDHC shall check the CRC field in the response." "0,1"
        textline "           "
        bitfld.long 0x00 20. " CICEN ,Command Index Check Enable: If this bit is set to 1, the uSDHC will check the Index field in the response to see if it has the same value as the command index." "0,1"
        textline "           "
        bitfld.long 0x00 21. " DPSEL ,Data Present Select: This bit is set to 1 to indicate that data is present and shall be transferred using the DAT line." "0,1"
        textline "           "
        hexmask.long.byte 0x00 22.--24. 1. " CMDTYP ,Command Type: There are three types of special commands: Suspend, Resume and Abort."
        textline "           "
        hexmask.long.byte 0x00 24.--30. 1. " CMDINX ,Command Index: These bits shall be set to the command number that is specified in bits 45-40 of the Command-Format in the SD Memory Card Physical Layer Specification and SDIO Card Specification."
width 9.
rgroup.long 0x10++0x3
    line.long 0x00 "CMD_RSP0,Command Response0"
        hexmask.long.long 0x00 0.--32. 1. " CMDRSP0 ,Command Response 0: Refer to for the mapping of command responses from the SD Bus to this register for each response type."
width 9.
rgroup.long 0x14++0x3
    line.long 0x00 "CMD_RSP1,Command Response1"
        hexmask.long.long 0x00 0.--32. 1. " CMDRSP1 ,Command Response 1: Refer to for the mapping of command responses from the SD Bus to this register for each response type."
width 9.
rgroup.long 0x18++0x3
    line.long 0x00 "CMD_RSP2,Command Response2"
        hexmask.long.long 0x00 0.--32. 1. " CMDRSP2 ,Command Response 2: Refer to for the mapping of command responses from the SD Bus to this register for each response type."
width 9.
rgroup.long 0x1c++0x3
    line.long 0x00 "CMD_RSP3,Command Response3"
        hexmask.long.long 0x00 0.--32. 1. " CMDRSP3 ,Command Response 3: Refer to for the mapping of command responses from the SD Bus to this register for each response type."
width 19.
group.long 0x20++0x3
    line.long 0x00 "DATA_BUFF_ACC_PORT,Data Buffer Access Port"
        hexmask.long.long 0x00 0.--32. 1. " DATCONT ,Data Content: The Buffer Data Port register is for 32-bit data access by the ARM platform or the external DMA."
width 11.
rgroup.long 0x24++0x3
    line.long 0x00 "PRES_STATE,Present State"
        bitfld.long 0x00 0. " CIHB ,Command Inhibit (CMD): If this status bit is 0, it indicates that the CMD line is not in use and the uSDHC can issue a SD/MMC Command using the CMD line." "0,1"
        textline "          "
        bitfld.long 0x00 1. " CDIHB ,Command Inhibit (DAT): This status bit is generated if either the DAT Line Active or the Read Transfer Active is set to 1." "0,1"
        textline "          "
        bitfld.long 0x00 2. " DLA ,Data Line Active This status bit indicates whether one of the DAT lines on the SD Bus is in use." "0,1"
        textline "          "
        bitfld.long 0x00 3. " SDSTB ,SD Clock Stable This status bit indicates that the internal card clock is stable." "0,1"
        textline "          "
        bitfld.long 0x00 4. " IPGOFF ,ipg_clk Gated Off Internally: This status bit indicates that the ipg_clk is internally gated off." "0,1"
        textline "          "
        bitfld.long 0x00 5. " HCKOFF ,hclk Gated Off Internally: This status bit indicates that the hclk is internally gated off." "0,1"
        textline "          "
        bitfld.long 0x00 6. " PEROFF ,ipg_perclk Gated Off Internally: This status bit indicates that the ipg_perclk is internally gated off." "0,1"
        textline "          "
        bitfld.long 0x00 7. " SDOFF ,SD Clock Gated Off Internally: This status bit indicates that the SD Clock is internally gated off, because of buffer over/under-run or read pause without read wait assertion, or the driver set FRC_SDCLK_ON bit is 0 to stop the SD clock in idle status." "0,1"
        textline "          "
        bitfld.long 0x00 8. " WTA ,Write Transfer Active: This status bit indicates a write transfer is active." "0,1"
        textline "          "
        bitfld.long 0x00 9. " RTA ,Read Transfer Active: This status bit is used for detecting completion of a read transfer." "0,1"
        textline "          "
        bitfld.long 0x00 10. " BWEN ,Buffer Write Enable: This status bit is used for non-DMA write transfers." "0,1"
        textline "          "
        bitfld.long 0x00 11. " BREN ,Buffer Read Enable: This status bit is used for non-DMA read transfers." "0,1"
        textline "          "
        bitfld.long 0x00 12. " RTR ,Re-Tuning Request: (only for SD3.0 SDR104 mode) Host Controller may request Host Driver to execute re-tuning sequence by setting this bit when the data window is shifted by temperature drift and a tuned sampling point does not have a good margin to receive correct data." "0,1"
        textline "          "
        bitfld.long 0x00 15. " TSCD ,Tape Select Change Done : This bit indicates the dealy setting is effective after write CLK_TUNE_CTRL_STATUS register." "0,1"
        textline "          "
        bitfld.long 0x00 16. " CINST ,Card Inserted: This bit indicates whether a card has been inserted." "0,1"
        textline "          "
        bitfld.long 0x00 18. " CDPL ,Card Detect Pin Level: This bit reflects the inverse value of the CD# pin for the card socket." "0,1"
        textline "          "
        bitfld.long 0x00 19. " WPSPL ,Write Protect Switch Pin Level: The Write Protect Switch is supported for memory and combo cards.This bit reflects the inverted value of the WP pin of the card socket." "0,1"
        textline "          "
        bitfld.long 0x00 23. " CLSL ,CMD Line Signal Level: This status is used to check the CMD line level to recover from errors, and for debugging." "0,1"
        textline "          "
        hexmask.long.byte 0x00 24.--32. 1. " DLSL ,DAT[7:0] Line Signal Level: This status is used to check the DAT line level to recover from errors, and for debugging.This is especially useful in detecting the busy signal level from DAT[0]."
width 10.
group.long 0x28++0x3
    line.long 0x00 "PROT_CTRL,Protocol Control"
        bitfld.long 0x00 0. " LCTL ,LED Control: This bit, fully controlled by the Host Driver, is used to caution the user not to remove the card while the card is being accessed." "0,1"
        textline "         "
        hexmask.long.byte 0x00 1.--3. 1. " DTW ,Data Transfer Width: This bit selects the data width of the SD bus for a data transfer."
        textline "         "
        bitfld.long 0x00 3. " D3CD ,DAT3 as Card Detection Pin: If this bit is set, DAT3 should be pulled down to act as a card detection pin." "0,1"
        textline "         "
        hexmask.long.byte 0x00 4.--6. 1. " EMODE ,Endian Mode: The uSDHC supports all three endian modes in data transfer."
        textline "         "
        bitfld.long 0x00 6. " CDTL ,Card Detect Test Level: This is bit is enabled while the Card Detection Signal Selection is set to 1 and it indicates card insertion." "0,1"
        textline "         "
        bitfld.long 0x00 7. " CDSS ,Card Detect Signal Selection: This bit selects the source for the card detection." "0,1"
        textline "         "
        hexmask.long.byte 0x00 8.--10. 1. " DMASEL ,DMA Select: This field is valid while DMA (SDMA or ADMA) is enabled and selects the DMA operation."
        textline "         "
        bitfld.long 0x00 16. " SABGREQ ,Stop At Block Gap Request: This bit is used to stop executing a transaction at the next block gap for both DMA and non-DMA transfers." "0,1"
        textline "         "
        bitfld.long 0x00 17. " CREQ ,Continue Request: This bit is used to restart a transaction which was stopped using the Stop At Block Gap Request." "0,1"
        textline "         "
        bitfld.long 0x00 18. " RWCTL ,Read Wait Control: The read wait function is optional for SDIO cards." "0,1"
        textline "         "
        bitfld.long 0x00 19. " IABG ,Interrupt At Block Gap: This bit is valid only in 4-bit mode, of the SDIO card, and selects a sample point in the interrupt cycle." "0,1"
        textline "         "
        bitfld.long 0x00 20. " RD_DONE_NO_8CLK ,Read done no 8 clock: According to the SD/MMC spec, for read data transaction, 8 clocks are needed after the end bit of the last data block." "0,1"
        textline "         "
        bitfld.long 0x00 24. " WECINT ,Wakeup Event Enable On Card Interrupt: This bit enables a wakeup event, via a Card Interrupt, in the Interrupt Status register." "0,1"
        textline "         "
        bitfld.long 0x00 25. " WECINS ,Wakeup Event Enable On SD Card Insertion: This bit enables a wakeup event, via a Card Insertion, in the Interrupt Status register." "0,1"
        textline "         "
        bitfld.long 0x00 26. " WECRM ,Wakeup Event Enable On SD Card Removal: This bit enables a wakeup event, via a Card Removal, in the Interrupt Status register." "0,1"
        textline "         "
        hexmask.long.byte 0x00 27.--30. 1. " BURST_LEN_EN ,BURST length enable for INCR, INCR4/INCR8/INCR16, INCR4-WRAP/INCR8-WRAP/INCR16-WRAP This is used to enable/disable the burst length for the external AHB2AXI bridge."
        textline "         "
        bitfld.long 0x00 30. " NON_EXACT_BLK_RD ,Current block read is non-exact block read." "0,1"
width 9.
group.long 0x2c++0x3
    line.long 0x00 "SYS_CTRL,System Control"
        hexmask.long.byte 0x00 4.--8. 1. " DVS ,Divisor: This register is used to provide a more exact divisor to generate the desired SD clock frequency."
        textline "        "
        hexmask.long.byte 0x00 8.--16. 1. " SDCLKFS ,SDCLK Frequency Select: This register is used to select the frequency of the SDCLK pin."
        textline "        "
        hexmask.long.byte 0x00 16.--20. 1. " DTOCV ,Data Timeout Counter Value: This value determines the interval by which DAT line timeouts are detected."
        textline "        "
        bitfld.long 0x00 23. " IPP_RST_N ,This register's value will be output to CARD from pad directly for hardware reset of the card if the card supports this feature." "0,1"
        textline "        "
        bitfld.long 0x00 24. " RSTA ,Software Reset For ALL: This reset effects the entire Host Controller except for the card detection circuit." "0,1"
        textline "        "
        bitfld.long 0x00 25. " RSTC ,Software Reset For CMD Line: Only part of the command circuit is reset." "0,1"
        textline "        "
        bitfld.long 0x00 26. " RSTD ,Software Reset For DAT Line: Only part of the data circuit is reset." "0,1"
        textline "        "
        bitfld.long 0x00 27. " INITA ,Initialization Active: When this bit is set, 80 SD-Clocks are sent to the card." "0,1"
        textline "        "
        bitfld.long 0x00 28. " RSTT ,Reset Tuning: When set this bit to 1, it will reset tuning circuit." "0,1"
width 11.
group.long 0x30++0x3
    line.long 0x00 "INT_STATUS,Interrupt Status"
        bitfld.long 0x00 0. " CC ,Command Complete: This bit is set when you receive the end bit of the command response (except Auto CMD12)." "0,1"
        textline "          "
        bitfld.long 0x00 1. " TC ,Transfer Complete: This bit is set when a read or write transfer is completed." "0,1"
        textline "          "
        bitfld.long 0x00 2. " BGE ,Block Gap Event: If the Stop At Block Gap Request bit in the Protocol Control register is set, this bit is set when a read or write transaction is stopped at a block gap." "0,1"
        textline "          "
        bitfld.long 0x00 3. " DINT ,DMA Interrupt: Occurs only when the internal DMA finishes the data transfer successfully." "0,1"
        textline "          "
        bitfld.long 0x00 4. " BWR ,Buffer Write Ready: This status bit is set if the Buffer Write Enable bit, in the Present State register, changes from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 5. " BRR ,Buffer Read Ready: This status bit is set if the Buffer Read Enable bit, in the Present State register, changes from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 6. " CINS ,Card Insertion: This status bit is set if the Card Inserted bit in the Present State register changes from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 7. " CRM ,Card Removal: This status bit is set if the Card Inserted bit in the Present State register changes from 1 to 0." "0,1"
        textline "          "
        bitfld.long 0x00 8. " CINT ,Card Interrupt: This status bit is set when an interrupt signal is detected from the external card." "0,1"
        textline "          "
        bitfld.long 0x00 12. " RTE ,Re-Tuning Event: (only for SD3.0 SDR104 mode) This status is set if Re-Tuning Request in the Present State register changes from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 14. " TP ,Tuning Pass:(only for SD3.0 SDR104 mode) Current CMD19 transfer is done successfully." "0,1"
        textline "          "
        bitfld.long 0x00 16. " CTOE ,Command Timeout Error: Occurs only if no response is returned within 64 SDCLK cycles from the end bit of the command." "0,1"
        textline "          "
        bitfld.long 0x00 17. " CCE ,Command CRC Error: Command CRC Error is generated in two cases." "0,1"
        textline "          "
        bitfld.long 0x00 18. " CEBE ,Command End Bit Error: Occurs when detecting that the end bit of a command response is 0." "0,1"
        textline "          "
        bitfld.long 0x00 19. " CIE ,Command Index Error: Occurs if a Command Index error occurs in the command response." "0,1"
        textline "          "
        bitfld.long 0x00 20. " DTOE ,Data Timeout Error: Occurs when detecting one of following time-out conditions." "0,1"
        textline "          "
        bitfld.long 0x00 21. " DCE ,Data CRC Error: Occurs when detecting a CRC error when transferring read data, which uses the DAT line, or when detecting the Write CRC status having a value other than 010." "0,1"
        textline "          "
        bitfld.long 0x00 22. " DEBE ,Data End Bit Error: Occurs either when detecting 0 at the end bit position of read data, which uses the DAT line, or at the end bit position of the CRC." "0,1"
        textline "          "
        bitfld.long 0x00 24. " AC12E ,Auto CMD12 Error: Occurs when detecting that one of the bits in the Auto CMD12 Error Status register has changed from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 26. " TNE ,Tuning Error: (only for SD3.0 SDR104 mode) This bit is set when an unrecoverable error is detected in a tuning circuit." "0,1"
        textline "          "
        bitfld.long 0x00 28. " DMAE ,DMA Error: Occurs when an Internal DMA transfer has failed." "0,1"
width 14.
group.long 0x34++0x3
    line.long 0x00 "INT_STATUS_EN,Interrupt Status Enable"
        bitfld.long 0x00 0. " CCSEN ,Command Complete Status Enable: 1 Enabled 0 Masked" "0,1"
        textline "             "
        bitfld.long 0x00 1. " TCSEN ,Transfer Complete Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 2. " BGESEN ,Block Gap Event Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 3. " DINTSEN ,DMA Interrupt Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 4. " BWRSEN ,Buffer Write Ready Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 5. " BRRSEN ,Buffer Read Ready Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 6. " CINSSEN ,Card Insertion Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 7. " CRMSEN ,Card Removal Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 8. " CINTSEN ,Card Interrupt Status Enable: If this bit is set to 0, the uSDHC will clear the interrupt request to the System." "0,1"
        textline "             "
        bitfld.long 0x00 12. " RTESEN ,Re-Tuning Event Status Enable" "0,1"
        textline "             "
        bitfld.long 0x00 14. " TPSEN ,Tuning Pass Status Enable" "0,1"
        textline "             "
        bitfld.long 0x00 16. " CTOESEN ,Command Timeout Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 17. " CCESEN ,Command CRC Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 18. " CEBESEN ,Command End Bit Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 19. " CIESEN ,Command Index Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 20. " DTOESEN ,Data Timeout Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 21. " DCESEN ,Data CRC Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 22. " DEBESEN ,Data End Bit Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 24. " AC12ESEN ,Auto CMD12 Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 26. " TNESEN ,Tuning Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 28. " DMAESEN ,DMA Error Status Enable:" "0,1"
width 14.
group.long 0x38++0x3
    line.long 0x00 "INT_SIGNAL_EN,Interrupt Signal Enable"
        bitfld.long 0x00 0. " CCIEN ,Command Complete Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 1. " TCIEN ,Transfer Complete Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 2. " BGEIEN ,Block Gap Event Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 3. " DINTIEN ,DMA Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 4. " BWRIEN ,Buffer Write Ready Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 5. " BRRIEN ,Buffer Read Ready Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 6. " CINSIEN ,Card Insertion Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 7. " CRMIEN ,Card Removal Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 8. " CINTIEN ,Card Interrupt Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 12. " RTEIEN ,Re-Tuning Event Interrupt Enable" "0,1"
        textline "             "
        bitfld.long 0x00 14. " TPIEN ,Tuning Pass Interrupt Enable" "0,1"
        textline "             "
        bitfld.long 0x00 16. " CTOEIEN ,Command Timeout Error Interrupt Enable" "0,1"
        textline "             "
        bitfld.long 0x00 17. " CCEIEN ,Command CRC Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 18. " CEBEIEN ,Command End Bit Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 19. " CIEIEN ,Command Index Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 20. " DTOEIEN ,Data Timeout Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 21. " DCEIEN ,Data CRC Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 22. " DEBEIEN ,Data End Bit Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 24. " AC12EIEN ,Auto CMD12 Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 26. " TNEIEN ,Tuning Error Interrupt Enable" "0,1"
        textline "             "
        bitfld.long 0x00 28. " DMAEIEN ,DMA Error Interrupt Enable:" "0,1"
width 21.
rgroup.long 0x3c++0x3
    line.long 0x00 "AUTOCMD12_ERR_STATUS,Auto CMD12 Error Status"
        bitfld.long 0x00 0. " AC12NE ,Auto CMD12 Not Executed: If memory multiple block data transfer is not started, due to a command error, this bit is not set because it is not necessary to issue an Auto CMD12." "0,1"
        textline "                    "
        bitfld.long 0x00 1. " AC12TOE ,Auto CMD12 Timeout Error: Occurs if no response is returned within 64 SDCLK cycles from the end bit of the command." "0,1"
        textline "                    "
        bitfld.long 0x00 2. " AC12EBE ,Auto CMD12 End Bit Error: Occurs when detecting that the end bit of command response is 0 which should be 1." "0,1"
        textline "                    "
        bitfld.long 0x00 3. " AC12CE ,Auto CMD12 CRC Error: Occurs when detecting a CRC error in the command response." "0,1"
        textline "                    "
        bitfld.long 0x00 4. " AC12IE ,Auto CMD12 Index Error: Occurs if the Command Index error occurs in response to a command." "0,1"
        textline "                    "
        bitfld.long 0x00 7. " CNIBAC12E ,Command Not Issued By Auto CMD12 Error: Setting this bit to 1 means CMD_wo_DAT is not executed due to an Auto CMD12 Error (D04-D01) in this register." "0,1"
        textline "                    "
        bitfld.long 0x00 22. " EXECUTE_TUNING ,Execute Tuning: When std_tuning_en bit is set, this bit is used to start tuning procedure." "0,1"
        textline "                    "
        bitfld.long 0x00 23. " SMP_CLK_SEL ,Sample Clock Select: When std_tuning_en bit is set, this bit is used to select sampling clock to receive CMD and DAT." "0,1"
width 14.
rgroup.long 0x40++0x3
    line.long 0x00 "HOST_CTRL_CAP,Host Controller Capabilities"
        bitfld.long 0x00 0. " SDR50_SUPPORT ,SDR50 support: This bit indicates support of SDR50 mode." "0,1"
        textline "             "
        bitfld.long 0x00 1. " SDR104_SUPPORT ,SDR104 support: This bit indicates support of SDR104 mode." "0,1"
        textline "             "
        bitfld.long 0x00 2. " DDR50_SUPPORT ,DDR50 support: This bit indicates support of DDR50 mode." "0,1"
        textline "             "
        hexmask.long.byte 0x00 8.--12. 1. " TIME_COUNT_RETUNING ,Time counter for retuning: This bit indicates an initial value of the Retuning Timer for Re-Tuning Mode1 and 3.Setting to 0 disables Retuning Timer."
        textline "             "
        bitfld.long 0x00 13. " USE_TUNING_SDR50 ,Use Tuning for SDR50: This bit is set to 1." "0,1"
        textline "             "
        hexmask.long.byte 0x00 14.--16. 1. " RETUNING_MODE ,Retuning Mode: This bit selects retuning method."
        textline "             "
        hexmask.long.byte 0x00 16.--19. 1. " MBL ,Max Block Length: This value indicates the maximum block size that the Host Driver can read and write to the buffer in the uSDHC."
        textline "             "
        bitfld.long 0x00 20. " ADMAS ,ADMA Support: This bit indicates whether the uSDHC supports the ADMA feature." "0,1"
        textline "             "
        bitfld.long 0x00 21. " HSS ,High Speed Support: This bit indicates whether the uSDHC supports High Speed mode and the Host System can supply a SD Clock frequency from 25 MHz to 50 MHz." "0,1"
        textline "             "
        bitfld.long 0x00 22. " DMAS ,DMA Support: This bit indicates whether the uSDHC is capable of using the internal DMA to transfer data between system memory and the data buffer directly." "0,1"
        textline "             "
        bitfld.long 0x00 23. " SRS ,Suspend / Resume Support: This bit indicates whether the uSDHC supports Suspend / Resume functionality." "0,1"
        textline "             "
        bitfld.long 0x00 24. " VS33 ,Voltage Support 3.3V: This bit shall depend on the Host System ability." "0,1"
        textline "             "
        bitfld.long 0x00 25. " VS30 ,Voltage Support 3.0V: This bit shall depend on the Host System ability." "0,1"
        textline "             "
        bitfld.long 0x00 26. " VS18 ,Voltage Support 1.8V: This bit shall depend on the Host System ability." "0,1"
width 9.
group.long 0x44++0x3
    line.long 0x00 "WTMK_LVL,Watermark Level"
        hexmask.long.byte 0x00 0.--8. 1. " RD_WML ,Read Watermark Level: The number of words used as the watermark level (FIFO threshold) in a DMA read operation."
        textline "        "
        hexmask.long.byte 0x00 8.--13. 1. " RD_BRST_LEN ,Read Burst Length: Due to system restriction, the actual burst length may not exceed 16."
        textline "        "
        hexmask.long.byte 0x00 16.--24. 1. " WR_WML ,Write Watermark Level: The number of words used as the watermark level (FIFO threshold) in a DMA write operation."
        textline "        "
        hexmask.long.byte 0x00 24.--29. 1. " WR_BRST_LEN ,Write Burst Length: Due to system restriction, the actual burst length may not exceed 16."
width 9.
group.long 0x48++0x3
    line.long 0x00 "MIX_CTRL,Mixer Control"
        bitfld.long 0x00 0. " DMAEN ,DMA Enable: This bit enables DMA functionality." "0,1"
        textline "        "
        bitfld.long 0x00 1. " BCEN ,Block Count Enable: This bit is used to enable the Block Count register, which is only relevant for multiple block transfers." "0,1"
        textline "        "
        bitfld.long 0x00 2. " AC12EN ,Auto CMD12 Enable: Multiple block transfers for memory require a CMD12 to stop the transaction." "0,1"
        textline "        "
        bitfld.long 0x00 3. " DDR_EN ,Dual Data Rate mode selection" "0,1"
        textline "        "
        bitfld.long 0x00 4. " DTDSEL ,Data Transfer Direction Select: This bit defines the direction of DAT line data transfers." "0,1"
        textline "        "
        bitfld.long 0x00 5. " MSBSEL ,Multi / Single Block Select: This bit enables multiple block DAT line data transfers." "0,1"
        textline "        "
        bitfld.long 0x00 6. " NIBBLE_POS ,In DDR 4-bit mode nibble position indictation." "0,1"
        textline "        "
        bitfld.long 0x00 7. " AC23EN ,Auto CMD23 Enable When this bit is set to 1, the Host Controller issues a CMD23 automatically before issuing a command specified in the Command Register." "0,1"
        textline "        "
        bitfld.long 0x00 22. " EXE_TUNE ,Execute Tuning: (Only used for SD3.0, SDR104 mode) When std_tuning_en is 0, this bit is set to 1 to indicate the Host Driver is starting tuning procedure." "0,1"
        textline "        "
        bitfld.long 0x00 23. " SMP_CLK_SEL ,When std_tuning_en is 0, this bit is used to select Tuned clock or Fixed clock to sample data/cmd (Only used for SD3.0, SDR104 mode)" "0,1"
        textline "        "
        bitfld.long 0x00 24. " AUTO_TUNE_EN ,Auto tuning enable (Only used for SD3.0, SDR104 mode)" "0,1"
        textline "        "
        bitfld.long 0x00 25. " FBCLK_SEL ,Feedback clock source selection (Only used for SD3.0, SDR104 mode)" "0,1"
width 12.
wgroup.long 0x50++0x3
    line.long 0x00 "FORCE_EVENT,Force Event"
        bitfld.long 0x00 0. " FEVTAC12NE ,Force Event Auto Command 12 Not Executed: Forces the AC12NE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 1. " FEVTAC12TOE ,Force Event Auto Command 12 Time Out Error: Forces the AC12TOE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 2. " FEVTAC12CE ,Force Event Auto Command 12 CRC Error: Forces the AC12CE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 3. " FEVTAC12EBE ,Force Event Auto Command 12 End Bit Error: Forces the AC12EBE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 4. " FEVTAC12IE ,Force Event Auto Command 12 Index Error: Forces the AC12IE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 7. " FEVTCNIBAC12E ,Force Event Command Not Executed By Auto Command 12 Error: Forces the CNIBAC12E bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 16. " FEVTCTOE ,Force Event Command Time Out Error: Forces the CTOE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 17. " FEVTCCE ,Force Event Command CRC Error: Forces the CCE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 18. " FEVTCEBE ,Force Event Command End Bit Error: Forces the CEBE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 19. " FEVTCIE ,Force Event Command Index Error: Forces the CCE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 20. " FEVTDTOE ,Force Event Data Time Out Error: Force the DTOE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 21. " FEVTDCE ,Force Event Data CRC Error: Forces the DCE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 22. " FEVTDEBE ,Force Event Data End Bit Error: Forces the DEBE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 24. " FEVTAC12E ,Force Event Auto Command 12 Error: Forces the AC12E bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 26. " FEVTTNE ,Force Tuning Error: Forces the TNE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 28. " FEVTDMAE ,Force Event DMA Error: Forces the DMAE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 31. " FEVTCINT ,Force Event Card Interrupt: Writing 1 to this bit generates a short low-level pulse on the internal DAT[1] line, as if a self clearing interrupt was received from the external card." "0,1"
width 16.
rgroup.long 0x54++0x3
    line.long 0x00 "ADMA_ERR_STATUS,ADMA Error Status Register"
        hexmask.long.byte 0x00 0.--2. 1. " ADMAES ,ADMA Error State (when ADMA Error is occurred.): This field indicates the state of the ADMA when an error has occurred during an ADMA data transfer."
        textline "               "
        bitfld.long 0x00 2. " ADMALME ,ADMA Length Mismatch Error: This error occurs in the following 2 cases: While the Block Count Enable is being set, the total data length specified by the Descriptor table is different from that specified by the Block Count and Block Length Total data length can not be divided by the block length" "0,1"
        textline "               "
        bitfld.long 0x00 3. " ADMADCE ,ADMA Descritor Error: This error occurs when invalid descriptor fetched by ADMA:" "0,1"
width 14.
group.long 0x58++0x3
    line.long 0x00 "ADMA_SYS_ADDR,ADMA System Address"
        hexmask.long.long 0x00 2.--32. 1. " ADS_ADDR ,ADMA System Address: This register holds the word address of the executing command in the Descriptor table."
width 9.
group.long 0x60++0x3
    line.long 0x00 "DLL_CTRL,DLL (Delay Line) Control"
        bitfld.long 0x00 0. " DLL_CTRL_ENABLE ,Set this bit to 1 to enable the DLL and delay chain; otherwise; set to 0 to bypasses DLL." "0,1"
        textline "        "
        bitfld.long 0x00 1. " DLL_CTRL_RESET ,Setting this bit to 1 force a reset on DLL." "0,1"
        textline "        "
        bitfld.long 0x00 2. " DLL_CTRL_SLV_FORCE_UPD ,Setting this bit to 1, forces the slave delay line to update to the DLL calibrated value immediately." "0,1"
        textline "        "
        hexmask.long.byte 0x00 3.--7. 1. " DLL_CTRL_SLV_DLY_TARGET0 ,The delay target for the uSDHC loopback read clock can be programmed in 1/16th increments of an ref_clock half-period."
        textline "        "
        bitfld.long 0x00 7. " DLL_CTRL_GATE_UPDATE ,Set this bit to 1 to prevent the DLL from updating (since when clock_in exists, glitches may appear during DLL updates)." "0,1"
        textline "        "
        bitfld.long 0x00 8. " DLL_CTRL_SLV_OVERRIDE ,Set this bit to 1 to Enable manual override for slave delay chain using SLV_OVERRIDE_VAL; to set 0 to disable manual override." "0,1"
        textline "        "
        hexmask.long.byte 0x00 9.--16. 1. " DLL_CTRL_SLV_OVERRIDE_VAL ,When SLV_OVERRIDE=1 This field is used to select 1 of 128 physical taps manually."
        textline "        "
        hexmask.long.byte 0x00 16.--19. 1. " DLL_CTRL_SLV_DLY_TARGET1 ,Refer to DLL_CTRL_SLV_DLY_TARGET0 below."
        textline "        "
        hexmask.long.byte 0x00 20.--28. 1. " DLL_CTRL_SLV_UPDATE_INT ,Slave delay line update interval."
        textline "        "
        hexmask.long.byte 0x00 28.--32. 1. " DLL_CTRL_REF_UPDATE_INT ,DLL control loop update interval."
width 11.
rgroup.long 0x64++0x3
    line.long 0x00 "DLL_STATUS,DLL Status"
        bitfld.long 0x00 0. " DLL_STS_SLV_LOCK ,Slave delay-line lock status." "0,1"
        textline "          "
        bitfld.long 0x00 1. " DLL_STS_REF_LOCK ,Reference DLL lock status." "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--9. 1. " DLL_STS_SLV_SEL ,Slave delay line select status."
        textline "          "
        hexmask.long.byte 0x00 9.--16. 1. " DLL_STS_REF_SEL ,Reference delay line select taps."
width 21.
group.long 0x68++0x3
    line.long 0x00 "CLK_TUNE_CTRL_STATUS,CLK Tuning Control and Status"
        hexmask.long.byte 0x00 0.--4. 1. " DLY_CELL_SET_POST ,Set the number of delay cells on the feedback clock between CLK_OUT and CLK_POST."
        textline "                    "
        hexmask.long.byte 0x00 4.--8. 1. " DLY_CELL_SET_OUT ,Set the number of delay cells on the feedback clock between CLK_PRE and CLK_OUT."
        textline "                    "
        hexmask.long.byte 0x00 8.--15. 1. " DLY_CELL_SET_PRE ,Set the number of delay cells on the feedback clock between the feedback clock and CLK_PRE."
        textline "                    "
        bitfld.long 0x00 15. " NXT_ERR ,NXT error which means the number of delay cells added on the feedback clock is too large." "0,1"
        textline "                    "
        hexmask.long.byte 0x00 16.--20. 1. " TAP_SEL_POST ,Reflect the number of delay cells added on the feedback clock between CLK_OUT and CLK_POST."
        textline "                    "
        hexmask.long.byte 0x00 20.--24. 1. " TAP_SEL_OUT ,Reflect the number of delay cells added on the feedback clock between CLK_PRE and CLK_OUT."
        textline "                    "
        hexmask.long.byte 0x00 24.--31. 1. " TAP_SEL_PRE ,Reflects the number of delay cells added on the feedback clock between the feedback clock and CLK_PRE."
        textline "                    "
        bitfld.long 0x00 31. " PRE_ERR ,PRE error which means the number of delay cells added on the feedback clock is too small." "0,1"
width 10.
group.long 0xc0++0x3
    line.long 0x00 "VEND_SPEC,Vendor Specific Register"
        bitfld.long 0x00 0. " EXT_DMA_EN ,External DMA Request Enable Enable the request to external DMA." "0,1"
        textline "         "
        bitfld.long 0x00 1. " VSELECT ,Voltage Selection Change the value of output signal VSELECT, to control the voltage on pads for external card." "0,1"
        textline "         "
        bitfld.long 0x00 2. " CONFLICT_CHK_EN ,It's not implemented in uSDHC IP." "0,1"
        textline "         "
        bitfld.long 0x00 3. " AC12_WR_CHKBUSY_EN ,Check busy enable after auto CMD12 for write data packet" "0,1"
        textline "         "
        bitfld.long 0x00 4. " DAT3_CD_POL ,Only for debug." "0,1"
        textline "         "
        bitfld.long 0x00 5. " CD_POL ,Only for debug." "0,1"
        textline "         "
        bitfld.long 0x00 6. " WP_POL ,Only for debug." "0,1"
        textline "         "
        bitfld.long 0x00 7. " CLKONJ_IN_ABORT ,Only for debug." "0,1"
        textline "         "
        bitfld.long 0x00 8. " FRC_SDCLK_ON ,Force CLK output active:" "0,1"
        textline "         "
        bitfld.long 0x00 11. " IPG_CLK_SOFT_EN ,IPG_CLK software enable" "0,1"
        textline "         "
        bitfld.long 0x00 12. " HCLK_SOFT_EN ,Please note, hardware auto-enables the AHB clock when the internal DMA is enabled even if HCLK_SOFT_EN is 0." "0,1"
        textline "         "
        bitfld.long 0x00 13. " IPG_PERCLK_SOFT_EN ,ipg_perclk software enable" "0,1"
        textline "         "
        bitfld.long 0x00 14. " CARD_CLK_SOFT_EN ,card clock software enable" "0,1"
        textline "         "
        bitfld.long 0x00 15. " CRC_CHK_DIS ,CRC check disable" "0,1"
        textline "         "
        hexmask.long.byte 0x00 16.--24. 1. " INT_ST_VAL ,Internal State Value Internal state value, reflecting the corresponding state value selected by Debug Select field."
width 9.
group.long 0xc4++0x3
    line.long 0x00 "MMC_BOOT,MMC Boot Register"
        hexmask.long.byte 0x00 0.--4. 1. " DTOCV_ACK ,Boot ACK time out counter value."
        textline "        "
        bitfld.long 0x00 4. " BOOT_ACK ,Boot ack mode select." "0,1"
        textline "        "
        bitfld.long 0x00 5. " BOOT_MODE ,Boot mode select." "0,1"
        textline "        "
        bitfld.long 0x00 6. " BOOT_EN ,Boot mode enable." "0,1"
        textline "        "
        bitfld.long 0x00 7. " AUTO_SABG_EN ,During boot, enable auto stop at block gap function." "0,1"
        textline "        "
        bitfld.long 0x00 8. " DISABLE_TIME_OUT ,Please note, when this bit is set, there is no timeout check no matter whether boot_en is set or not." "0,1"
        textline "        "
        hexmask.long.word 0x00 16.--32. 1. " BOOT_BLK_CNT ,The value defines the Stop At Block Gap value of automatic mode."
width 11.
group.long 0xc8++0x3
    line.long 0x00 "VEND_SPEC2,Vendor Specific 2 Register"
        bitfld.long 0x00 0. " SDR104_TIMING_DIS ,Timeout counter test." "0,1"
        textline "          "
        bitfld.long 0x00 1. " SDR104_OE_DIS ,CMD_OE/DAT_OE logic generation test." "0,1"
        textline "          "
        bitfld.long 0x00 2. " SDR104_NSD_DIS ,Interrupt window after abort command is sent." "0,1"
        textline "          "
        bitfld.long 0x00 3. " CARD_INT_D3_TEST ,Card interrupt detection test." "0,1"
        textline "          "
        bitfld.long 0x00 4. " TUNING_8BIT_EN ,Enable the auto tuning circuit to check the DAT[7:0]." "0,1"
        textline "          "
        bitfld.long 0x00 5. " TUNING_1BIT_EN ,Enable the auto tuning circuit to check the DAT0 only." "0,1"
        textline "          "
        bitfld.long 0x00 6. " TUNING_CMD_EN ,Enable the auto tuning circuit to check the CMD line." "0,1"
        textline "          "
        bitfld.long 0x00 7. " CARD_INT_AUTO_CLR_DIS ,Disable the feature to clear the Card interrupt status bit when Card Interrupt status enable bit is cleared." "0,1"
width 12.
group.long 0xcc++0x3
    line.long 0x00 "TUNING_CTRL,Tuning Control Register"
        hexmask.long.byte 0x00 0.--8. 1. " TUNING_START_TAP ,The start dealy cell point when send first CMD19 in tuning procedure."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " TUNING_COUNTER ,The MAX repeat CMD19 times in tuning procedure."
        textline "           "
        hexmask.long.byte 0x00 16.--19. 1. " TUNING_STEP ,The increasing delay cell step in tuning procedure."
        textline "           "
        hexmask.long.byte 0x00 20.--23. 1. " TUNING_WINDOW ,Select data window value for auto tuning"
        textline "           "
        bitfld.long 0x00 24. " STD_TUNING_EN ,Standard tuning circuit and procedure enable: This bit is used to enable standard tuning circuit and procedure." "0,1"


    tree.end
    tree "USDHC3"
        base ad:0x02198000

width 8.
group.long 0x0++0x3
    line.long 0x00 "DS_ADDR,DMA System Address"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,DMA System Address: This register contains the 32-bit system memory address for a DMA transfer."
width 8.
group.long 0x4++0x3
    line.long 0x00 "BLK_ATT,Block Attributes"
        hexmask.long.word 0x00 0.--13. 1. " BLKSIZE ,Transfer Block Size: This register specifies the block size for block data transfers."
        textline "       "
        hexmask.long.word 0x00 16.--32. 1. " BLKCNT ,Blocks Count For Current Transfer: This register is enabled when the Block Count Enable bit in the Transfer Mode register is set to 1 and is valid only for multiple block transfers."
width 8.
group.long 0x8++0x3
    line.long 0x00 "CMD_ARG,Command Argument"
        hexmask.long.long 0x00 0.--32. 1. " CMDARG ,Command Argument: The SD/MMC Command Argument is specified as bits 39-8 of the Command Format in the SD or MMC Specification.This register is write protected when the Command Inhibit (CMD) bit in the Present State register is set."
width 12.
group.long 0xc++0x3
    line.long 0x00 "CMD_XFR_TYP,Command Transfer Type"
        hexmask.long.byte 0x00 16.--18. 1. " RSPTYP ,Response Type Select:"
        textline "           "
        bitfld.long 0x00 19. " CCCEN ,Command CRC Check Enable: If this bit is set to 1, the uSDHC shall check the CRC field in the response." "0,1"
        textline "           "
        bitfld.long 0x00 20. " CICEN ,Command Index Check Enable: If this bit is set to 1, the uSDHC will check the Index field in the response to see if it has the same value as the command index." "0,1"
        textline "           "
        bitfld.long 0x00 21. " DPSEL ,Data Present Select: This bit is set to 1 to indicate that data is present and shall be transferred using the DAT line." "0,1"
        textline "           "
        hexmask.long.byte 0x00 22.--24. 1. " CMDTYP ,Command Type: There are three types of special commands: Suspend, Resume and Abort."
        textline "           "
        hexmask.long.byte 0x00 24.--30. 1. " CMDINX ,Command Index: These bits shall be set to the command number that is specified in bits 45-40 of the Command-Format in the SD Memory Card Physical Layer Specification and SDIO Card Specification."
width 9.
rgroup.long 0x10++0x3
    line.long 0x00 "CMD_RSP0,Command Response0"
        hexmask.long.long 0x00 0.--32. 1. " CMDRSP0 ,Command Response 0: Refer to for the mapping of command responses from the SD Bus to this register for each response type."
width 9.
rgroup.long 0x14++0x3
    line.long 0x00 "CMD_RSP1,Command Response1"
        hexmask.long.long 0x00 0.--32. 1. " CMDRSP1 ,Command Response 1: Refer to for the mapping of command responses from the SD Bus to this register for each response type."
width 9.
rgroup.long 0x18++0x3
    line.long 0x00 "CMD_RSP2,Command Response2"
        hexmask.long.long 0x00 0.--32. 1. " CMDRSP2 ,Command Response 2: Refer to for the mapping of command responses from the SD Bus to this register for each response type."
width 9.
rgroup.long 0x1c++0x3
    line.long 0x00 "CMD_RSP3,Command Response3"
        hexmask.long.long 0x00 0.--32. 1. " CMDRSP3 ,Command Response 3: Refer to for the mapping of command responses from the SD Bus to this register for each response type."
width 19.
group.long 0x20++0x3
    line.long 0x00 "DATA_BUFF_ACC_PORT,Data Buffer Access Port"
        hexmask.long.long 0x00 0.--32. 1. " DATCONT ,Data Content: The Buffer Data Port register is for 32-bit data access by the ARM platform or the external DMA."
width 11.
rgroup.long 0x24++0x3
    line.long 0x00 "PRES_STATE,Present State"
        bitfld.long 0x00 0. " CIHB ,Command Inhibit (CMD): If this status bit is 0, it indicates that the CMD line is not in use and the uSDHC can issue a SD/MMC Command using the CMD line." "0,1"
        textline "          "
        bitfld.long 0x00 1. " CDIHB ,Command Inhibit (DAT): This status bit is generated if either the DAT Line Active or the Read Transfer Active is set to 1." "0,1"
        textline "          "
        bitfld.long 0x00 2. " DLA ,Data Line Active This status bit indicates whether one of the DAT lines on the SD Bus is in use." "0,1"
        textline "          "
        bitfld.long 0x00 3. " SDSTB ,SD Clock Stable This status bit indicates that the internal card clock is stable." "0,1"
        textline "          "
        bitfld.long 0x00 4. " IPGOFF ,ipg_clk Gated Off Internally: This status bit indicates that the ipg_clk is internally gated off." "0,1"
        textline "          "
        bitfld.long 0x00 5. " HCKOFF ,hclk Gated Off Internally: This status bit indicates that the hclk is internally gated off." "0,1"
        textline "          "
        bitfld.long 0x00 6. " PEROFF ,ipg_perclk Gated Off Internally: This status bit indicates that the ipg_perclk is internally gated off." "0,1"
        textline "          "
        bitfld.long 0x00 7. " SDOFF ,SD Clock Gated Off Internally: This status bit indicates that the SD Clock is internally gated off, because of buffer over/under-run or read pause without read wait assertion, or the driver set FRC_SDCLK_ON bit is 0 to stop the SD clock in idle status." "0,1"
        textline "          "
        bitfld.long 0x00 8. " WTA ,Write Transfer Active: This status bit indicates a write transfer is active." "0,1"
        textline "          "
        bitfld.long 0x00 9. " RTA ,Read Transfer Active: This status bit is used for detecting completion of a read transfer." "0,1"
        textline "          "
        bitfld.long 0x00 10. " BWEN ,Buffer Write Enable: This status bit is used for non-DMA write transfers." "0,1"
        textline "          "
        bitfld.long 0x00 11. " BREN ,Buffer Read Enable: This status bit is used for non-DMA read transfers." "0,1"
        textline "          "
        bitfld.long 0x00 12. " RTR ,Re-Tuning Request: (only for SD3.0 SDR104 mode) Host Controller may request Host Driver to execute re-tuning sequence by setting this bit when the data window is shifted by temperature drift and a tuned sampling point does not have a good margin to receive correct data." "0,1"
        textline "          "
        bitfld.long 0x00 15. " TSCD ,Tape Select Change Done : This bit indicates the dealy setting is effective after write CLK_TUNE_CTRL_STATUS register." "0,1"
        textline "          "
        bitfld.long 0x00 16. " CINST ,Card Inserted: This bit indicates whether a card has been inserted." "0,1"
        textline "          "
        bitfld.long 0x00 18. " CDPL ,Card Detect Pin Level: This bit reflects the inverse value of the CD# pin for the card socket." "0,1"
        textline "          "
        bitfld.long 0x00 19. " WPSPL ,Write Protect Switch Pin Level: The Write Protect Switch is supported for memory and combo cards.This bit reflects the inverted value of the WP pin of the card socket." "0,1"
        textline "          "
        bitfld.long 0x00 23. " CLSL ,CMD Line Signal Level: This status is used to check the CMD line level to recover from errors, and for debugging." "0,1"
        textline "          "
        hexmask.long.byte 0x00 24.--32. 1. " DLSL ,DAT[7:0] Line Signal Level: This status is used to check the DAT line level to recover from errors, and for debugging.This is especially useful in detecting the busy signal level from DAT[0]."
width 10.
group.long 0x28++0x3
    line.long 0x00 "PROT_CTRL,Protocol Control"
        bitfld.long 0x00 0. " LCTL ,LED Control: This bit, fully controlled by the Host Driver, is used to caution the user not to remove the card while the card is being accessed." "0,1"
        textline "         "
        hexmask.long.byte 0x00 1.--3. 1. " DTW ,Data Transfer Width: This bit selects the data width of the SD bus for a data transfer."
        textline "         "
        bitfld.long 0x00 3. " D3CD ,DAT3 as Card Detection Pin: If this bit is set, DAT3 should be pulled down to act as a card detection pin." "0,1"
        textline "         "
        hexmask.long.byte 0x00 4.--6. 1. " EMODE ,Endian Mode: The uSDHC supports all three endian modes in data transfer."
        textline "         "
        bitfld.long 0x00 6. " CDTL ,Card Detect Test Level: This is bit is enabled while the Card Detection Signal Selection is set to 1 and it indicates card insertion." "0,1"
        textline "         "
        bitfld.long 0x00 7. " CDSS ,Card Detect Signal Selection: This bit selects the source for the card detection." "0,1"
        textline "         "
        hexmask.long.byte 0x00 8.--10. 1. " DMASEL ,DMA Select: This field is valid while DMA (SDMA or ADMA) is enabled and selects the DMA operation."
        textline "         "
        bitfld.long 0x00 16. " SABGREQ ,Stop At Block Gap Request: This bit is used to stop executing a transaction at the next block gap for both DMA and non-DMA transfers." "0,1"
        textline "         "
        bitfld.long 0x00 17. " CREQ ,Continue Request: This bit is used to restart a transaction which was stopped using the Stop At Block Gap Request." "0,1"
        textline "         "
        bitfld.long 0x00 18. " RWCTL ,Read Wait Control: The read wait function is optional for SDIO cards." "0,1"
        textline "         "
        bitfld.long 0x00 19. " IABG ,Interrupt At Block Gap: This bit is valid only in 4-bit mode, of the SDIO card, and selects a sample point in the interrupt cycle." "0,1"
        textline "         "
        bitfld.long 0x00 20. " RD_DONE_NO_8CLK ,Read done no 8 clock: According to the SD/MMC spec, for read data transaction, 8 clocks are needed after the end bit of the last data block." "0,1"
        textline "         "
        bitfld.long 0x00 24. " WECINT ,Wakeup Event Enable On Card Interrupt: This bit enables a wakeup event, via a Card Interrupt, in the Interrupt Status register." "0,1"
        textline "         "
        bitfld.long 0x00 25. " WECINS ,Wakeup Event Enable On SD Card Insertion: This bit enables a wakeup event, via a Card Insertion, in the Interrupt Status register." "0,1"
        textline "         "
        bitfld.long 0x00 26. " WECRM ,Wakeup Event Enable On SD Card Removal: This bit enables a wakeup event, via a Card Removal, in the Interrupt Status register." "0,1"
        textline "         "
        hexmask.long.byte 0x00 27.--30. 1. " BURST_LEN_EN ,BURST length enable for INCR, INCR4/INCR8/INCR16, INCR4-WRAP/INCR8-WRAP/INCR16-WRAP This is used to enable/disable the burst length for the external AHB2AXI bridge."
        textline "         "
        bitfld.long 0x00 30. " NON_EXACT_BLK_RD ,Current block read is non-exact block read." "0,1"
width 9.
group.long 0x2c++0x3
    line.long 0x00 "SYS_CTRL,System Control"
        hexmask.long.byte 0x00 4.--8. 1. " DVS ,Divisor: This register is used to provide a more exact divisor to generate the desired SD clock frequency."
        textline "        "
        hexmask.long.byte 0x00 8.--16. 1. " SDCLKFS ,SDCLK Frequency Select: This register is used to select the frequency of the SDCLK pin."
        textline "        "
        hexmask.long.byte 0x00 16.--20. 1. " DTOCV ,Data Timeout Counter Value: This value determines the interval by which DAT line timeouts are detected."
        textline "        "
        bitfld.long 0x00 23. " IPP_RST_N ,This register's value will be output to CARD from pad directly for hardware reset of the card if the card supports this feature." "0,1"
        textline "        "
        bitfld.long 0x00 24. " RSTA ,Software Reset For ALL: This reset effects the entire Host Controller except for the card detection circuit." "0,1"
        textline "        "
        bitfld.long 0x00 25. " RSTC ,Software Reset For CMD Line: Only part of the command circuit is reset." "0,1"
        textline "        "
        bitfld.long 0x00 26. " RSTD ,Software Reset For DAT Line: Only part of the data circuit is reset." "0,1"
        textline "        "
        bitfld.long 0x00 27. " INITA ,Initialization Active: When this bit is set, 80 SD-Clocks are sent to the card." "0,1"
        textline "        "
        bitfld.long 0x00 28. " RSTT ,Reset Tuning: When set this bit to 1, it will reset tuning circuit." "0,1"
width 11.
group.long 0x30++0x3
    line.long 0x00 "INT_STATUS,Interrupt Status"
        bitfld.long 0x00 0. " CC ,Command Complete: This bit is set when you receive the end bit of the command response (except Auto CMD12)." "0,1"
        textline "          "
        bitfld.long 0x00 1. " TC ,Transfer Complete: This bit is set when a read or write transfer is completed." "0,1"
        textline "          "
        bitfld.long 0x00 2. " BGE ,Block Gap Event: If the Stop At Block Gap Request bit in the Protocol Control register is set, this bit is set when a read or write transaction is stopped at a block gap." "0,1"
        textline "          "
        bitfld.long 0x00 3. " DINT ,DMA Interrupt: Occurs only when the internal DMA finishes the data transfer successfully." "0,1"
        textline "          "
        bitfld.long 0x00 4. " BWR ,Buffer Write Ready: This status bit is set if the Buffer Write Enable bit, in the Present State register, changes from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 5. " BRR ,Buffer Read Ready: This status bit is set if the Buffer Read Enable bit, in the Present State register, changes from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 6. " CINS ,Card Insertion: This status bit is set if the Card Inserted bit in the Present State register changes from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 7. " CRM ,Card Removal: This status bit is set if the Card Inserted bit in the Present State register changes from 1 to 0." "0,1"
        textline "          "
        bitfld.long 0x00 8. " CINT ,Card Interrupt: This status bit is set when an interrupt signal is detected from the external card." "0,1"
        textline "          "
        bitfld.long 0x00 12. " RTE ,Re-Tuning Event: (only for SD3.0 SDR104 mode) This status is set if Re-Tuning Request in the Present State register changes from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 14. " TP ,Tuning Pass:(only for SD3.0 SDR104 mode) Current CMD19 transfer is done successfully." "0,1"
        textline "          "
        bitfld.long 0x00 16. " CTOE ,Command Timeout Error: Occurs only if no response is returned within 64 SDCLK cycles from the end bit of the command." "0,1"
        textline "          "
        bitfld.long 0x00 17. " CCE ,Command CRC Error: Command CRC Error is generated in two cases." "0,1"
        textline "          "
        bitfld.long 0x00 18. " CEBE ,Command End Bit Error: Occurs when detecting that the end bit of a command response is 0." "0,1"
        textline "          "
        bitfld.long 0x00 19. " CIE ,Command Index Error: Occurs if a Command Index error occurs in the command response." "0,1"
        textline "          "
        bitfld.long 0x00 20. " DTOE ,Data Timeout Error: Occurs when detecting one of following time-out conditions." "0,1"
        textline "          "
        bitfld.long 0x00 21. " DCE ,Data CRC Error: Occurs when detecting a CRC error when transferring read data, which uses the DAT line, or when detecting the Write CRC status having a value other than 010." "0,1"
        textline "          "
        bitfld.long 0x00 22. " DEBE ,Data End Bit Error: Occurs either when detecting 0 at the end bit position of read data, which uses the DAT line, or at the end bit position of the CRC." "0,1"
        textline "          "
        bitfld.long 0x00 24. " AC12E ,Auto CMD12 Error: Occurs when detecting that one of the bits in the Auto CMD12 Error Status register has changed from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 26. " TNE ,Tuning Error: (only for SD3.0 SDR104 mode) This bit is set when an unrecoverable error is detected in a tuning circuit." "0,1"
        textline "          "
        bitfld.long 0x00 28. " DMAE ,DMA Error: Occurs when an Internal DMA transfer has failed." "0,1"
width 14.
group.long 0x34++0x3
    line.long 0x00 "INT_STATUS_EN,Interrupt Status Enable"
        bitfld.long 0x00 0. " CCSEN ,Command Complete Status Enable: 1 Enabled 0 Masked" "0,1"
        textline "             "
        bitfld.long 0x00 1. " TCSEN ,Transfer Complete Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 2. " BGESEN ,Block Gap Event Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 3. " DINTSEN ,DMA Interrupt Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 4. " BWRSEN ,Buffer Write Ready Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 5. " BRRSEN ,Buffer Read Ready Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 6. " CINSSEN ,Card Insertion Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 7. " CRMSEN ,Card Removal Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 8. " CINTSEN ,Card Interrupt Status Enable: If this bit is set to 0, the uSDHC will clear the interrupt request to the System." "0,1"
        textline "             "
        bitfld.long 0x00 12. " RTESEN ,Re-Tuning Event Status Enable" "0,1"
        textline "             "
        bitfld.long 0x00 14. " TPSEN ,Tuning Pass Status Enable" "0,1"
        textline "             "
        bitfld.long 0x00 16. " CTOESEN ,Command Timeout Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 17. " CCESEN ,Command CRC Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 18. " CEBESEN ,Command End Bit Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 19. " CIESEN ,Command Index Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 20. " DTOESEN ,Data Timeout Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 21. " DCESEN ,Data CRC Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 22. " DEBESEN ,Data End Bit Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 24. " AC12ESEN ,Auto CMD12 Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 26. " TNESEN ,Tuning Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 28. " DMAESEN ,DMA Error Status Enable:" "0,1"
width 14.
group.long 0x38++0x3
    line.long 0x00 "INT_SIGNAL_EN,Interrupt Signal Enable"
        bitfld.long 0x00 0. " CCIEN ,Command Complete Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 1. " TCIEN ,Transfer Complete Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 2. " BGEIEN ,Block Gap Event Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 3. " DINTIEN ,DMA Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 4. " BWRIEN ,Buffer Write Ready Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 5. " BRRIEN ,Buffer Read Ready Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 6. " CINSIEN ,Card Insertion Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 7. " CRMIEN ,Card Removal Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 8. " CINTIEN ,Card Interrupt Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 12. " RTEIEN ,Re-Tuning Event Interrupt Enable" "0,1"
        textline "             "
        bitfld.long 0x00 14. " TPIEN ,Tuning Pass Interrupt Enable" "0,1"
        textline "             "
        bitfld.long 0x00 16. " CTOEIEN ,Command Timeout Error Interrupt Enable" "0,1"
        textline "             "
        bitfld.long 0x00 17. " CCEIEN ,Command CRC Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 18. " CEBEIEN ,Command End Bit Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 19. " CIEIEN ,Command Index Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 20. " DTOEIEN ,Data Timeout Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 21. " DCEIEN ,Data CRC Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 22. " DEBEIEN ,Data End Bit Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 24. " AC12EIEN ,Auto CMD12 Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 26. " TNEIEN ,Tuning Error Interrupt Enable" "0,1"
        textline "             "
        bitfld.long 0x00 28. " DMAEIEN ,DMA Error Interrupt Enable:" "0,1"
width 21.
rgroup.long 0x3c++0x3
    line.long 0x00 "AUTOCMD12_ERR_STATUS,Auto CMD12 Error Status"
        bitfld.long 0x00 0. " AC12NE ,Auto CMD12 Not Executed: If memory multiple block data transfer is not started, due to a command error, this bit is not set because it is not necessary to issue an Auto CMD12." "0,1"
        textline "                    "
        bitfld.long 0x00 1. " AC12TOE ,Auto CMD12 Timeout Error: Occurs if no response is returned within 64 SDCLK cycles from the end bit of the command." "0,1"
        textline "                    "
        bitfld.long 0x00 2. " AC12EBE ,Auto CMD12 End Bit Error: Occurs when detecting that the end bit of command response is 0 which should be 1." "0,1"
        textline "                    "
        bitfld.long 0x00 3. " AC12CE ,Auto CMD12 CRC Error: Occurs when detecting a CRC error in the command response." "0,1"
        textline "                    "
        bitfld.long 0x00 4. " AC12IE ,Auto CMD12 Index Error: Occurs if the Command Index error occurs in response to a command." "0,1"
        textline "                    "
        bitfld.long 0x00 7. " CNIBAC12E ,Command Not Issued By Auto CMD12 Error: Setting this bit to 1 means CMD_wo_DAT is not executed due to an Auto CMD12 Error (D04-D01) in this register." "0,1"
        textline "                    "
        bitfld.long 0x00 22. " EXECUTE_TUNING ,Execute Tuning: When std_tuning_en bit is set, this bit is used to start tuning procedure." "0,1"
        textline "                    "
        bitfld.long 0x00 23. " SMP_CLK_SEL ,Sample Clock Select: When std_tuning_en bit is set, this bit is used to select sampling clock to receive CMD and DAT." "0,1"
width 14.
rgroup.long 0x40++0x3
    line.long 0x00 "HOST_CTRL_CAP,Host Controller Capabilities"
        bitfld.long 0x00 0. " SDR50_SUPPORT ,SDR50 support: This bit indicates support of SDR50 mode." "0,1"
        textline "             "
        bitfld.long 0x00 1. " SDR104_SUPPORT ,SDR104 support: This bit indicates support of SDR104 mode." "0,1"
        textline "             "
        bitfld.long 0x00 2. " DDR50_SUPPORT ,DDR50 support: This bit indicates support of DDR50 mode." "0,1"
        textline "             "
        hexmask.long.byte 0x00 8.--12. 1. " TIME_COUNT_RETUNING ,Time counter for retuning: This bit indicates an initial value of the Retuning Timer for Re-Tuning Mode1 and 3.Setting to 0 disables Retuning Timer."
        textline "             "
        bitfld.long 0x00 13. " USE_TUNING_SDR50 ,Use Tuning for SDR50: This bit is set to 1." "0,1"
        textline "             "
        hexmask.long.byte 0x00 14.--16. 1. " RETUNING_MODE ,Retuning Mode: This bit selects retuning method."
        textline "             "
        hexmask.long.byte 0x00 16.--19. 1. " MBL ,Max Block Length: This value indicates the maximum block size that the Host Driver can read and write to the buffer in the uSDHC."
        textline "             "
        bitfld.long 0x00 20. " ADMAS ,ADMA Support: This bit indicates whether the uSDHC supports the ADMA feature." "0,1"
        textline "             "
        bitfld.long 0x00 21. " HSS ,High Speed Support: This bit indicates whether the uSDHC supports High Speed mode and the Host System can supply a SD Clock frequency from 25 MHz to 50 MHz." "0,1"
        textline "             "
        bitfld.long 0x00 22. " DMAS ,DMA Support: This bit indicates whether the uSDHC is capable of using the internal DMA to transfer data between system memory and the data buffer directly." "0,1"
        textline "             "
        bitfld.long 0x00 23. " SRS ,Suspend / Resume Support: This bit indicates whether the uSDHC supports Suspend / Resume functionality." "0,1"
        textline "             "
        bitfld.long 0x00 24. " VS33 ,Voltage Support 3.3V: This bit shall depend on the Host System ability." "0,1"
        textline "             "
        bitfld.long 0x00 25. " VS30 ,Voltage Support 3.0V: This bit shall depend on the Host System ability." "0,1"
        textline "             "
        bitfld.long 0x00 26. " VS18 ,Voltage Support 1.8V: This bit shall depend on the Host System ability." "0,1"
width 9.
group.long 0x44++0x3
    line.long 0x00 "WTMK_LVL,Watermark Level"
        hexmask.long.byte 0x00 0.--8. 1. " RD_WML ,Read Watermark Level: The number of words used as the watermark level (FIFO threshold) in a DMA read operation."
        textline "        "
        hexmask.long.byte 0x00 8.--13. 1. " RD_BRST_LEN ,Read Burst Length: Due to system restriction, the actual burst length may not exceed 16."
        textline "        "
        hexmask.long.byte 0x00 16.--24. 1. " WR_WML ,Write Watermark Level: The number of words used as the watermark level (FIFO threshold) in a DMA write operation."
        textline "        "
        hexmask.long.byte 0x00 24.--29. 1. " WR_BRST_LEN ,Write Burst Length: Due to system restriction, the actual burst length may not exceed 16."
width 9.
group.long 0x48++0x3
    line.long 0x00 "MIX_CTRL,Mixer Control"
        bitfld.long 0x00 0. " DMAEN ,DMA Enable: This bit enables DMA functionality." "0,1"
        textline "        "
        bitfld.long 0x00 1. " BCEN ,Block Count Enable: This bit is used to enable the Block Count register, which is only relevant for multiple block transfers." "0,1"
        textline "        "
        bitfld.long 0x00 2. " AC12EN ,Auto CMD12 Enable: Multiple block transfers for memory require a CMD12 to stop the transaction." "0,1"
        textline "        "
        bitfld.long 0x00 3. " DDR_EN ,Dual Data Rate mode selection" "0,1"
        textline "        "
        bitfld.long 0x00 4. " DTDSEL ,Data Transfer Direction Select: This bit defines the direction of DAT line data transfers." "0,1"
        textline "        "
        bitfld.long 0x00 5. " MSBSEL ,Multi / Single Block Select: This bit enables multiple block DAT line data transfers." "0,1"
        textline "        "
        bitfld.long 0x00 6. " NIBBLE_POS ,In DDR 4-bit mode nibble position indictation." "0,1"
        textline "        "
        bitfld.long 0x00 7. " AC23EN ,Auto CMD23 Enable When this bit is set to 1, the Host Controller issues a CMD23 automatically before issuing a command specified in the Command Register." "0,1"
        textline "        "
        bitfld.long 0x00 22. " EXE_TUNE ,Execute Tuning: (Only used for SD3.0, SDR104 mode) When std_tuning_en is 0, this bit is set to 1 to indicate the Host Driver is starting tuning procedure." "0,1"
        textline "        "
        bitfld.long 0x00 23. " SMP_CLK_SEL ,When std_tuning_en is 0, this bit is used to select Tuned clock or Fixed clock to sample data/cmd (Only used for SD3.0, SDR104 mode)" "0,1"
        textline "        "
        bitfld.long 0x00 24. " AUTO_TUNE_EN ,Auto tuning enable (Only used for SD3.0, SDR104 mode)" "0,1"
        textline "        "
        bitfld.long 0x00 25. " FBCLK_SEL ,Feedback clock source selection (Only used for SD3.0, SDR104 mode)" "0,1"
width 12.
wgroup.long 0x50++0x3
    line.long 0x00 "FORCE_EVENT,Force Event"
        bitfld.long 0x00 0. " FEVTAC12NE ,Force Event Auto Command 12 Not Executed: Forces the AC12NE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 1. " FEVTAC12TOE ,Force Event Auto Command 12 Time Out Error: Forces the AC12TOE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 2. " FEVTAC12CE ,Force Event Auto Command 12 CRC Error: Forces the AC12CE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 3. " FEVTAC12EBE ,Force Event Auto Command 12 End Bit Error: Forces the AC12EBE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 4. " FEVTAC12IE ,Force Event Auto Command 12 Index Error: Forces the AC12IE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 7. " FEVTCNIBAC12E ,Force Event Command Not Executed By Auto Command 12 Error: Forces the CNIBAC12E bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 16. " FEVTCTOE ,Force Event Command Time Out Error: Forces the CTOE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 17. " FEVTCCE ,Force Event Command CRC Error: Forces the CCE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 18. " FEVTCEBE ,Force Event Command End Bit Error: Forces the CEBE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 19. " FEVTCIE ,Force Event Command Index Error: Forces the CCE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 20. " FEVTDTOE ,Force Event Data Time Out Error: Force the DTOE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 21. " FEVTDCE ,Force Event Data CRC Error: Forces the DCE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 22. " FEVTDEBE ,Force Event Data End Bit Error: Forces the DEBE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 24. " FEVTAC12E ,Force Event Auto Command 12 Error: Forces the AC12E bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 26. " FEVTTNE ,Force Tuning Error: Forces the TNE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 28. " FEVTDMAE ,Force Event DMA Error: Forces the DMAE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 31. " FEVTCINT ,Force Event Card Interrupt: Writing 1 to this bit generates a short low-level pulse on the internal DAT[1] line, as if a self clearing interrupt was received from the external card." "0,1"
width 16.
rgroup.long 0x54++0x3
    line.long 0x00 "ADMA_ERR_STATUS,ADMA Error Status Register"
        hexmask.long.byte 0x00 0.--2. 1. " ADMAES ,ADMA Error State (when ADMA Error is occurred.): This field indicates the state of the ADMA when an error has occurred during an ADMA data transfer."
        textline "               "
        bitfld.long 0x00 2. " ADMALME ,ADMA Length Mismatch Error: This error occurs in the following 2 cases: While the Block Count Enable is being set, the total data length specified by the Descriptor table is different from that specified by the Block Count and Block Length Total data length can not be divided by the block length" "0,1"
        textline "               "
        bitfld.long 0x00 3. " ADMADCE ,ADMA Descritor Error: This error occurs when invalid descriptor fetched by ADMA:" "0,1"
width 14.
group.long 0x58++0x3
    line.long 0x00 "ADMA_SYS_ADDR,ADMA System Address"
        hexmask.long.long 0x00 2.--32. 1. " ADS_ADDR ,ADMA System Address: This register holds the word address of the executing command in the Descriptor table."
width 9.
group.long 0x60++0x3
    line.long 0x00 "DLL_CTRL,DLL (Delay Line) Control"
        bitfld.long 0x00 0. " DLL_CTRL_ENABLE ,Set this bit to 1 to enable the DLL and delay chain; otherwise; set to 0 to bypasses DLL." "0,1"
        textline "        "
        bitfld.long 0x00 1. " DLL_CTRL_RESET ,Setting this bit to 1 force a reset on DLL." "0,1"
        textline "        "
        bitfld.long 0x00 2. " DLL_CTRL_SLV_FORCE_UPD ,Setting this bit to 1, forces the slave delay line to update to the DLL calibrated value immediately." "0,1"
        textline "        "
        hexmask.long.byte 0x00 3.--7. 1. " DLL_CTRL_SLV_DLY_TARGET0 ,The delay target for the uSDHC loopback read clock can be programmed in 1/16th increments of an ref_clock half-period."
        textline "        "
        bitfld.long 0x00 7. " DLL_CTRL_GATE_UPDATE ,Set this bit to 1 to prevent the DLL from updating (since when clock_in exists, glitches may appear during DLL updates)." "0,1"
        textline "        "
        bitfld.long 0x00 8. " DLL_CTRL_SLV_OVERRIDE ,Set this bit to 1 to Enable manual override for slave delay chain using SLV_OVERRIDE_VAL; to set 0 to disable manual override." "0,1"
        textline "        "
        hexmask.long.byte 0x00 9.--16. 1. " DLL_CTRL_SLV_OVERRIDE_VAL ,When SLV_OVERRIDE=1 This field is used to select 1 of 128 physical taps manually."
        textline "        "
        hexmask.long.byte 0x00 16.--19. 1. " DLL_CTRL_SLV_DLY_TARGET1 ,Refer to DLL_CTRL_SLV_DLY_TARGET0 below."
        textline "        "
        hexmask.long.byte 0x00 20.--28. 1. " DLL_CTRL_SLV_UPDATE_INT ,Slave delay line update interval."
        textline "        "
        hexmask.long.byte 0x00 28.--32. 1. " DLL_CTRL_REF_UPDATE_INT ,DLL control loop update interval."
width 11.
rgroup.long 0x64++0x3
    line.long 0x00 "DLL_STATUS,DLL Status"
        bitfld.long 0x00 0. " DLL_STS_SLV_LOCK ,Slave delay-line lock status." "0,1"
        textline "          "
        bitfld.long 0x00 1. " DLL_STS_REF_LOCK ,Reference DLL lock status." "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--9. 1. " DLL_STS_SLV_SEL ,Slave delay line select status."
        textline "          "
        hexmask.long.byte 0x00 9.--16. 1. " DLL_STS_REF_SEL ,Reference delay line select taps."
width 21.
group.long 0x68++0x3
    line.long 0x00 "CLK_TUNE_CTRL_STATUS,CLK Tuning Control and Status"
        hexmask.long.byte 0x00 0.--4. 1. " DLY_CELL_SET_POST ,Set the number of delay cells on the feedback clock between CLK_OUT and CLK_POST."
        textline "                    "
        hexmask.long.byte 0x00 4.--8. 1. " DLY_CELL_SET_OUT ,Set the number of delay cells on the feedback clock between CLK_PRE and CLK_OUT."
        textline "                    "
        hexmask.long.byte 0x00 8.--15. 1. " DLY_CELL_SET_PRE ,Set the number of delay cells on the feedback clock between the feedback clock and CLK_PRE."
        textline "                    "
        bitfld.long 0x00 15. " NXT_ERR ,NXT error which means the number of delay cells added on the feedback clock is too large." "0,1"
        textline "                    "
        hexmask.long.byte 0x00 16.--20. 1. " TAP_SEL_POST ,Reflect the number of delay cells added on the feedback clock between CLK_OUT and CLK_POST."
        textline "                    "
        hexmask.long.byte 0x00 20.--24. 1. " TAP_SEL_OUT ,Reflect the number of delay cells added on the feedback clock between CLK_PRE and CLK_OUT."
        textline "                    "
        hexmask.long.byte 0x00 24.--31. 1. " TAP_SEL_PRE ,Reflects the number of delay cells added on the feedback clock between the feedback clock and CLK_PRE."
        textline "                    "
        bitfld.long 0x00 31. " PRE_ERR ,PRE error which means the number of delay cells added on the feedback clock is too small." "0,1"
width 10.
group.long 0xc0++0x3
    line.long 0x00 "VEND_SPEC,Vendor Specific Register"
        bitfld.long 0x00 0. " EXT_DMA_EN ,External DMA Request Enable Enable the request to external DMA." "0,1"
        textline "         "
        bitfld.long 0x00 1. " VSELECT ,Voltage Selection Change the value of output signal VSELECT, to control the voltage on pads for external card." "0,1"
        textline "         "
        bitfld.long 0x00 2. " CONFLICT_CHK_EN ,It's not implemented in uSDHC IP." "0,1"
        textline "         "
        bitfld.long 0x00 3. " AC12_WR_CHKBUSY_EN ,Check busy enable after auto CMD12 for write data packet" "0,1"
        textline "         "
        bitfld.long 0x00 4. " DAT3_CD_POL ,Only for debug." "0,1"
        textline "         "
        bitfld.long 0x00 5. " CD_POL ,Only for debug." "0,1"
        textline "         "
        bitfld.long 0x00 6. " WP_POL ,Only for debug." "0,1"
        textline "         "
        bitfld.long 0x00 7. " CLKONJ_IN_ABORT ,Only for debug." "0,1"
        textline "         "
        bitfld.long 0x00 8. " FRC_SDCLK_ON ,Force CLK output active:" "0,1"
        textline "         "
        bitfld.long 0x00 11. " IPG_CLK_SOFT_EN ,IPG_CLK software enable" "0,1"
        textline "         "
        bitfld.long 0x00 12. " HCLK_SOFT_EN ,Please note, hardware auto-enables the AHB clock when the internal DMA is enabled even if HCLK_SOFT_EN is 0." "0,1"
        textline "         "
        bitfld.long 0x00 13. " IPG_PERCLK_SOFT_EN ,ipg_perclk software enable" "0,1"
        textline "         "
        bitfld.long 0x00 14. " CARD_CLK_SOFT_EN ,card clock software enable" "0,1"
        textline "         "
        bitfld.long 0x00 15. " CRC_CHK_DIS ,CRC check disable" "0,1"
        textline "         "
        hexmask.long.byte 0x00 16.--24. 1. " INT_ST_VAL ,Internal State Value Internal state value, reflecting the corresponding state value selected by Debug Select field."
width 9.
group.long 0xc4++0x3
    line.long 0x00 "MMC_BOOT,MMC Boot Register"
        hexmask.long.byte 0x00 0.--4. 1. " DTOCV_ACK ,Boot ACK time out counter value."
        textline "        "
        bitfld.long 0x00 4. " BOOT_ACK ,Boot ack mode select." "0,1"
        textline "        "
        bitfld.long 0x00 5. " BOOT_MODE ,Boot mode select." "0,1"
        textline "        "
        bitfld.long 0x00 6. " BOOT_EN ,Boot mode enable." "0,1"
        textline "        "
        bitfld.long 0x00 7. " AUTO_SABG_EN ,During boot, enable auto stop at block gap function." "0,1"
        textline "        "
        bitfld.long 0x00 8. " DISABLE_TIME_OUT ,Please note, when this bit is set, there is no timeout check no matter whether boot_en is set or not." "0,1"
        textline "        "
        hexmask.long.word 0x00 16.--32. 1. " BOOT_BLK_CNT ,The value defines the Stop At Block Gap value of automatic mode."
width 11.
group.long 0xc8++0x3
    line.long 0x00 "VEND_SPEC2,Vendor Specific 2 Register"
        bitfld.long 0x00 0. " SDR104_TIMING_DIS ,Timeout counter test." "0,1"
        textline "          "
        bitfld.long 0x00 1. " SDR104_OE_DIS ,CMD_OE/DAT_OE logic generation test." "0,1"
        textline "          "
        bitfld.long 0x00 2. " SDR104_NSD_DIS ,Interrupt window after abort command is sent." "0,1"
        textline "          "
        bitfld.long 0x00 3. " CARD_INT_D3_TEST ,Card interrupt detection test." "0,1"
        textline "          "
        bitfld.long 0x00 4. " TUNING_8BIT_EN ,Enable the auto tuning circuit to check the DAT[7:0]." "0,1"
        textline "          "
        bitfld.long 0x00 5. " TUNING_1BIT_EN ,Enable the auto tuning circuit to check the DAT0 only." "0,1"
        textline "          "
        bitfld.long 0x00 6. " TUNING_CMD_EN ,Enable the auto tuning circuit to check the CMD line." "0,1"
        textline "          "
        bitfld.long 0x00 7. " CARD_INT_AUTO_CLR_DIS ,Disable the feature to clear the Card interrupt status bit when Card Interrupt status enable bit is cleared." "0,1"
width 12.
group.long 0xcc++0x3
    line.long 0x00 "TUNING_CTRL,Tuning Control Register"
        hexmask.long.byte 0x00 0.--8. 1. " TUNING_START_TAP ,The start dealy cell point when send first CMD19 in tuning procedure."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " TUNING_COUNTER ,The MAX repeat CMD19 times in tuning procedure."
        textline "           "
        hexmask.long.byte 0x00 16.--19. 1. " TUNING_STEP ,The increasing delay cell step in tuning procedure."
        textline "           "
        hexmask.long.byte 0x00 20.--23. 1. " TUNING_WINDOW ,Select data window value for auto tuning"
        textline "           "
        bitfld.long 0x00 24. " STD_TUNING_EN ,Standard tuning circuit and procedure enable: This bit is used to enable standard tuning circuit and procedure." "0,1"


    tree.end
    tree "USDHC4"
        base ad:0x0219c000

width 8.
group.long 0x0++0x3
    line.long 0x00 "DS_ADDR,DMA System Address"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,DMA System Address: This register contains the 32-bit system memory address for a DMA transfer."
width 8.
group.long 0x4++0x3
    line.long 0x00 "BLK_ATT,Block Attributes"
        hexmask.long.word 0x00 0.--13. 1. " BLKSIZE ,Transfer Block Size: This register specifies the block size for block data transfers."
        textline "       "
        hexmask.long.word 0x00 16.--32. 1. " BLKCNT ,Blocks Count For Current Transfer: This register is enabled when the Block Count Enable bit in the Transfer Mode register is set to 1 and is valid only for multiple block transfers."
width 8.
group.long 0x8++0x3
    line.long 0x00 "CMD_ARG,Command Argument"
        hexmask.long.long 0x00 0.--32. 1. " CMDARG ,Command Argument: The SD/MMC Command Argument is specified as bits 39-8 of the Command Format in the SD or MMC Specification.This register is write protected when the Command Inhibit (CMD) bit in the Present State register is set."
width 12.
group.long 0xc++0x3
    line.long 0x00 "CMD_XFR_TYP,Command Transfer Type"
        hexmask.long.byte 0x00 16.--18. 1. " RSPTYP ,Response Type Select:"
        textline "           "
        bitfld.long 0x00 19. " CCCEN ,Command CRC Check Enable: If this bit is set to 1, the uSDHC shall check the CRC field in the response." "0,1"
        textline "           "
        bitfld.long 0x00 20. " CICEN ,Command Index Check Enable: If this bit is set to 1, the uSDHC will check the Index field in the response to see if it has the same value as the command index." "0,1"
        textline "           "
        bitfld.long 0x00 21. " DPSEL ,Data Present Select: This bit is set to 1 to indicate that data is present and shall be transferred using the DAT line." "0,1"
        textline "           "
        hexmask.long.byte 0x00 22.--24. 1. " CMDTYP ,Command Type: There are three types of special commands: Suspend, Resume and Abort."
        textline "           "
        hexmask.long.byte 0x00 24.--30. 1. " CMDINX ,Command Index: These bits shall be set to the command number that is specified in bits 45-40 of the Command-Format in the SD Memory Card Physical Layer Specification and SDIO Card Specification."
width 9.
rgroup.long 0x10++0x3
    line.long 0x00 "CMD_RSP0,Command Response0"
        hexmask.long.long 0x00 0.--32. 1. " CMDRSP0 ,Command Response 0: Refer to for the mapping of command responses from the SD Bus to this register for each response type."
width 9.
rgroup.long 0x14++0x3
    line.long 0x00 "CMD_RSP1,Command Response1"
        hexmask.long.long 0x00 0.--32. 1. " CMDRSP1 ,Command Response 1: Refer to for the mapping of command responses from the SD Bus to this register for each response type."
width 9.
rgroup.long 0x18++0x3
    line.long 0x00 "CMD_RSP2,Command Response2"
        hexmask.long.long 0x00 0.--32. 1. " CMDRSP2 ,Command Response 2: Refer to for the mapping of command responses from the SD Bus to this register for each response type."
width 9.
rgroup.long 0x1c++0x3
    line.long 0x00 "CMD_RSP3,Command Response3"
        hexmask.long.long 0x00 0.--32. 1. " CMDRSP3 ,Command Response 3: Refer to for the mapping of command responses from the SD Bus to this register for each response type."
width 19.
group.long 0x20++0x3
    line.long 0x00 "DATA_BUFF_ACC_PORT,Data Buffer Access Port"
        hexmask.long.long 0x00 0.--32. 1. " DATCONT ,Data Content: The Buffer Data Port register is for 32-bit data access by the ARM platform or the external DMA."
width 11.
rgroup.long 0x24++0x3
    line.long 0x00 "PRES_STATE,Present State"
        bitfld.long 0x00 0. " CIHB ,Command Inhibit (CMD): If this status bit is 0, it indicates that the CMD line is not in use and the uSDHC can issue a SD/MMC Command using the CMD line." "0,1"
        textline "          "
        bitfld.long 0x00 1. " CDIHB ,Command Inhibit (DAT): This status bit is generated if either the DAT Line Active or the Read Transfer Active is set to 1." "0,1"
        textline "          "
        bitfld.long 0x00 2. " DLA ,Data Line Active This status bit indicates whether one of the DAT lines on the SD Bus is in use." "0,1"
        textline "          "
        bitfld.long 0x00 3. " SDSTB ,SD Clock Stable This status bit indicates that the internal card clock is stable." "0,1"
        textline "          "
        bitfld.long 0x00 4. " IPGOFF ,ipg_clk Gated Off Internally: This status bit indicates that the ipg_clk is internally gated off." "0,1"
        textline "          "
        bitfld.long 0x00 5. " HCKOFF ,hclk Gated Off Internally: This status bit indicates that the hclk is internally gated off." "0,1"
        textline "          "
        bitfld.long 0x00 6. " PEROFF ,ipg_perclk Gated Off Internally: This status bit indicates that the ipg_perclk is internally gated off." "0,1"
        textline "          "
        bitfld.long 0x00 7. " SDOFF ,SD Clock Gated Off Internally: This status bit indicates that the SD Clock is internally gated off, because of buffer over/under-run or read pause without read wait assertion, or the driver set FRC_SDCLK_ON bit is 0 to stop the SD clock in idle status." "0,1"
        textline "          "
        bitfld.long 0x00 8. " WTA ,Write Transfer Active: This status bit indicates a write transfer is active." "0,1"
        textline "          "
        bitfld.long 0x00 9. " RTA ,Read Transfer Active: This status bit is used for detecting completion of a read transfer." "0,1"
        textline "          "
        bitfld.long 0x00 10. " BWEN ,Buffer Write Enable: This status bit is used for non-DMA write transfers." "0,1"
        textline "          "
        bitfld.long 0x00 11. " BREN ,Buffer Read Enable: This status bit is used for non-DMA read transfers." "0,1"
        textline "          "
        bitfld.long 0x00 12. " RTR ,Re-Tuning Request: (only for SD3.0 SDR104 mode) Host Controller may request Host Driver to execute re-tuning sequence by setting this bit when the data window is shifted by temperature drift and a tuned sampling point does not have a good margin to receive correct data." "0,1"
        textline "          "
        bitfld.long 0x00 15. " TSCD ,Tape Select Change Done : This bit indicates the dealy setting is effective after write CLK_TUNE_CTRL_STATUS register." "0,1"
        textline "          "
        bitfld.long 0x00 16. " CINST ,Card Inserted: This bit indicates whether a card has been inserted." "0,1"
        textline "          "
        bitfld.long 0x00 18. " CDPL ,Card Detect Pin Level: This bit reflects the inverse value of the CD# pin for the card socket." "0,1"
        textline "          "
        bitfld.long 0x00 19. " WPSPL ,Write Protect Switch Pin Level: The Write Protect Switch is supported for memory and combo cards.This bit reflects the inverted value of the WP pin of the card socket." "0,1"
        textline "          "
        bitfld.long 0x00 23. " CLSL ,CMD Line Signal Level: This status is used to check the CMD line level to recover from errors, and for debugging." "0,1"
        textline "          "
        hexmask.long.byte 0x00 24.--32. 1. " DLSL ,DAT[7:0] Line Signal Level: This status is used to check the DAT line level to recover from errors, and for debugging.This is especially useful in detecting the busy signal level from DAT[0]."
width 10.
group.long 0x28++0x3
    line.long 0x00 "PROT_CTRL,Protocol Control"
        bitfld.long 0x00 0. " LCTL ,LED Control: This bit, fully controlled by the Host Driver, is used to caution the user not to remove the card while the card is being accessed." "0,1"
        textline "         "
        hexmask.long.byte 0x00 1.--3. 1. " DTW ,Data Transfer Width: This bit selects the data width of the SD bus for a data transfer."
        textline "         "
        bitfld.long 0x00 3. " D3CD ,DAT3 as Card Detection Pin: If this bit is set, DAT3 should be pulled down to act as a card detection pin." "0,1"
        textline "         "
        hexmask.long.byte 0x00 4.--6. 1. " EMODE ,Endian Mode: The uSDHC supports all three endian modes in data transfer."
        textline "         "
        bitfld.long 0x00 6. " CDTL ,Card Detect Test Level: This is bit is enabled while the Card Detection Signal Selection is set to 1 and it indicates card insertion." "0,1"
        textline "         "
        bitfld.long 0x00 7. " CDSS ,Card Detect Signal Selection: This bit selects the source for the card detection." "0,1"
        textline "         "
        hexmask.long.byte 0x00 8.--10. 1. " DMASEL ,DMA Select: This field is valid while DMA (SDMA or ADMA) is enabled and selects the DMA operation."
        textline "         "
        bitfld.long 0x00 16. " SABGREQ ,Stop At Block Gap Request: This bit is used to stop executing a transaction at the next block gap for both DMA and non-DMA transfers." "0,1"
        textline "         "
        bitfld.long 0x00 17. " CREQ ,Continue Request: This bit is used to restart a transaction which was stopped using the Stop At Block Gap Request." "0,1"
        textline "         "
        bitfld.long 0x00 18. " RWCTL ,Read Wait Control: The read wait function is optional for SDIO cards." "0,1"
        textline "         "
        bitfld.long 0x00 19. " IABG ,Interrupt At Block Gap: This bit is valid only in 4-bit mode, of the SDIO card, and selects a sample point in the interrupt cycle." "0,1"
        textline "         "
        bitfld.long 0x00 20. " RD_DONE_NO_8CLK ,Read done no 8 clock: According to the SD/MMC spec, for read data transaction, 8 clocks are needed after the end bit of the last data block." "0,1"
        textline "         "
        bitfld.long 0x00 24. " WECINT ,Wakeup Event Enable On Card Interrupt: This bit enables a wakeup event, via a Card Interrupt, in the Interrupt Status register." "0,1"
        textline "         "
        bitfld.long 0x00 25. " WECINS ,Wakeup Event Enable On SD Card Insertion: This bit enables a wakeup event, via a Card Insertion, in the Interrupt Status register." "0,1"
        textline "         "
        bitfld.long 0x00 26. " WECRM ,Wakeup Event Enable On SD Card Removal: This bit enables a wakeup event, via a Card Removal, in the Interrupt Status register." "0,1"
        textline "         "
        hexmask.long.byte 0x00 27.--30. 1. " BURST_LEN_EN ,BURST length enable for INCR, INCR4/INCR8/INCR16, INCR4-WRAP/INCR8-WRAP/INCR16-WRAP This is used to enable/disable the burst length for the external AHB2AXI bridge."
        textline "         "
        bitfld.long 0x00 30. " NON_EXACT_BLK_RD ,Current block read is non-exact block read." "0,1"
width 9.
group.long 0x2c++0x3
    line.long 0x00 "SYS_CTRL,System Control"
        hexmask.long.byte 0x00 4.--8. 1. " DVS ,Divisor: This register is used to provide a more exact divisor to generate the desired SD clock frequency."
        textline "        "
        hexmask.long.byte 0x00 8.--16. 1. " SDCLKFS ,SDCLK Frequency Select: This register is used to select the frequency of the SDCLK pin."
        textline "        "
        hexmask.long.byte 0x00 16.--20. 1. " DTOCV ,Data Timeout Counter Value: This value determines the interval by which DAT line timeouts are detected."
        textline "        "
        bitfld.long 0x00 23. " IPP_RST_N ,This register's value will be output to CARD from pad directly for hardware reset of the card if the card supports this feature." "0,1"
        textline "        "
        bitfld.long 0x00 24. " RSTA ,Software Reset For ALL: This reset effects the entire Host Controller except for the card detection circuit." "0,1"
        textline "        "
        bitfld.long 0x00 25. " RSTC ,Software Reset For CMD Line: Only part of the command circuit is reset." "0,1"
        textline "        "
        bitfld.long 0x00 26. " RSTD ,Software Reset For DAT Line: Only part of the data circuit is reset." "0,1"
        textline "        "
        bitfld.long 0x00 27. " INITA ,Initialization Active: When this bit is set, 80 SD-Clocks are sent to the card." "0,1"
        textline "        "
        bitfld.long 0x00 28. " RSTT ,Reset Tuning: When set this bit to 1, it will reset tuning circuit." "0,1"
width 11.
group.long 0x30++0x3
    line.long 0x00 "INT_STATUS,Interrupt Status"
        bitfld.long 0x00 0. " CC ,Command Complete: This bit is set when you receive the end bit of the command response (except Auto CMD12)." "0,1"
        textline "          "
        bitfld.long 0x00 1. " TC ,Transfer Complete: This bit is set when a read or write transfer is completed." "0,1"
        textline "          "
        bitfld.long 0x00 2. " BGE ,Block Gap Event: If the Stop At Block Gap Request bit in the Protocol Control register is set, this bit is set when a read or write transaction is stopped at a block gap." "0,1"
        textline "          "
        bitfld.long 0x00 3. " DINT ,DMA Interrupt: Occurs only when the internal DMA finishes the data transfer successfully." "0,1"
        textline "          "
        bitfld.long 0x00 4. " BWR ,Buffer Write Ready: This status bit is set if the Buffer Write Enable bit, in the Present State register, changes from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 5. " BRR ,Buffer Read Ready: This status bit is set if the Buffer Read Enable bit, in the Present State register, changes from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 6. " CINS ,Card Insertion: This status bit is set if the Card Inserted bit in the Present State register changes from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 7. " CRM ,Card Removal: This status bit is set if the Card Inserted bit in the Present State register changes from 1 to 0." "0,1"
        textline "          "
        bitfld.long 0x00 8. " CINT ,Card Interrupt: This status bit is set when an interrupt signal is detected from the external card." "0,1"
        textline "          "
        bitfld.long 0x00 12. " RTE ,Re-Tuning Event: (only for SD3.0 SDR104 mode) This status is set if Re-Tuning Request in the Present State register changes from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 14. " TP ,Tuning Pass:(only for SD3.0 SDR104 mode) Current CMD19 transfer is done successfully." "0,1"
        textline "          "
        bitfld.long 0x00 16. " CTOE ,Command Timeout Error: Occurs only if no response is returned within 64 SDCLK cycles from the end bit of the command." "0,1"
        textline "          "
        bitfld.long 0x00 17. " CCE ,Command CRC Error: Command CRC Error is generated in two cases." "0,1"
        textline "          "
        bitfld.long 0x00 18. " CEBE ,Command End Bit Error: Occurs when detecting that the end bit of a command response is 0." "0,1"
        textline "          "
        bitfld.long 0x00 19. " CIE ,Command Index Error: Occurs if a Command Index error occurs in the command response." "0,1"
        textline "          "
        bitfld.long 0x00 20. " DTOE ,Data Timeout Error: Occurs when detecting one of following time-out conditions." "0,1"
        textline "          "
        bitfld.long 0x00 21. " DCE ,Data CRC Error: Occurs when detecting a CRC error when transferring read data, which uses the DAT line, or when detecting the Write CRC status having a value other than 010." "0,1"
        textline "          "
        bitfld.long 0x00 22. " DEBE ,Data End Bit Error: Occurs either when detecting 0 at the end bit position of read data, which uses the DAT line, or at the end bit position of the CRC." "0,1"
        textline "          "
        bitfld.long 0x00 24. " AC12E ,Auto CMD12 Error: Occurs when detecting that one of the bits in the Auto CMD12 Error Status register has changed from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 26. " TNE ,Tuning Error: (only for SD3.0 SDR104 mode) This bit is set when an unrecoverable error is detected in a tuning circuit." "0,1"
        textline "          "
        bitfld.long 0x00 28. " DMAE ,DMA Error: Occurs when an Internal DMA transfer has failed." "0,1"
width 14.
group.long 0x34++0x3
    line.long 0x00 "INT_STATUS_EN,Interrupt Status Enable"
        bitfld.long 0x00 0. " CCSEN ,Command Complete Status Enable: 1 Enabled 0 Masked" "0,1"
        textline "             "
        bitfld.long 0x00 1. " TCSEN ,Transfer Complete Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 2. " BGESEN ,Block Gap Event Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 3. " DINTSEN ,DMA Interrupt Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 4. " BWRSEN ,Buffer Write Ready Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 5. " BRRSEN ,Buffer Read Ready Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 6. " CINSSEN ,Card Insertion Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 7. " CRMSEN ,Card Removal Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 8. " CINTSEN ,Card Interrupt Status Enable: If this bit is set to 0, the uSDHC will clear the interrupt request to the System." "0,1"
        textline "             "
        bitfld.long 0x00 12. " RTESEN ,Re-Tuning Event Status Enable" "0,1"
        textline "             "
        bitfld.long 0x00 14. " TPSEN ,Tuning Pass Status Enable" "0,1"
        textline "             "
        bitfld.long 0x00 16. " CTOESEN ,Command Timeout Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 17. " CCESEN ,Command CRC Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 18. " CEBESEN ,Command End Bit Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 19. " CIESEN ,Command Index Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 20. " DTOESEN ,Data Timeout Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 21. " DCESEN ,Data CRC Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 22. " DEBESEN ,Data End Bit Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 24. " AC12ESEN ,Auto CMD12 Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 26. " TNESEN ,Tuning Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 28. " DMAESEN ,DMA Error Status Enable:" "0,1"
width 14.
group.long 0x38++0x3
    line.long 0x00 "INT_SIGNAL_EN,Interrupt Signal Enable"
        bitfld.long 0x00 0. " CCIEN ,Command Complete Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 1. " TCIEN ,Transfer Complete Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 2. " BGEIEN ,Block Gap Event Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 3. " DINTIEN ,DMA Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 4. " BWRIEN ,Buffer Write Ready Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 5. " BRRIEN ,Buffer Read Ready Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 6. " CINSIEN ,Card Insertion Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 7. " CRMIEN ,Card Removal Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 8. " CINTIEN ,Card Interrupt Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 12. " RTEIEN ,Re-Tuning Event Interrupt Enable" "0,1"
        textline "             "
        bitfld.long 0x00 14. " TPIEN ,Tuning Pass Interrupt Enable" "0,1"
        textline "             "
        bitfld.long 0x00 16. " CTOEIEN ,Command Timeout Error Interrupt Enable" "0,1"
        textline "             "
        bitfld.long 0x00 17. " CCEIEN ,Command CRC Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 18. " CEBEIEN ,Command End Bit Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 19. " CIEIEN ,Command Index Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 20. " DTOEIEN ,Data Timeout Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 21. " DCEIEN ,Data CRC Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 22. " DEBEIEN ,Data End Bit Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 24. " AC12EIEN ,Auto CMD12 Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 26. " TNEIEN ,Tuning Error Interrupt Enable" "0,1"
        textline "             "
        bitfld.long 0x00 28. " DMAEIEN ,DMA Error Interrupt Enable:" "0,1"
width 21.
rgroup.long 0x3c++0x3
    line.long 0x00 "AUTOCMD12_ERR_STATUS,Auto CMD12 Error Status"
        bitfld.long 0x00 0. " AC12NE ,Auto CMD12 Not Executed: If memory multiple block data transfer is not started, due to a command error, this bit is not set because it is not necessary to issue an Auto CMD12." "0,1"
        textline "                    "
        bitfld.long 0x00 1. " AC12TOE ,Auto CMD12 Timeout Error: Occurs if no response is returned within 64 SDCLK cycles from the end bit of the command." "0,1"
        textline "                    "
        bitfld.long 0x00 2. " AC12EBE ,Auto CMD12 End Bit Error: Occurs when detecting that the end bit of command response is 0 which should be 1." "0,1"
        textline "                    "
        bitfld.long 0x00 3. " AC12CE ,Auto CMD12 CRC Error: Occurs when detecting a CRC error in the command response." "0,1"
        textline "                    "
        bitfld.long 0x00 4. " AC12IE ,Auto CMD12 Index Error: Occurs if the Command Index error occurs in response to a command." "0,1"
        textline "                    "
        bitfld.long 0x00 7. " CNIBAC12E ,Command Not Issued By Auto CMD12 Error: Setting this bit to 1 means CMD_wo_DAT is not executed due to an Auto CMD12 Error (D04-D01) in this register." "0,1"
        textline "                    "
        bitfld.long 0x00 22. " EXECUTE_TUNING ,Execute Tuning: When std_tuning_en bit is set, this bit is used to start tuning procedure." "0,1"
        textline "                    "
        bitfld.long 0x00 23. " SMP_CLK_SEL ,Sample Clock Select: When std_tuning_en bit is set, this bit is used to select sampling clock to receive CMD and DAT." "0,1"
width 14.
rgroup.long 0x40++0x3
    line.long 0x00 "HOST_CTRL_CAP,Host Controller Capabilities"
        bitfld.long 0x00 0. " SDR50_SUPPORT ,SDR50 support: This bit indicates support of SDR50 mode." "0,1"
        textline "             "
        bitfld.long 0x00 1. " SDR104_SUPPORT ,SDR104 support: This bit indicates support of SDR104 mode." "0,1"
        textline "             "
        bitfld.long 0x00 2. " DDR50_SUPPORT ,DDR50 support: This bit indicates support of DDR50 mode." "0,1"
        textline "             "
        hexmask.long.byte 0x00 8.--12. 1. " TIME_COUNT_RETUNING ,Time counter for retuning: This bit indicates an initial value of the Retuning Timer for Re-Tuning Mode1 and 3.Setting to 0 disables Retuning Timer."
        textline "             "
        bitfld.long 0x00 13. " USE_TUNING_SDR50 ,Use Tuning for SDR50: This bit is set to 1." "0,1"
        textline "             "
        hexmask.long.byte 0x00 14.--16. 1. " RETUNING_MODE ,Retuning Mode: This bit selects retuning method."
        textline "             "
        hexmask.long.byte 0x00 16.--19. 1. " MBL ,Max Block Length: This value indicates the maximum block size that the Host Driver can read and write to the buffer in the uSDHC."
        textline "             "
        bitfld.long 0x00 20. " ADMAS ,ADMA Support: This bit indicates whether the uSDHC supports the ADMA feature." "0,1"
        textline "             "
        bitfld.long 0x00 21. " HSS ,High Speed Support: This bit indicates whether the uSDHC supports High Speed mode and the Host System can supply a SD Clock frequency from 25 MHz to 50 MHz." "0,1"
        textline "             "
        bitfld.long 0x00 22. " DMAS ,DMA Support: This bit indicates whether the uSDHC is capable of using the internal DMA to transfer data between system memory and the data buffer directly." "0,1"
        textline "             "
        bitfld.long 0x00 23. " SRS ,Suspend / Resume Support: This bit indicates whether the uSDHC supports Suspend / Resume functionality." "0,1"
        textline "             "
        bitfld.long 0x00 24. " VS33 ,Voltage Support 3.3V: This bit shall depend on the Host System ability." "0,1"
        textline "             "
        bitfld.long 0x00 25. " VS30 ,Voltage Support 3.0V: This bit shall depend on the Host System ability." "0,1"
        textline "             "
        bitfld.long 0x00 26. " VS18 ,Voltage Support 1.8V: This bit shall depend on the Host System ability." "0,1"
width 9.
group.long 0x44++0x3
    line.long 0x00 "WTMK_LVL,Watermark Level"
        hexmask.long.byte 0x00 0.--8. 1. " RD_WML ,Read Watermark Level: The number of words used as the watermark level (FIFO threshold) in a DMA read operation."
        textline "        "
        hexmask.long.byte 0x00 8.--13. 1. " RD_BRST_LEN ,Read Burst Length: Due to system restriction, the actual burst length may not exceed 16."
        textline "        "
        hexmask.long.byte 0x00 16.--24. 1. " WR_WML ,Write Watermark Level: The number of words used as the watermark level (FIFO threshold) in a DMA write operation."
        textline "        "
        hexmask.long.byte 0x00 24.--29. 1. " WR_BRST_LEN ,Write Burst Length: Due to system restriction, the actual burst length may not exceed 16."
width 9.
group.long 0x48++0x3
    line.long 0x00 "MIX_CTRL,Mixer Control"
        bitfld.long 0x00 0. " DMAEN ,DMA Enable: This bit enables DMA functionality." "0,1"
        textline "        "
        bitfld.long 0x00 1. " BCEN ,Block Count Enable: This bit is used to enable the Block Count register, which is only relevant for multiple block transfers." "0,1"
        textline "        "
        bitfld.long 0x00 2. " AC12EN ,Auto CMD12 Enable: Multiple block transfers for memory require a CMD12 to stop the transaction." "0,1"
        textline "        "
        bitfld.long 0x00 3. " DDR_EN ,Dual Data Rate mode selection" "0,1"
        textline "        "
        bitfld.long 0x00 4. " DTDSEL ,Data Transfer Direction Select: This bit defines the direction of DAT line data transfers." "0,1"
        textline "        "
        bitfld.long 0x00 5. " MSBSEL ,Multi / Single Block Select: This bit enables multiple block DAT line data transfers." "0,1"
        textline "        "
        bitfld.long 0x00 6. " NIBBLE_POS ,In DDR 4-bit mode nibble position indictation." "0,1"
        textline "        "
        bitfld.long 0x00 7. " AC23EN ,Auto CMD23 Enable When this bit is set to 1, the Host Controller issues a CMD23 automatically before issuing a command specified in the Command Register." "0,1"
        textline "        "
        bitfld.long 0x00 22. " EXE_TUNE ,Execute Tuning: (Only used for SD3.0, SDR104 mode) When std_tuning_en is 0, this bit is set to 1 to indicate the Host Driver is starting tuning procedure." "0,1"
        textline "        "
        bitfld.long 0x00 23. " SMP_CLK_SEL ,When std_tuning_en is 0, this bit is used to select Tuned clock or Fixed clock to sample data/cmd (Only used for SD3.0, SDR104 mode)" "0,1"
        textline "        "
        bitfld.long 0x00 24. " AUTO_TUNE_EN ,Auto tuning enable (Only used for SD3.0, SDR104 mode)" "0,1"
        textline "        "
        bitfld.long 0x00 25. " FBCLK_SEL ,Feedback clock source selection (Only used for SD3.0, SDR104 mode)" "0,1"
width 12.
wgroup.long 0x50++0x3
    line.long 0x00 "FORCE_EVENT,Force Event"
        bitfld.long 0x00 0. " FEVTAC12NE ,Force Event Auto Command 12 Not Executed: Forces the AC12NE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 1. " FEVTAC12TOE ,Force Event Auto Command 12 Time Out Error: Forces the AC12TOE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 2. " FEVTAC12CE ,Force Event Auto Command 12 CRC Error: Forces the AC12CE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 3. " FEVTAC12EBE ,Force Event Auto Command 12 End Bit Error: Forces the AC12EBE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 4. " FEVTAC12IE ,Force Event Auto Command 12 Index Error: Forces the AC12IE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 7. " FEVTCNIBAC12E ,Force Event Command Not Executed By Auto Command 12 Error: Forces the CNIBAC12E bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 16. " FEVTCTOE ,Force Event Command Time Out Error: Forces the CTOE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 17. " FEVTCCE ,Force Event Command CRC Error: Forces the CCE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 18. " FEVTCEBE ,Force Event Command End Bit Error: Forces the CEBE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 19. " FEVTCIE ,Force Event Command Index Error: Forces the CCE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 20. " FEVTDTOE ,Force Event Data Time Out Error: Force the DTOE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 21. " FEVTDCE ,Force Event Data CRC Error: Forces the DCE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 22. " FEVTDEBE ,Force Event Data End Bit Error: Forces the DEBE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 24. " FEVTAC12E ,Force Event Auto Command 12 Error: Forces the AC12E bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 26. " FEVTTNE ,Force Tuning Error: Forces the TNE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 28. " FEVTDMAE ,Force Event DMA Error: Forces the DMAE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 31. " FEVTCINT ,Force Event Card Interrupt: Writing 1 to this bit generates a short low-level pulse on the internal DAT[1] line, as if a self clearing interrupt was received from the external card." "0,1"
width 16.
rgroup.long 0x54++0x3
    line.long 0x00 "ADMA_ERR_STATUS,ADMA Error Status Register"
        hexmask.long.byte 0x00 0.--2. 1. " ADMAES ,ADMA Error State (when ADMA Error is occurred.): This field indicates the state of the ADMA when an error has occurred during an ADMA data transfer."
        textline "               "
        bitfld.long 0x00 2. " ADMALME ,ADMA Length Mismatch Error: This error occurs in the following 2 cases: While the Block Count Enable is being set, the total data length specified by the Descriptor table is different from that specified by the Block Count and Block Length Total data length can not be divided by the block length" "0,1"
        textline "               "
        bitfld.long 0x00 3. " ADMADCE ,ADMA Descritor Error: This error occurs when invalid descriptor fetched by ADMA:" "0,1"
width 14.
group.long 0x58++0x3
    line.long 0x00 "ADMA_SYS_ADDR,ADMA System Address"
        hexmask.long.long 0x00 2.--32. 1. " ADS_ADDR ,ADMA System Address: This register holds the word address of the executing command in the Descriptor table."
width 9.
group.long 0x60++0x3
    line.long 0x00 "DLL_CTRL,DLL (Delay Line) Control"
        bitfld.long 0x00 0. " DLL_CTRL_ENABLE ,Set this bit to 1 to enable the DLL and delay chain; otherwise; set to 0 to bypasses DLL." "0,1"
        textline "        "
        bitfld.long 0x00 1. " DLL_CTRL_RESET ,Setting this bit to 1 force a reset on DLL." "0,1"
        textline "        "
        bitfld.long 0x00 2. " DLL_CTRL_SLV_FORCE_UPD ,Setting this bit to 1, forces the slave delay line to update to the DLL calibrated value immediately." "0,1"
        textline "        "
        hexmask.long.byte 0x00 3.--7. 1. " DLL_CTRL_SLV_DLY_TARGET0 ,The delay target for the uSDHC loopback read clock can be programmed in 1/16th increments of an ref_clock half-period."
        textline "        "
        bitfld.long 0x00 7. " DLL_CTRL_GATE_UPDATE ,Set this bit to 1 to prevent the DLL from updating (since when clock_in exists, glitches may appear during DLL updates)." "0,1"
        textline "        "
        bitfld.long 0x00 8. " DLL_CTRL_SLV_OVERRIDE ,Set this bit to 1 to Enable manual override for slave delay chain using SLV_OVERRIDE_VAL; to set 0 to disable manual override." "0,1"
        textline "        "
        hexmask.long.byte 0x00 9.--16. 1. " DLL_CTRL_SLV_OVERRIDE_VAL ,When SLV_OVERRIDE=1 This field is used to select 1 of 128 physical taps manually."
        textline "        "
        hexmask.long.byte 0x00 16.--19. 1. " DLL_CTRL_SLV_DLY_TARGET1 ,Refer to DLL_CTRL_SLV_DLY_TARGET0 below."
        textline "        "
        hexmask.long.byte 0x00 20.--28. 1. " DLL_CTRL_SLV_UPDATE_INT ,Slave delay line update interval."
        textline "        "
        hexmask.long.byte 0x00 28.--32. 1. " DLL_CTRL_REF_UPDATE_INT ,DLL control loop update interval."
width 11.
rgroup.long 0x64++0x3
    line.long 0x00 "DLL_STATUS,DLL Status"
        bitfld.long 0x00 0. " DLL_STS_SLV_LOCK ,Slave delay-line lock status." "0,1"
        textline "          "
        bitfld.long 0x00 1. " DLL_STS_REF_LOCK ,Reference DLL lock status." "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--9. 1. " DLL_STS_SLV_SEL ,Slave delay line select status."
        textline "          "
        hexmask.long.byte 0x00 9.--16. 1. " DLL_STS_REF_SEL ,Reference delay line select taps."
width 21.
group.long 0x68++0x3
    line.long 0x00 "CLK_TUNE_CTRL_STATUS,CLK Tuning Control and Status"
        hexmask.long.byte 0x00 0.--4. 1. " DLY_CELL_SET_POST ,Set the number of delay cells on the feedback clock between CLK_OUT and CLK_POST."
        textline "                    "
        hexmask.long.byte 0x00 4.--8. 1. " DLY_CELL_SET_OUT ,Set the number of delay cells on the feedback clock between CLK_PRE and CLK_OUT."
        textline "                    "
        hexmask.long.byte 0x00 8.--15. 1. " DLY_CELL_SET_PRE ,Set the number of delay cells on the feedback clock between the feedback clock and CLK_PRE."
        textline "                    "
        bitfld.long 0x00 15. " NXT_ERR ,NXT error which means the number of delay cells added on the feedback clock is too large." "0,1"
        textline "                    "
        hexmask.long.byte 0x00 16.--20. 1. " TAP_SEL_POST ,Reflect the number of delay cells added on the feedback clock between CLK_OUT and CLK_POST."
        textline "                    "
        hexmask.long.byte 0x00 20.--24. 1. " TAP_SEL_OUT ,Reflect the number of delay cells added on the feedback clock between CLK_PRE and CLK_OUT."
        textline "                    "
        hexmask.long.byte 0x00 24.--31. 1. " TAP_SEL_PRE ,Reflects the number of delay cells added on the feedback clock between the feedback clock and CLK_PRE."
        textline "                    "
        bitfld.long 0x00 31. " PRE_ERR ,PRE error which means the number of delay cells added on the feedback clock is too small." "0,1"
width 10.
group.long 0xc0++0x3
    line.long 0x00 "VEND_SPEC,Vendor Specific Register"
        bitfld.long 0x00 0. " EXT_DMA_EN ,External DMA Request Enable Enable the request to external DMA." "0,1"
        textline "         "
        bitfld.long 0x00 1. " VSELECT ,Voltage Selection Change the value of output signal VSELECT, to control the voltage on pads for external card." "0,1"
        textline "         "
        bitfld.long 0x00 2. " CONFLICT_CHK_EN ,It's not implemented in uSDHC IP." "0,1"
        textline "         "
        bitfld.long 0x00 3. " AC12_WR_CHKBUSY_EN ,Check busy enable after auto CMD12 for write data packet" "0,1"
        textline "         "
        bitfld.long 0x00 4. " DAT3_CD_POL ,Only for debug." "0,1"
        textline "         "
        bitfld.long 0x00 5. " CD_POL ,Only for debug." "0,1"
        textline "         "
        bitfld.long 0x00 6. " WP_POL ,Only for debug." "0,1"
        textline "         "
        bitfld.long 0x00 7. " CLKONJ_IN_ABORT ,Only for debug." "0,1"
        textline "         "
        bitfld.long 0x00 8. " FRC_SDCLK_ON ,Force CLK output active:" "0,1"
        textline "         "
        bitfld.long 0x00 11. " IPG_CLK_SOFT_EN ,IPG_CLK software enable" "0,1"
        textline "         "
        bitfld.long 0x00 12. " HCLK_SOFT_EN ,Please note, hardware auto-enables the AHB clock when the internal DMA is enabled even if HCLK_SOFT_EN is 0." "0,1"
        textline "         "
        bitfld.long 0x00 13. " IPG_PERCLK_SOFT_EN ,ipg_perclk software enable" "0,1"
        textline "         "
        bitfld.long 0x00 14. " CARD_CLK_SOFT_EN ,card clock software enable" "0,1"
        textline "         "
        bitfld.long 0x00 15. " CRC_CHK_DIS ,CRC check disable" "0,1"
        textline "         "
        hexmask.long.byte 0x00 16.--24. 1. " INT_ST_VAL ,Internal State Value Internal state value, reflecting the corresponding state value selected by Debug Select field."
width 9.
group.long 0xc4++0x3
    line.long 0x00 "MMC_BOOT,MMC Boot Register"
        hexmask.long.byte 0x00 0.--4. 1. " DTOCV_ACK ,Boot ACK time out counter value."
        textline "        "
        bitfld.long 0x00 4. " BOOT_ACK ,Boot ack mode select." "0,1"
        textline "        "
        bitfld.long 0x00 5. " BOOT_MODE ,Boot mode select." "0,1"
        textline "        "
        bitfld.long 0x00 6. " BOOT_EN ,Boot mode enable." "0,1"
        textline "        "
        bitfld.long 0x00 7. " AUTO_SABG_EN ,During boot, enable auto stop at block gap function." "0,1"
        textline "        "
        bitfld.long 0x00 8. " DISABLE_TIME_OUT ,Please note, when this bit is set, there is no timeout check no matter whether boot_en is set or not." "0,1"
        textline "        "
        hexmask.long.word 0x00 16.--32. 1. " BOOT_BLK_CNT ,The value defines the Stop At Block Gap value of automatic mode."
width 11.
group.long 0xc8++0x3
    line.long 0x00 "VEND_SPEC2,Vendor Specific 2 Register"
        bitfld.long 0x00 0. " SDR104_TIMING_DIS ,Timeout counter test." "0,1"
        textline "          "
        bitfld.long 0x00 1. " SDR104_OE_DIS ,CMD_OE/DAT_OE logic generation test." "0,1"
        textline "          "
        bitfld.long 0x00 2. " SDR104_NSD_DIS ,Interrupt window after abort command is sent." "0,1"
        textline "          "
        bitfld.long 0x00 3. " CARD_INT_D3_TEST ,Card interrupt detection test." "0,1"
        textline "          "
        bitfld.long 0x00 4. " TUNING_8BIT_EN ,Enable the auto tuning circuit to check the DAT[7:0]." "0,1"
        textline "          "
        bitfld.long 0x00 5. " TUNING_1BIT_EN ,Enable the auto tuning circuit to check the DAT0 only." "0,1"
        textline "          "
        bitfld.long 0x00 6. " TUNING_CMD_EN ,Enable the auto tuning circuit to check the CMD line." "0,1"
        textline "          "
        bitfld.long 0x00 7. " CARD_INT_AUTO_CLR_DIS ,Disable the feature to clear the Card interrupt status bit when Card Interrupt status enable bit is cleared." "0,1"
width 12.
group.long 0xcc++0x3
    line.long 0x00 "TUNING_CTRL,Tuning Control Register"
        hexmask.long.byte 0x00 0.--8. 1. " TUNING_START_TAP ,The start dealy cell point when send first CMD19 in tuning procedure."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " TUNING_COUNTER ,The MAX repeat CMD19 times in tuning procedure."
        textline "           "
        hexmask.long.byte 0x00 16.--19. 1. " TUNING_STEP ,The increasing delay cell step in tuning procedure."
        textline "           "
        hexmask.long.byte 0x00 20.--23. 1. " TUNING_WINDOW ,Select data window value for auto tuning"
        textline "           "
        bitfld.long 0x00 24. " STD_TUNING_EN ,Standard tuning circuit and procedure enable: This bit is used to enable standard tuning circuit and procedure." "0,1"


    tree.end

tree.end



;--------------------------------------------------------------------------------
; WDOG
;--------------------------------------------------------------------------------
tree.open "WDOG"
    tree "WDOG1"
        base ad:0x020bc000

width 4.
group.word 0x0++0x1
    line.word 0x00 "WCR,Watchdog Control Register"
        bitfld.word 0x00 0. " WDZST ,Watchdog Low Power." "0,1"
        textline "   "
        bitfld.word 0x00 1. " WDBG ,Watchdog DEBUG Enable." "0,1"
        textline "   "
        bitfld.word 0x00 2. " WDE ,Watchdog Enable." "0,1"
        textline "   "
        bitfld.word 0x00 3. " WDT ,WDOG Time-out assertion." "0,1"
        textline "   "
        bitfld.word 0x00 4. " SRS ,Software Reset Signal." "0,1"
        textline "   "
        bitfld.word 0x00 5. " WDA ,WDOG assertion." "0,1"
        textline "   "
        bitfld.word 0x00 6. " SRE ,adopt a new way to generate a more robust software reset." "0,1"
        textline "   "
        bitfld.word 0x00 7. " WDW ,Watchdog Disable for Wait." "0,1"
        textline "   "
        hexmask.word.byte 0x00 8.--16. 1. " WT ,Watchdog Time-out Field."
width 4.
group.word 0x2++0x1
    line.word 0x00 "WSR,Watchdog Service Register"
        hexmask.word.word 0x00 0.--16. 1. " WSR ,Watchdog Service Register."
width 5.
rgroup.word 0x4++0x1
    line.word 0x00 "WRSR,Watchdog Reset Status Register"
        bitfld.word 0x00 0. " SFTW ,Software Reset." "0,1"
        textline "    "
        bitfld.word 0x00 1. " TOUT ,Timeout." "0,1"
        textline "    "
        bitfld.word 0x00 4. " POR ,Power On Reset." "0,1"
width 5.
group.word 0x6++0x1
    line.word 0x00 "WICR,Watchdog Interrupt Control Register"
        hexmask.word.byte 0x00 0.--8. 1. " WICT ,Watchdog Interrupt Count Time-out (WICT) field determines, how long before the counter time-out must the interrupt occur."
        textline "    "
        bitfld.word 0x00 14. " WTIS ,Watchdog TImer Interrupt Status bit will reflect the timer interrupt status, whether interrupt has occurred or not." "0,1"
        textline "    "
        bitfld.word 0x00 15. " WIE ,Watchdog Timer Interrupt enable bit." "0,1"
width 5.
group.word 0x8++0x1
    line.word 0x00 "WMCR,Watchdog Miscellaneous Control Register"
        bitfld.word 0x00 0. " PDE ,Power Down Enable bit." "0,1"


    tree.end
    tree "WDOG2"
        base ad:0x020c0000

width 4.
group.word 0x0++0x1
    line.word 0x00 "WCR,Watchdog Control Register"
        bitfld.word 0x00 0. " WDZST ,Watchdog Low Power." "0,1"
        textline "   "
        bitfld.word 0x00 1. " WDBG ,Watchdog DEBUG Enable." "0,1"
        textline "   "
        bitfld.word 0x00 2. " WDE ,Watchdog Enable." "0,1"
        textline "   "
        bitfld.word 0x00 3. " WDT ,WDOG Time-out assertion." "0,1"
        textline "   "
        bitfld.word 0x00 4. " SRS ,Software Reset Signal." "0,1"
        textline "   "
        bitfld.word 0x00 5. " WDA ,WDOG assertion." "0,1"
        textline "   "
        bitfld.word 0x00 6. " SRE ,adopt a new way to generate a more robust software reset." "0,1"
        textline "   "
        bitfld.word 0x00 7. " WDW ,Watchdog Disable for Wait." "0,1"
        textline "   "
        hexmask.word.byte 0x00 8.--16. 1. " WT ,Watchdog Time-out Field."
width 4.
group.word 0x2++0x1
    line.word 0x00 "WSR,Watchdog Service Register"
        hexmask.word.word 0x00 0.--16. 1. " WSR ,Watchdog Service Register."
width 5.
rgroup.word 0x4++0x1
    line.word 0x00 "WRSR,Watchdog Reset Status Register"
        bitfld.word 0x00 0. " SFTW ,Software Reset." "0,1"
        textline "    "
        bitfld.word 0x00 1. " TOUT ,Timeout." "0,1"
        textline "    "
        bitfld.word 0x00 4. " POR ,Power On Reset." "0,1"
width 5.
group.word 0x6++0x1
    line.word 0x00 "WICR,Watchdog Interrupt Control Register"
        hexmask.word.byte 0x00 0.--8. 1. " WICT ,Watchdog Interrupt Count Time-out (WICT) field determines, how long before the counter time-out must the interrupt occur."
        textline "    "
        bitfld.word 0x00 14. " WTIS ,Watchdog TImer Interrupt Status bit will reflect the timer interrupt status, whether interrupt has occurred or not." "0,1"
        textline "    "
        bitfld.word 0x00 15. " WIE ,Watchdog Timer Interrupt enable bit." "0,1"
width 5.
group.word 0x8++0x1
    line.word 0x00 "WMCR,Watchdog Miscellaneous Control Register"
        bitfld.word 0x00 0. " PDE ,Power Down Enable bit." "0,1"


    tree.end

tree.end



;--------------------------------------------------------------------------------
; XTALOSC24M
;--------------------------------------------------------------------------------
tree "XTALOSC24M"
    base ad:0x020c8000

width 6.
group.long 0x150++0x3
    line.long 0x00 "MISC0,Miscellaneous Register 0"
        bitfld.long 0x00 0. " REFTOP_PWD ,Control bit to power-down the analog bandgap reference circuitry." "0,1"
        textline "     "
        bitfld.long 0x00 3. " REFTOP_SELFBIASOFF ,Control bit to disable the self-bias circuit in the analog bandgap." "0,1"
        textline "     "
        hexmask.long.byte 0x00 4.--7. 1. " REFTOP_VBGADJ ,Not related to oscillator."
        textline "     "
        bitfld.long 0x00 7. " REFTOP_VBGUP ,Status bit which signals that the analog bandgap voltage is up and stable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 11.--13. 1. " STOP_MODE_CONFIG ,Configure the analog behavior in stop mode."
        textline "     "
        hexmask.long.byte 0x00 14.--16. 1. " OSC_I ,This bit field determines the bias current in the 24MHz oscillator."
        textline "     "
        bitfld.long 0x00 16. " OSC_XTALOK ,Status bit which signals that the output of the 24MHz crystal oscillator is stable." "0,1"
        textline "     "
        bitfld.long 0x00 17. " OSC_XTALOK_EN ,Enable bit for the xtal_ok module(24 MHz)" "0,1"
        textline "     "
        hexmask.long.byte 0x00 18.--20. 1. " WBCP_VPW_THRESH ,This signal alters the voltage that the pwell is charged pumped to."
        textline "     "
        bitfld.long 0x00 25. " CLKGATE_CTRL ,This bit allows disabling the clock gate (always un-gated) for the xtal 24MHz clock that clocks the digital logic in the analog block." "0,1"
        textline "     "
        hexmask.long.byte 0x00 26.--29. 1. " CLKGATE_DELAY ,This field specifies the delay between powering up the XTAL 24MHz clock and release the clock to the digital logic inside the analog block."
width 6.
group.long 0x260++0x3
    line.long 0x00 "MISC1,XTAL OSC MISC1 Control Register"
        bitfld.long 0x00 0. " RC_OSC_EN ,RC Osc." "0,1"
        textline "     "
        hexmask.long.byte 0x00 1.--4. 1. " RC_OSC_PROG ,RC osc."
        textline "     "
        bitfld.long 0x00 4. " OSC_SEL ,Select the source for the 24MHz clock." "0,1"
        textline "     "
        bitfld.long 0x00 5. " LPBG_SEL ,Bandgap select." "0,1"
        textline "     "
        bitfld.long 0x00 6. " LPBG_TEST ,Low power bandgap test bit." "0,1"
        textline "     "
        bitfld.long 0x00 7. " REFTOP_IBIAS_OFF ,Low power reftop ibias disable." "0,1"
        textline "     "
        bitfld.long 0x00 8. " L1_PWRGATE ,L1 power gate control." "0,1"
        textline "     "
        bitfld.long 0x00 9. " L2_PWRGATE ,L2 power gate control." "0,1"
        textline "     "
        bitfld.long 0x00 10. " CPU_PWRGATE ,CPU power gate control." "0,1"
        textline "     "
        bitfld.long 0x00 11. " DISPLAY_PWRGATE ,Display logic power gate control." "0,1"
        textline "     "
        bitfld.long 0x00 12. " RWB_EN ,Reverse well bias enable control." "0,1"
        textline "     "
        bitfld.long 0x00 13. " RCOSC_CG_OVERRIDE ,For debug purposes only." "0,1"
        textline "     "
        hexmask.long.byte 0x00 14.--16. 1. " XTALOSC_PWRUP_DELAY ,Specifies the time delay between when the 24MHz xtal is powered up until it is stable and ready to use."
        textline "     "
        bitfld.long 0x00 16. " XTALOSC_PWRUP_STAT ,Status of the 24MHz xtal oscillator." "0,1"


tree.end


